// This file is autogenerated by hexya-generate
// DO NOT MODIFY THIS FILE - ANY CHANGES WILL BE OVERWRITTEN

package attachment

import (
	"github.com/beevik/etree"
	"github.com/hexya-addons/web/domains"
	"github.com/hexya-addons/web/webtypes"
	"github.com/hexya-erp/hexya/src/actions"
	"github.com/hexya-erp/hexya/src/models"
	"github.com/hexya-erp/hexya/src/models/operator"
	"github.com/hexya-erp/hexya/src/models/types"
	"github.com/hexya-erp/hexya/src/models/types/dates"
	"github.com/hexya-erp/pool/m"
	"github.com/hexya-erp/pool/q"
)

// ------- FIELD COLLECTION ----------

// A FieldsCollection is the collection of fields
// of the Attachment model.
type FieldsCollection struct {
	*models.FieldsCollection
}

// AccessToken returns a pointer to the AccessToken Field.
func (c FieldsCollection) AccessToken() *models.Field {
	return c.MustGet("AccessToken")
}

// CheckSum returns a pointer to the CheckSum Field.
func (c FieldsCollection) CheckSum() *models.Field {
	return c.MustGet("CheckSum")
}

// Company returns a pointer to the Company Field.
func (c FieldsCollection) Company() *models.Field {
	return c.MustGet("Company")
}

// CreateDate returns a pointer to the CreateDate Field.
func (c FieldsCollection) CreateDate() *models.Field {
	return c.MustGet("CreateDate")
}

// CreateUID returns a pointer to the CreateUID Field.
func (c FieldsCollection) CreateUID() *models.Field {
	return c.MustGet("CreateUID")
}

// DBDatas returns a pointer to the DBDatas Field.
func (c FieldsCollection) DBDatas() *models.Field {
	return c.MustGet("DBDatas")
}

// Datas returns a pointer to the Datas Field.
func (c FieldsCollection) Datas() *models.Field {
	return c.MustGet("Datas")
}

// Description returns a pointer to the Description Field.
func (c FieldsCollection) Description() *models.Field {
	return c.MustGet("Description")
}

// DisplayName returns a pointer to the DisplayName Field.
func (c FieldsCollection) DisplayName() *models.Field {
	return c.MustGet("DisplayName")
}

// FileSize returns a pointer to the FileSize Field.
func (c FieldsCollection) FileSize() *models.Field {
	return c.MustGet("FileSize")
}

// HexyaExternalID returns a pointer to the HexyaExternalID Field.
func (c FieldsCollection) HexyaExternalID() *models.Field {
	return c.MustGet("HexyaExternalID")
}

// HexyaVersion returns a pointer to the HexyaVersion Field.
func (c FieldsCollection) HexyaVersion() *models.Field {
	return c.MustGet("HexyaVersion")
}

// ID returns a pointer to the ID Field.
func (c FieldsCollection) ID() *models.Field {
	return c.MustGet("ID")
}

// IndexContent returns a pointer to the IndexContent Field.
func (c FieldsCollection) IndexContent() *models.Field {
	return c.MustGet("IndexContent")
}

// LastUpdate returns a pointer to the LastUpdate Field.
func (c FieldsCollection) LastUpdate() *models.Field {
	return c.MustGet("LastUpdate")
}

// MimeType returns a pointer to the MimeType Field.
func (c FieldsCollection) MimeType() *models.Field {
	return c.MustGet("MimeType")
}

// Name returns a pointer to the Name Field.
func (c FieldsCollection) Name() *models.Field {
	return c.MustGet("Name")
}

// Public returns a pointer to the Public Field.
func (c FieldsCollection) Public() *models.Field {
	return c.MustGet("Public")
}

// ResField returns a pointer to the ResField Field.
func (c FieldsCollection) ResField() *models.Field {
	return c.MustGet("ResField")
}

// ResID returns a pointer to the ResID Field.
func (c FieldsCollection) ResID() *models.Field {
	return c.MustGet("ResID")
}

// ResModel returns a pointer to the ResModel Field.
func (c FieldsCollection) ResModel() *models.Field {
	return c.MustGet("ResModel")
}

// ResName returns a pointer to the ResName Field.
func (c FieldsCollection) ResName() *models.Field {
	return c.MustGet("ResName")
}

// StoreFname returns a pointer to the StoreFname Field.
func (c FieldsCollection) StoreFname() *models.Field {
	return c.MustGet("StoreFname")
}

// Type returns a pointer to the Type Field.
func (c FieldsCollection) Type() *models.Field {
	return c.MustGet("Type")
}

// URL returns a pointer to the URL Field.
func (c FieldsCollection) URL() *models.Field {
	return c.MustGet("URL")
}

// WriteDate returns a pointer to the WriteDate Field.
func (c FieldsCollection) WriteDate() *models.Field {
	return c.MustGet("WriteDate")
}

// WriteUID returns a pointer to the WriteUID Field.
func (c FieldsCollection) WriteUID() *models.Field {
	return c.MustGet("WriteUID")
}

// ------- METHOD COLLECTION ----------

// A MethodsCollection is the collection of methods
// of the Attachment model.
type MethodsCollection struct {
	*models.MethodsCollection
}

// pActionArchive holds the metadata of the Attachment.ActionArchive() method
type pActionArchive struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionArchive) Extend(fnct func(m.AttachmentSet)) pActionArchive {
	return pActionArchive{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionArchive) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionArchive{}

// ActionArchive returns a pointer to the ActionArchive Method.
func (c MethodsCollection) ActionArchive() pActionArchive {
	return pActionArchive{
		Method: c.MustGet("ActionArchive"),
	}
}

// pActionGet holds the metadata of the Attachment.ActionGet() method
type pActionGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionGet) Extend(fnct func(m.AttachmentSet) *actions.Action) pActionGet {
	return pActionGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionGet{}

// ActionGet returns a pointer to the ActionGet Method.
func (c MethodsCollection) ActionGet() pActionGet {
	return pActionGet{
		Method: c.MustGet("ActionGet"),
	}
}

// pActionUnarchive holds the metadata of the Attachment.ActionUnarchive() method
type pActionUnarchive struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionUnarchive) Extend(fnct func(m.AttachmentSet)) pActionUnarchive {
	return pActionUnarchive{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionUnarchive) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionUnarchive{}

// ActionUnarchive returns a pointer to the ActionUnarchive Method.
func (c MethodsCollection) ActionUnarchive() pActionUnarchive {
	return pActionUnarchive{
		Method: c.MustGet("ActionUnarchive"),
	}
}

// pAddDomainLimitOffset holds the metadata of the Attachment.AddDomainLimitOffset() method
type pAddDomainLimitOffset struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddDomainLimitOffset) Extend(fnct func(m.AttachmentSet, domains.Domain, int, int, string) m.AttachmentSet) pAddDomainLimitOffset {
	return pAddDomainLimitOffset{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddDomainLimitOffset) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddDomainLimitOffset{}

// AddDomainLimitOffset returns a pointer to the AddDomainLimitOffset Method.
func (c MethodsCollection) AddDomainLimitOffset() pAddDomainLimitOffset {
	return pAddDomainLimitOffset{
		Method: c.MustGet("AddDomainLimitOffset"),
	}
}

// pAddModifiers holds the metadata of the Attachment.AddModifiers() method
type pAddModifiers struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddModifiers) Extend(fnct func(m.AttachmentSet, *etree.Document, map[string]*models.FieldInfo)) pAddModifiers {
	return pAddModifiers{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddModifiers) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddModifiers{}

// AddModifiers returns a pointer to the AddModifiers Method.
func (c MethodsCollection) AddModifiers() pAddModifiers {
	return pAddModifiers{
		Method: c.MustGet("AddModifiers"),
	}
}

// pAddNamesToRelations holds the metadata of the Attachment.AddNamesToRelations() method
type pAddNamesToRelations struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddNamesToRelations) Extend(fnct func(m.AttachmentSet, models.RecordData, map[string]*models.FieldInfo) models.RecordData) pAddNamesToRelations {
	return pAddNamesToRelations{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddNamesToRelations) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddNamesToRelations{}

// AddNamesToRelations returns a pointer to the AddNamesToRelations Method.
func (c MethodsCollection) AddNamesToRelations() pAddNamesToRelations {
	return pAddNamesToRelations{
		Method: c.MustGet("AddNamesToRelations"),
	}
}

// pAggregates holds the metadata of the Attachment.Aggregates() method
type pAggregates struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAggregates) Extend(fnct func(m.AttachmentSet, ...models.FieldName) []m.AttachmentGroupAggregateRow) pAggregates {
	return pAggregates{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAggregates) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAggregates{}

// Aggregates returns a pointer to the Aggregates Method.
func (c MethodsCollection) Aggregates() pAggregates {
	return pAggregates{
		Method: c.MustGet("Aggregates"),
	}
}

// pBrowse holds the metadata of the Attachment.Browse() method
type pBrowse struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pBrowse) Extend(fnct func(m.AttachmentSet, []int64) m.AttachmentSet) pBrowse {
	return pBrowse{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pBrowse) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pBrowse{}

// Browse returns a pointer to the Browse Method.
func (c MethodsCollection) Browse() pBrowse {
	return pBrowse{
		Method: c.MustGet("Browse"),
	}
}

// pBrowseOne holds the metadata of the Attachment.BrowseOne() method
type pBrowseOne struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pBrowseOne) Extend(fnct func(m.AttachmentSet, int64) m.AttachmentSet) pBrowseOne {
	return pBrowseOne{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pBrowseOne) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pBrowseOne{}

// BrowseOne returns a pointer to the BrowseOne Method.
func (c MethodsCollection) BrowseOne() pBrowseOne {
	return pBrowseOne{
		Method: c.MustGet("BrowseOne"),
	}
}

// pCartesianProduct holds the metadata of the Attachment.CartesianProduct() method
type pCartesianProduct struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCartesianProduct) Extend(fnct func(m.AttachmentSet, ...m.AttachmentSet) []m.AttachmentSet) pCartesianProduct {
	return pCartesianProduct{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCartesianProduct) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCartesianProduct{}

// CartesianProduct returns a pointer to the CartesianProduct Method.
func (c MethodsCollection) CartesianProduct() pCartesianProduct {
	return pCartesianProduct{
		Method: c.MustGet("CartesianProduct"),
	}
}

// pCheck holds the metadata of the Attachment.Check() method
type pCheck struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheck) Extend(fnct func(m.AttachmentSet, string, m.AttachmentData)) pCheck {
	return pCheck{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheck) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheck{}

// Check returns a pointer to the Check Method.
func (c MethodsCollection) Check() pCheck {
	return pCheck{
		Method: c.MustGet("Check"),
	}
}

// pCheckAccessRights holds the metadata of the Attachment.CheckAccessRights() method
type pCheckAccessRights struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckAccessRights) Extend(fnct func(m.AttachmentSet, webtypes.CheckAccessRightsArgs) bool) pCheckAccessRights {
	return pCheckAccessRights{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckAccessRights) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckAccessRights{}

// CheckAccessRights returns a pointer to the CheckAccessRights Method.
func (c MethodsCollection) CheckAccessRights() pCheckAccessRights {
	return pCheckAccessRights{
		Method: c.MustGet("CheckAccessRights"),
	}
}

// pCheckContents holds the metadata of the Attachment.CheckContents() method
type pCheckContents struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckContents) Extend(fnct func(m.AttachmentSet, m.AttachmentData) m.AttachmentData) pCheckContents {
	return pCheckContents{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckContents) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckContents{}

// CheckContents returns a pointer to the CheckContents Method.
func (c MethodsCollection) CheckContents() pCheckContents {
	return pCheckContents{
		Method: c.MustGet("CheckContents"),
	}
}

// pCheckExecutionPermission holds the metadata of the Attachment.CheckExecutionPermission() method
type pCheckExecutionPermission struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckExecutionPermission) Extend(fnct func(m.AttachmentSet, *models.Method, ...bool) bool) pCheckExecutionPermission {
	return pCheckExecutionPermission{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckExecutionPermission) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckExecutionPermission{}

// CheckExecutionPermission returns a pointer to the CheckExecutionPermission Method.
func (c MethodsCollection) CheckExecutionPermission() pCheckExecutionPermission {
	return pCheckExecutionPermission{
		Method: c.MustGet("CheckExecutionPermission"),
	}
}

// pCheckRecursion holds the metadata of the Attachment.CheckRecursion() method
type pCheckRecursion struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckRecursion) Extend(fnct func(m.AttachmentSet) bool) pCheckRecursion {
	return pCheckRecursion{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckRecursion) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckRecursion{}

// CheckRecursion returns a pointer to the CheckRecursion Method.
func (c MethodsCollection) CheckRecursion() pCheckRecursion {
	return pCheckRecursion{
		Method: c.MustGet("CheckRecursion"),
	}
}

// pCheckServingAttachments holds the metadata of the Attachment.CheckServingAttachments() method
type pCheckServingAttachments struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckServingAttachments) Extend(fnct func(m.AttachmentSet)) pCheckServingAttachments {
	return pCheckServingAttachments{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckServingAttachments) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckServingAttachments{}

// CheckServingAttachments returns a pointer to the CheckServingAttachments Method.
func (c MethodsCollection) CheckServingAttachments() pCheckServingAttachments {
	return pCheckServingAttachments{
		Method: c.MustGet("CheckServingAttachments"),
	}
}

// pComputeCheckSum holds the metadata of the Attachment.ComputeCheckSum() method
type pComputeCheckSum struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeCheckSum) Extend(fnct func(m.AttachmentSet, string) string) pComputeCheckSum {
	return pComputeCheckSum{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeCheckSum) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeCheckSum{}

// ComputeCheckSum returns a pointer to the ComputeCheckSum Method.
func (c MethodsCollection) ComputeCheckSum() pComputeCheckSum {
	return pComputeCheckSum{
		Method: c.MustGet("ComputeCheckSum"),
	}
}

// pComputeDatas holds the metadata of the Attachment.ComputeDatas() method
type pComputeDatas struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeDatas) Extend(fnct func(m.AttachmentSet) m.AttachmentData) pComputeDatas {
	return pComputeDatas{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeDatas) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeDatas{}

// ComputeDatas returns a pointer to the ComputeDatas Method.
func (c MethodsCollection) ComputeDatas() pComputeDatas {
	return pComputeDatas{
		Method: c.MustGet("ComputeDatas"),
	}
}

// pComputeDisplayName holds the metadata of the Attachment.ComputeDisplayName() method
type pComputeDisplayName struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeDisplayName) Extend(fnct func(m.AttachmentSet) *models.ModelData) pComputeDisplayName {
	return pComputeDisplayName{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeDisplayName) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeDisplayName{}

// ComputeDisplayName returns a pointer to the ComputeDisplayName Method.
func (c MethodsCollection) ComputeDisplayName() pComputeDisplayName {
	return pComputeDisplayName{
		Method: c.MustGet("ComputeDisplayName"),
	}
}

// pComputeLastUpdate holds the metadata of the Attachment.ComputeLastUpdate() method
type pComputeLastUpdate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeLastUpdate) Extend(fnct func(m.AttachmentSet) *models.ModelData) pComputeLastUpdate {
	return pComputeLastUpdate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeLastUpdate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeLastUpdate{}

// ComputeLastUpdate returns a pointer to the ComputeLastUpdate Method.
func (c MethodsCollection) ComputeLastUpdate() pComputeLastUpdate {
	return pComputeLastUpdate{
		Method: c.MustGet("ComputeLastUpdate"),
	}
}

// pComputeMimeType holds the metadata of the Attachment.ComputeMimeType() method
type pComputeMimeType struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeMimeType) Extend(fnct func(m.AttachmentSet, m.AttachmentData) string) pComputeMimeType {
	return pComputeMimeType{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeMimeType) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeMimeType{}

// ComputeMimeType returns a pointer to the ComputeMimeType Method.
func (c MethodsCollection) ComputeMimeType() pComputeMimeType {
	return pComputeMimeType{
		Method: c.MustGet("ComputeMimeType"),
	}
}

// pComputeResName holds the metadata of the Attachment.ComputeResName() method
type pComputeResName struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeResName) Extend(fnct func(m.AttachmentSet) m.AttachmentData) pComputeResName {
	return pComputeResName{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeResName) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeResName{}

// ComputeResName returns a pointer to the ComputeResName Method.
func (c MethodsCollection) ComputeResName() pComputeResName {
	return pComputeResName{
		Method: c.MustGet("ComputeResName"),
	}
}

// pCopy holds the metadata of the Attachment.Copy() method
type pCopy struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCopy) Extend(fnct func(m.AttachmentSet, m.AttachmentData) m.AttachmentSet) pCopy {
	return pCopy{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCopy) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCopy{}

// Copy returns a pointer to the Copy Method.
func (c MethodsCollection) Copy() pCopy {
	return pCopy{
		Method: c.MustGet("Copy"),
	}
}

// pCopyData holds the metadata of the Attachment.CopyData() method
type pCopyData struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCopyData) Extend(fnct func(m.AttachmentSet, m.AttachmentData) m.AttachmentData) pCopyData {
	return pCopyData{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCopyData) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCopyData{}

// CopyData returns a pointer to the CopyData Method.
func (c MethodsCollection) CopyData() pCopyData {
	return pCopyData{
		Method: c.MustGet("CopyData"),
	}
}

// pCreate holds the metadata of the Attachment.Create() method
type pCreate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCreate) Extend(fnct func(m.AttachmentSet, m.AttachmentData) m.AttachmentSet) pCreate {
	return pCreate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCreate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCreate{}

// Create returns a pointer to the Create Method.
func (c MethodsCollection) Create() pCreate {
	return pCreate{
		Method: c.MustGet("Create"),
	}
}

// pDefaultGet holds the metadata of the Attachment.DefaultGet() method
type pDefaultGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pDefaultGet) Extend(fnct func(m.AttachmentSet) m.AttachmentData) pDefaultGet {
	return pDefaultGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pDefaultGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pDefaultGet{}

// DefaultGet returns a pointer to the DefaultGet Method.
func (c MethodsCollection) DefaultGet() pDefaultGet {
	return pDefaultGet{
		Method: c.MustGet("DefaultGet"),
	}
}

// pEnqueue holds the metadata of the Attachment.Enqueue() method
type pEnqueue struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pEnqueue) Extend(fnct func(m.AttachmentSet, string, models.Methoder, ...interface{}) m.QueueJobSet) pEnqueue {
	return pEnqueue{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pEnqueue) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pEnqueue{}

// Enqueue returns a pointer to the Enqueue Method.
func (c MethodsCollection) Enqueue() pEnqueue {
	return pEnqueue{
		Method: c.MustGet("Enqueue"),
	}
}

// pEquals holds the metadata of the Attachment.Equals() method
type pEquals struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pEquals) Extend(fnct func(m.AttachmentSet, m.AttachmentSet) bool) pEquals {
	return pEquals{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pEquals) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pEquals{}

// Equals returns a pointer to the Equals Method.
func (c MethodsCollection) Equals() pEquals {
	return pEquals{
		Method: c.MustGet("Equals"),
	}
}

// pExecuteO2MActions holds the metadata of the Attachment.ExecuteO2MActions() method
type pExecuteO2MActions struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pExecuteO2MActions) Extend(fnct func(m.AttachmentSet, models.FieldName, *models.FieldInfo, interface{}) interface{}) pExecuteO2MActions {
	return pExecuteO2MActions{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pExecuteO2MActions) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pExecuteO2MActions{}

// ExecuteO2MActions returns a pointer to the ExecuteO2MActions Method.
func (c MethodsCollection) ExecuteO2MActions() pExecuteO2MActions {
	return pExecuteO2MActions{
		Method: c.MustGet("ExecuteO2MActions"),
	}
}

// pFetch holds the metadata of the Attachment.Fetch() method
type pFetch struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFetch) Extend(fnct func(m.AttachmentSet) m.AttachmentSet) pFetch {
	return pFetch{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFetch) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFetch{}

// Fetch returns a pointer to the Fetch Method.
func (c MethodsCollection) Fetch() pFetch {
	return pFetch{
		Method: c.MustGet("Fetch"),
	}
}

// pFieldGet holds the metadata of the Attachment.FieldGet() method
type pFieldGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFieldGet) Extend(fnct func(m.AttachmentSet, models.FieldName) *models.FieldInfo) pFieldGet {
	return pFieldGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFieldGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFieldGet{}

// FieldGet returns a pointer to the FieldGet Method.
func (c MethodsCollection) FieldGet() pFieldGet {
	return pFieldGet{
		Method: c.MustGet("FieldGet"),
	}
}

// pFieldsGet holds the metadata of the Attachment.FieldsGet() method
type pFieldsGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFieldsGet) Extend(fnct func(m.AttachmentSet, models.FieldsGetArgs) map[string]*models.FieldInfo) pFieldsGet {
	return pFieldsGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFieldsGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFieldsGet{}

// FieldsGet returns a pointer to the FieldsGet Method.
func (c MethodsCollection) FieldsGet() pFieldsGet {
	return pFieldsGet{
		Method: c.MustGet("FieldsGet"),
	}
}

// pFieldsViewGet holds the metadata of the Attachment.FieldsViewGet() method
type pFieldsViewGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFieldsViewGet) Extend(fnct func(m.AttachmentSet, webtypes.FieldsViewGetParams) *webtypes.FieldsViewData) pFieldsViewGet {
	return pFieldsViewGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFieldsViewGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFieldsViewGet{}

// FieldsViewGet returns a pointer to the FieldsViewGet Method.
func (c MethodsCollection) FieldsViewGet() pFieldsViewGet {
	return pFieldsViewGet{
		Method: c.MustGet("FieldsViewGet"),
	}
}

// pFileDelete holds the metadata of the Attachment.FileDelete() method
type pFileDelete struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFileDelete) Extend(fnct func(m.AttachmentSet, string)) pFileDelete {
	return pFileDelete{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFileDelete) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFileDelete{}

// FileDelete returns a pointer to the FileDelete Method.
func (c MethodsCollection) FileDelete() pFileDelete {
	return pFileDelete{
		Method: c.MustGet("FileDelete"),
	}
}

// pFileGC holds the metadata of the Attachment.FileGC() method
type pFileGC struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFileGC) Extend(fnct func(m.AttachmentSet)) pFileGC {
	return pFileGC{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFileGC) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFileGC{}

// FileGC returns a pointer to the FileGC Method.
func (c MethodsCollection) FileGC() pFileGC {
	return pFileGC{
		Method: c.MustGet("FileGC"),
	}
}

// pFileRead holds the metadata of the Attachment.FileRead() method
type pFileRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFileRead) Extend(fnct func(m.AttachmentSet, string, bool) string) pFileRead {
	return pFileRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFileRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFileRead{}

// FileRead returns a pointer to the FileRead Method.
func (c MethodsCollection) FileRead() pFileRead {
	return pFileRead{
		Method: c.MustGet("FileRead"),
	}
}

// pFileStore holds the metadata of the Attachment.FileStore() method
type pFileStore struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFileStore) Extend(fnct func(m.AttachmentSet) string) pFileStore {
	return pFileStore{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFileStore) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFileStore{}

// FileStore returns a pointer to the FileStore Method.
func (c MethodsCollection) FileStore() pFileStore {
	return pFileStore{
		Method: c.MustGet("FileStore"),
	}
}

// pFileWrite holds the metadata of the Attachment.FileWrite() method
type pFileWrite struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFileWrite) Extend(fnct func(m.AttachmentSet, string, string) string) pFileWrite {
	return pFileWrite{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFileWrite) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFileWrite{}

// FileWrite returns a pointer to the FileWrite Method.
func (c MethodsCollection) FileWrite() pFileWrite {
	return pFileWrite{
		Method: c.MustGet("FileWrite"),
	}
}

// pFiltered holds the metadata of the Attachment.Filtered() method
type pFiltered struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFiltered) Extend(fnct func(m.AttachmentSet, func(m.AttachmentSet) bool) m.AttachmentSet) pFiltered {
	return pFiltered{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFiltered) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFiltered{}

// Filtered returns a pointer to the Filtered Method.
func (c MethodsCollection) Filtered() pFiltered {
	return pFiltered{
		Method: c.MustGet("Filtered"),
	}
}

// pForceStorage holds the metadata of the Attachment.ForceStorage() method
type pForceStorage struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pForceStorage) Extend(fnct func(m.AttachmentSet) bool) pForceStorage {
	return pForceStorage{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pForceStorage) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pForceStorage{}

// ForceStorage returns a pointer to the ForceStorage Method.
func (c MethodsCollection) ForceStorage() pForceStorage {
	return pForceStorage{
		Method: c.MustGet("ForceStorage"),
	}
}

// pFormatRelationFields holds the metadata of the Attachment.FormatRelationFields() method
type pFormatRelationFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFormatRelationFields) Extend(fnct func(m.AttachmentSet, models.RecordData, map[string]*models.FieldInfo) models.RecordData) pFormatRelationFields {
	return pFormatRelationFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFormatRelationFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFormatRelationFields{}

// FormatRelationFields returns a pointer to the FormatRelationFields Method.
func (c MethodsCollection) FormatRelationFields() pFormatRelationFields {
	return pFormatRelationFields{
		Method: c.MustGet("FormatRelationFields"),
	}
}

// pFullPath holds the metadata of the Attachment.FullPath() method
type pFullPath struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFullPath) Extend(fnct func(m.AttachmentSet, string) string) pFullPath {
	return pFullPath{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFullPath) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFullPath{}

// FullPath returns a pointer to the FullPath Method.
func (c MethodsCollection) FullPath() pFullPath {
	return pFullPath{
		Method: c.MustGet("FullPath"),
	}
}

// pGenerateAccessToken holds the metadata of the Attachment.GenerateAccessToken() method
type pGenerateAccessToken struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGenerateAccessToken) Extend(fnct func(m.AttachmentSet) []string) pGenerateAccessToken {
	return pGenerateAccessToken{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGenerateAccessToken) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGenerateAccessToken{}

// GenerateAccessToken returns a pointer to the GenerateAccessToken Method.
func (c MethodsCollection) GenerateAccessToken() pGenerateAccessToken {
	return pGenerateAccessToken{
		Method: c.MustGet("GenerateAccessToken"),
	}
}

// pGenerateToken holds the metadata of the Attachment.GenerateToken() method
type pGenerateToken struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGenerateToken) Extend(fnct func(m.AttachmentSet) string) pGenerateToken {
	return pGenerateToken{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGenerateToken) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGenerateToken{}

// GenerateToken returns a pointer to the GenerateToken Method.
func (c MethodsCollection) GenerateToken() pGenerateToken {
	return pGenerateToken{
		Method: c.MustGet("GenerateToken"),
	}
}

// pGetAttachmentByKey holds the metadata of the Attachment.GetAttachmentByKey() method
type pGetAttachmentByKey struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetAttachmentByKey) Extend(fnct func(m.AttachmentSet, string, q.AttachmentCondition, []string) m.AttachmentSet) pGetAttachmentByKey {
	return pGetAttachmentByKey{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetAttachmentByKey) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetAttachmentByKey{}

// GetAttachmentByKey returns a pointer to the GetAttachmentByKey Method.
func (c MethodsCollection) GetAttachmentByKey() pGetAttachmentByKey {
	return pGetAttachmentByKey{
		Method: c.MustGet("GetAttachmentByKey"),
	}
}

// pGetDatasRelatedValues holds the metadata of the Attachment.GetDatasRelatedValues() method
type pGetDatasRelatedValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetDatasRelatedValues) Extend(fnct func(m.AttachmentSet, string, string) m.AttachmentData) pGetDatasRelatedValues {
	return pGetDatasRelatedValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetDatasRelatedValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetDatasRelatedValues{}

// GetDatasRelatedValues returns a pointer to the GetDatasRelatedValues Method.
func (c MethodsCollection) GetDatasRelatedValues() pGetDatasRelatedValues {
	return pGetDatasRelatedValues{
		Method: c.MustGet("GetDatasRelatedValues"),
	}
}

// pGetFormviewAction holds the metadata of the Attachment.GetFormviewAction() method
type pGetFormviewAction struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetFormviewAction) Extend(fnct func(m.AttachmentSet) *actions.Action) pGetFormviewAction {
	return pGetFormviewAction{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetFormviewAction) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetFormviewAction{}

// GetFormviewAction returns a pointer to the GetFormviewAction Method.
func (c MethodsCollection) GetFormviewAction() pGetFormviewAction {
	return pGetFormviewAction{
		Method: c.MustGet("GetFormviewAction"),
	}
}

// pGetFormviewId holds the metadata of the Attachment.GetFormviewId() method
type pGetFormviewId struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetFormviewId) Extend(fnct func(m.AttachmentSet) string) pGetFormviewId {
	return pGetFormviewId{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetFormviewId) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetFormviewId{}

// GetFormviewId returns a pointer to the GetFormviewId Method.
func (c MethodsCollection) GetFormviewId() pGetFormviewId {
	return pGetFormviewId{
		Method: c.MustGet("GetFormviewId"),
	}
}

// pGetPath holds the metadata of the Attachment.GetPath() method
type pGetPath struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetPath) Extend(fnct func(m.AttachmentSet, string) (string, string)) pGetPath {
	return pGetPath{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetPath) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetPath{}

// GetPath returns a pointer to the GetPath Method.
func (c MethodsCollection) GetPath() pGetPath {
	return pGetPath{
		Method: c.MustGet("GetPath"),
	}
}

// pGetRecord holds the metadata of the Attachment.GetRecord() method
type pGetRecord struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetRecord) Extend(fnct func(m.AttachmentSet, string) m.AttachmentSet) pGetRecord {
	return pGetRecord{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetRecord) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetRecord{}

// GetRecord returns a pointer to the GetRecord Method.
func (c MethodsCollection) GetRecord() pGetRecord {
	return pGetRecord{
		Method: c.MustGet("GetRecord"),
	}
}

// pGetServeAttachment holds the metadata of the Attachment.GetServeAttachment() method
type pGetServeAttachment struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetServeAttachment) Extend(fnct func(m.AttachmentSet, string, q.AttachmentCondition, models.FieldNames, []string) []models.RecordData) pGetServeAttachment {
	return pGetServeAttachment{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetServeAttachment) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetServeAttachment{}

// GetServeAttachment returns a pointer to the GetServeAttachment Method.
func (c MethodsCollection) GetServeAttachment() pGetServeAttachment {
	return pGetServeAttachment{
		Method: c.MustGet("GetServeAttachment"),
	}
}

// pGetServingGroups holds the metadata of the Attachment.GetServingGroups() method
type pGetServingGroups struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetServingGroups) Extend(fnct func(m.AttachmentSet) m.GroupSet) pGetServingGroups {
	return pGetServingGroups{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetServingGroups) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetServingGroups{}

// GetServingGroups returns a pointer to the GetServingGroups Method.
func (c MethodsCollection) GetServingGroups() pGetServingGroups {
	return pGetServingGroups{
		Method: c.MustGet("GetServingGroups"),
	}
}

// pGetToolbar holds the metadata of the Attachment.GetToolbar() method
type pGetToolbar struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetToolbar) Extend(fnct func(m.AttachmentSet) webtypes.Toolbar) pGetToolbar {
	return pGetToolbar{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetToolbar) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetToolbar{}

// GetToolbar returns a pointer to the GetToolbar Method.
func (c MethodsCollection) GetToolbar() pGetToolbar {
	return pGetToolbar{
		Method: c.MustGet("GetToolbar"),
	}
}

// pGroupBy holds the metadata of the Attachment.GroupBy() method
type pGroupBy struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGroupBy) Extend(fnct func(m.AttachmentSet, ...models.FieldName) m.AttachmentSet) pGroupBy {
	return pGroupBy{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGroupBy) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGroupBy{}

// GroupBy returns a pointer to the GroupBy Method.
func (c MethodsCollection) GroupBy() pGroupBy {
	return pGroupBy{
		Method: c.MustGet("GroupBy"),
	}
}

// pIndex holds the metadata of the Attachment.Index() method
type pIndex struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIndex) Extend(fnct func(m.AttachmentSet, string, string) string) pIndex {
	return pIndex{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIndex) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIndex{}

// Index returns a pointer to the Index Method.
func (c MethodsCollection) Index() pIndex {
	return pIndex{
		Method: c.MustGet("Index"),
	}
}

// pIntersect holds the metadata of the Attachment.Intersect() method
type pIntersect struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIntersect) Extend(fnct func(m.AttachmentSet, m.AttachmentSet) m.AttachmentSet) pIntersect {
	return pIntersect{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIntersect) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIntersect{}

// Intersect returns a pointer to the Intersect Method.
func (c MethodsCollection) Intersect() pIntersect {
	return pIntersect{
		Method: c.MustGet("Intersect"),
	}
}

// pInverseDatas holds the metadata of the Attachment.InverseDatas() method
type pInverseDatas struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pInverseDatas) Extend(fnct func(m.AttachmentSet, string)) pInverseDatas {
	return pInverseDatas{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pInverseDatas) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pInverseDatas{}

// InverseDatas returns a pointer to the InverseDatas Method.
func (c MethodsCollection) InverseDatas() pInverseDatas {
	return pInverseDatas{
		Method: c.MustGet("InverseDatas"),
	}
}

// pLimit holds the metadata of the Attachment.Limit() method
type pLimit struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pLimit) Extend(fnct func(m.AttachmentSet, int) m.AttachmentSet) pLimit {
	return pLimit{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pLimit) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pLimit{}

// Limit returns a pointer to the Limit Method.
func (c MethodsCollection) Limit() pLimit {
	return pLimit{
		Method: c.MustGet("Limit"),
	}
}

// pLoad holds the metadata of the Attachment.Load() method
type pLoad struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pLoad) Extend(fnct func(m.AttachmentSet, ...models.FieldName) m.AttachmentSet) pLoad {
	return pLoad{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pLoad) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pLoad{}

// Load returns a pointer to the Load Method.
func (c MethodsCollection) Load() pLoad {
	return pLoad{
		Method: c.MustGet("Load"),
	}
}

// pLoadViews holds the metadata of the Attachment.LoadViews() method
type pLoadViews struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pLoadViews) Extend(fnct func(m.AttachmentSet, webtypes.LoadViewsArgs) *webtypes.LoadViewsData) pLoadViews {
	return pLoadViews{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pLoadViews) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pLoadViews{}

// LoadViews returns a pointer to the LoadViews Method.
func (c MethodsCollection) LoadViews() pLoadViews {
	return pLoadViews{
		Method: c.MustGet("LoadViews"),
	}
}

// pManageGroupsOnFields holds the metadata of the Attachment.ManageGroupsOnFields() method
type pManageGroupsOnFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pManageGroupsOnFields) Extend(fnct func(m.AttachmentSet, *etree.Document, map[string]*models.FieldInfo)) pManageGroupsOnFields {
	return pManageGroupsOnFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pManageGroupsOnFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pManageGroupsOnFields{}

// ManageGroupsOnFields returns a pointer to the ManageGroupsOnFields Method.
func (c MethodsCollection) ManageGroupsOnFields() pManageGroupsOnFields {
	return pManageGroupsOnFields{
		Method: c.MustGet("ManageGroupsOnFields"),
	}
}

// pMarkForGC holds the metadata of the Attachment.MarkForGC() method
type pMarkForGC struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pMarkForGC) Extend(fnct func(m.AttachmentSet, string)) pMarkForGC {
	return pMarkForGC{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pMarkForGC) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pMarkForGC{}

// MarkForGC returns a pointer to the MarkForGC Method.
func (c MethodsCollection) MarkForGC() pMarkForGC {
	return pMarkForGC{
		Method: c.MustGet("MarkForGC"),
	}
}

// pNameGet holds the metadata of the Attachment.NameGet() method
type pNameGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNameGet) Extend(fnct func(m.AttachmentSet) string) pNameGet {
	return pNameGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNameGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNameGet{}

// NameGet returns a pointer to the NameGet Method.
func (c MethodsCollection) NameGet() pNameGet {
	return pNameGet{
		Method: c.MustGet("NameGet"),
	}
}

// pNameSearch holds the metadata of the Attachment.NameSearch() method
type pNameSearch struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNameSearch) Extend(fnct func(m.AttachmentSet, webtypes.NameSearchParams) []webtypes.RecordIDWithName) pNameSearch {
	return pNameSearch{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNameSearch) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNameSearch{}

// NameSearch returns a pointer to the NameSearch Method.
func (c MethodsCollection) NameSearch() pNameSearch {
	return pNameSearch{
		Method: c.MustGet("NameSearch"),
	}
}

// pNew holds the metadata of the Attachment.New() method
type pNew struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNew) Extend(fnct func(m.AttachmentSet, m.AttachmentData) m.AttachmentSet) pNew {
	return pNew{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNew) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNew{}

// New returns a pointer to the New Method.
func (c MethodsCollection) New() pNew {
	return pNew{
		Method: c.MustGet("New"),
	}
}

// pNormalizeM2MData holds the metadata of the Attachment.NormalizeM2MData() method
type pNormalizeM2MData struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNormalizeM2MData) Extend(fnct func(m.AttachmentSet, models.FieldName, *models.FieldInfo, interface{}) interface{}) pNormalizeM2MData {
	return pNormalizeM2MData{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNormalizeM2MData) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNormalizeM2MData{}

// NormalizeM2MData returns a pointer to the NormalizeM2MData Method.
func (c MethodsCollection) NormalizeM2MData() pNormalizeM2MData {
	return pNormalizeM2MData{
		Method: c.MustGet("NormalizeM2MData"),
	}
}

// pOffset holds the metadata of the Attachment.Offset() method
type pOffset struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOffset) Extend(fnct func(m.AttachmentSet, int) m.AttachmentSet) pOffset {
	return pOffset{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOffset) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOffset{}

// Offset returns a pointer to the Offset Method.
func (c MethodsCollection) Offset() pOffset {
	return pOffset{
		Method: c.MustGet("Offset"),
	}
}

// pOnchange holds the metadata of the Attachment.Onchange() method
type pOnchange struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOnchange) Extend(fnct func(m.AttachmentSet, models.OnchangeParams) models.OnchangeResult) pOnchange {
	return pOnchange{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOnchange) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOnchange{}

// Onchange returns a pointer to the Onchange Method.
func (c MethodsCollection) Onchange() pOnchange {
	return pOnchange{
		Method: c.MustGet("Onchange"),
	}
}

// pOrderBy holds the metadata of the Attachment.OrderBy() method
type pOrderBy struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOrderBy) Extend(fnct func(m.AttachmentSet, ...string) m.AttachmentSet) pOrderBy {
	return pOrderBy{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOrderBy) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOrderBy{}

// OrderBy returns a pointer to the OrderBy Method.
func (c MethodsCollection) OrderBy() pOrderBy {
	return pOrderBy{
		Method: c.MustGet("OrderBy"),
	}
}

// pPostAddCreate holds the metadata of the Attachment.PostAddCreate() method
type pPostAddCreate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPostAddCreate) Extend(fnct func(m.AttachmentSet)) pPostAddCreate {
	return pPostAddCreate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPostAddCreate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPostAddCreate{}

// PostAddCreate returns a pointer to the PostAddCreate Method.
func (c MethodsCollection) PostAddCreate() pPostAddCreate {
	return pPostAddCreate{
		Method: c.MustGet("PostAddCreate"),
	}
}

// pPostProcessCreateValues holds the metadata of the Attachment.PostProcessCreateValues() method
type pPostProcessCreateValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPostProcessCreateValues) Extend(fnct func(m.AttachmentSet, models.RecordData)) pPostProcessCreateValues {
	return pPostProcessCreateValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPostProcessCreateValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPostProcessCreateValues{}

// PostProcessCreateValues returns a pointer to the PostProcessCreateValues Method.
func (c MethodsCollection) PostProcessCreateValues() pPostProcessCreateValues {
	return pPostProcessCreateValues{
		Method: c.MustGet("PostProcessCreateValues"),
	}
}

// pPostProcessFilters holds the metadata of the Attachment.PostProcessFilters() method
type pPostProcessFilters struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPostProcessFilters) Extend(fnct func(m.AttachmentSet, map[models.FieldName]models.Conditioner) map[string][]interface{}) pPostProcessFilters {
	return pPostProcessFilters{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPostProcessFilters) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPostProcessFilters{}

// PostProcessFilters returns a pointer to the PostProcessFilters Method.
func (c MethodsCollection) PostProcessFilters() pPostProcessFilters {
	return pPostProcessFilters{
		Method: c.MustGet("PostProcessFilters"),
	}
}

// pProcessCreateValues holds the metadata of the Attachment.ProcessCreateValues() method
type pProcessCreateValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessCreateValues) Extend(fnct func(m.AttachmentSet, models.RecordData) (models.RecordData, models.RecordData)) pProcessCreateValues {
	return pProcessCreateValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessCreateValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessCreateValues{}

// ProcessCreateValues returns a pointer to the ProcessCreateValues Method.
func (c MethodsCollection) ProcessCreateValues() pProcessCreateValues {
	return pProcessCreateValues{
		Method: c.MustGet("ProcessCreateValues"),
	}
}

// pProcessElementAttrs holds the metadata of the Attachment.ProcessElementAttrs() method
type pProcessElementAttrs struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessElementAttrs) Extend(fnct func(m.AttachmentSet, *etree.Element, map[string]*models.FieldInfo) map[string]interface{}) pProcessElementAttrs {
	return pProcessElementAttrs{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessElementAttrs) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessElementAttrs{}

// ProcessElementAttrs returns a pointer to the ProcessElementAttrs Method.
func (c MethodsCollection) ProcessElementAttrs() pProcessElementAttrs {
	return pProcessElementAttrs{
		Method: c.MustGet("ProcessElementAttrs"),
	}
}

// pProcessFieldElementModifiers holds the metadata of the Attachment.ProcessFieldElementModifiers() method
type pProcessFieldElementModifiers struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessFieldElementModifiers) Extend(fnct func(m.AttachmentSet, *etree.Element, map[string]*models.FieldInfo, map[string]interface{}) map[string]interface{}) pProcessFieldElementModifiers {
	return pProcessFieldElementModifiers{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessFieldElementModifiers) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessFieldElementModifiers{}

// ProcessFieldElementModifiers returns a pointer to the ProcessFieldElementModifiers Method.
func (c MethodsCollection) ProcessFieldElementModifiers() pProcessFieldElementModifiers {
	return pProcessFieldElementModifiers{
		Method: c.MustGet("ProcessFieldElementModifiers"),
	}
}

// pProcessView holds the metadata of the Attachment.ProcessView() method
type pProcessView struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessView) Extend(fnct func(m.AttachmentSet, *etree.Document, map[string]*models.FieldInfo) string) pProcessView {
	return pProcessView{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessView) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessView{}

// ProcessView returns a pointer to the ProcessView Method.
func (c MethodsCollection) ProcessView() pProcessView {
	return pProcessView{
		Method: c.MustGet("ProcessView"),
	}
}

// pProcessWriteValues holds the metadata of the Attachment.ProcessWriteValues() method
type pProcessWriteValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessWriteValues) Extend(fnct func(m.AttachmentSet, models.RecordData) models.RecordData) pProcessWriteValues {
	return pProcessWriteValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessWriteValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessWriteValues{}

// ProcessWriteValues returns a pointer to the ProcessWriteValues Method.
func (c MethodsCollection) ProcessWriteValues() pProcessWriteValues {
	return pProcessWriteValues{
		Method: c.MustGet("ProcessWriteValues"),
	}
}

// pRead holds the metadata of the Attachment.Read() method
type pRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pRead) Extend(fnct func(m.AttachmentSet, models.FieldNames) []models.RecordData) pRead {
	return pRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pRead{}

// Read returns a pointer to the Read Method.
func (c MethodsCollection) Read() pRead {
	return pRead{
		Method: c.MustGet("Read"),
	}
}

// pReadGroup holds the metadata of the Attachment.ReadGroup() method
type pReadGroup struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pReadGroup) Extend(fnct func(m.AttachmentSet, webtypes.ReadGroupParams) []models.FieldMap) pReadGroup {
	return pReadGroup{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pReadGroup) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pReadGroup{}

// ReadGroup returns a pointer to the ReadGroup Method.
func (c MethodsCollection) ReadGroup() pReadGroup {
	return pReadGroup{
		Method: c.MustGet("ReadGroup"),
	}
}

// pReadGroupAllowedFields holds the metadata of the Attachment.ReadGroupAllowedFields() method
type pReadGroupAllowedFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pReadGroupAllowedFields) Extend(fnct func(m.AttachmentSet) models.FieldNames) pReadGroupAllowedFields {
	return pReadGroupAllowedFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pReadGroupAllowedFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pReadGroupAllowedFields{}

// ReadGroupAllowedFields returns a pointer to the ReadGroupAllowedFields Method.
func (c MethodsCollection) ReadGroupAllowedFields() pReadGroupAllowedFields {
	return pReadGroupAllowedFields{
		Method: c.MustGet("ReadGroupAllowedFields"),
	}
}

// pSQLFromCondition holds the metadata of the Attachment.SQLFromCondition() method
type pSQLFromCondition struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSQLFromCondition) Extend(fnct func(m.AttachmentSet, *models.Condition) (string, models.SQLParams)) pSQLFromCondition {
	return pSQLFromCondition{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSQLFromCondition) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSQLFromCondition{}

// SQLFromCondition returns a pointer to the SQLFromCondition Method.
func (c MethodsCollection) SQLFromCondition() pSQLFromCondition {
	return pSQLFromCondition{
		Method: c.MustGet("SQLFromCondition"),
	}
}

// pSearch holds the metadata of the Attachment.Search() method
type pSearch struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearch) Extend(fnct func(m.AttachmentSet, q.AttachmentCondition) m.AttachmentSet) pSearch {
	return pSearch{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearch) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearch{}

// Search returns a pointer to the Search Method.
func (c MethodsCollection) Search() pSearch {
	return pSearch{
		Method: c.MustGet("Search"),
	}
}

// pSearchAll holds the metadata of the Attachment.SearchAll() method
type pSearchAll struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchAll) Extend(fnct func(m.AttachmentSet) m.AttachmentSet) pSearchAll {
	return pSearchAll{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchAll) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchAll{}

// SearchAll returns a pointer to the SearchAll Method.
func (c MethodsCollection) SearchAll() pSearchAll {
	return pSearchAll{
		Method: c.MustGet("SearchAll"),
	}
}

// pSearchByName holds the metadata of the Attachment.SearchByName() method
type pSearchByName struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchByName) Extend(fnct func(m.AttachmentSet, string, operator.Operator, q.AttachmentCondition, int) m.AttachmentSet) pSearchByName {
	return pSearchByName{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchByName) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchByName{}

// SearchByName returns a pointer to the SearchByName Method.
func (c MethodsCollection) SearchByName() pSearchByName {
	return pSearchByName{
		Method: c.MustGet("SearchByName"),
	}
}

// pSearchCount holds the metadata of the Attachment.SearchCount() method
type pSearchCount struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchCount) Extend(fnct func(m.AttachmentSet) int) pSearchCount {
	return pSearchCount{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchCount) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchCount{}

// SearchCount returns a pointer to the SearchCount Method.
func (c MethodsCollection) SearchCount() pSearchCount {
	return pSearchCount{
		Method: c.MustGet("SearchCount"),
	}
}

// pSearchDomain holds the metadata of the Attachment.SearchDomain() method
type pSearchDomain struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchDomain) Extend(fnct func(m.AttachmentSet, domains.Domain) m.CommonMixinSet) pSearchDomain {
	return pSearchDomain{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchDomain) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchDomain{}

// SearchDomain returns a pointer to the SearchDomain Method.
func (c MethodsCollection) SearchDomain() pSearchDomain {
	return pSearchDomain{
		Method: c.MustGet("SearchDomain"),
	}
}

// pSearchRead holds the metadata of the Attachment.SearchRead() method
type pSearchRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchRead) Extend(fnct func(m.AttachmentSet, webtypes.SearchParams) []models.RecordData) pSearchRead {
	return pSearchRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchRead{}

// SearchRead returns a pointer to the SearchRead Method.
func (c MethodsCollection) SearchRead() pSearchRead {
	return pSearchRead{
		Method: c.MustGet("SearchRead"),
	}
}

// pSorted holds the metadata of the Attachment.Sorted() method
type pSorted struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSorted) Extend(fnct func(m.AttachmentSet, func(m.AttachmentSet, m.AttachmentSet) bool) m.AttachmentSet) pSorted {
	return pSorted{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSorted) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSorted{}

// Sorted returns a pointer to the Sorted Method.
func (c MethodsCollection) Sorted() pSorted {
	return pSorted{
		Method: c.MustGet("Sorted"),
	}
}

// pSortedByField holds the metadata of the Attachment.SortedByField() method
type pSortedByField struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSortedByField) Extend(fnct func(m.AttachmentSet, models.FieldName, bool) m.AttachmentSet) pSortedByField {
	return pSortedByField{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSortedByField) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSortedByField{}

// SortedByField returns a pointer to the SortedByField Method.
func (c MethodsCollection) SortedByField() pSortedByField {
	return pSortedByField{
		Method: c.MustGet("SortedByField"),
	}
}

// pSortedDefault holds the metadata of the Attachment.SortedDefault() method
type pSortedDefault struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSortedDefault) Extend(fnct func(m.AttachmentSet) m.AttachmentSet) pSortedDefault {
	return pSortedDefault{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSortedDefault) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSortedDefault{}

// SortedDefault returns a pointer to the SortedDefault Method.
func (c MethodsCollection) SortedDefault() pSortedDefault {
	return pSortedDefault{
		Method: c.MustGet("SortedDefault"),
	}
}

// pStorage holds the metadata of the Attachment.Storage() method
type pStorage struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pStorage) Extend(fnct func(m.AttachmentSet) string) pStorage {
	return pStorage{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pStorage) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pStorage{}

// Storage returns a pointer to the Storage Method.
func (c MethodsCollection) Storage() pStorage {
	return pStorage{
		Method: c.MustGet("Storage"),
	}
}

// pSubtract holds the metadata of the Attachment.Subtract() method
type pSubtract struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSubtract) Extend(fnct func(m.AttachmentSet, m.AttachmentSet) m.AttachmentSet) pSubtract {
	return pSubtract{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSubtract) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSubtract{}

// Subtract returns a pointer to the Subtract Method.
func (c MethodsCollection) Subtract() pSubtract {
	return pSubtract{
		Method: c.MustGet("Subtract"),
	}
}

// pSudo holds the metadata of the Attachment.Sudo() method
type pSudo struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSudo) Extend(fnct func(m.AttachmentSet, ...int64) m.AttachmentSet) pSudo {
	return pSudo{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSudo) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSudo{}

// Sudo returns a pointer to the Sudo Method.
func (c MethodsCollection) Sudo() pSudo {
	return pSudo{
		Method: c.MustGet("Sudo"),
	}
}

// pToggleActive holds the metadata of the Attachment.ToggleActive() method
type pToggleActive struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pToggleActive) Extend(fnct func(m.AttachmentSet)) pToggleActive {
	return pToggleActive{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pToggleActive) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pToggleActive{}

// ToggleActive returns a pointer to the ToggleActive Method.
func (c MethodsCollection) ToggleActive() pToggleActive {
	return pToggleActive{
		Method: c.MustGet("ToggleActive"),
	}
}

// pUnion holds the metadata of the Attachment.Union() method
type pUnion struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pUnion) Extend(fnct func(m.AttachmentSet, m.AttachmentSet) m.AttachmentSet) pUnion {
	return pUnion{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pUnion) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pUnion{}

// Union returns a pointer to the Union Method.
func (c MethodsCollection) Union() pUnion {
	return pUnion{
		Method: c.MustGet("Union"),
	}
}

// pUnlink holds the metadata of the Attachment.Unlink() method
type pUnlink struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pUnlink) Extend(fnct func(m.AttachmentSet) int64) pUnlink {
	return pUnlink{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pUnlink) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pUnlink{}

// Unlink returns a pointer to the Unlink Method.
func (c MethodsCollection) Unlink() pUnlink {
	return pUnlink{
		Method: c.MustGet("Unlink"),
	}
}

// pWebReadGroup holds the metadata of the Attachment.WebReadGroup() method
type pWebReadGroup struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWebReadGroup) Extend(fnct func(m.AttachmentSet, webtypes.WebReadGroupParams) webtypes.WebReadGroupResult) pWebReadGroup {
	return pWebReadGroup{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWebReadGroup) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWebReadGroup{}

// WebReadGroup returns a pointer to the WebReadGroup Method.
func (c MethodsCollection) WebReadGroup() pWebReadGroup {
	return pWebReadGroup{
		Method: c.MustGet("WebReadGroup"),
	}
}

// pWebReadGroupPrivate holds the metadata of the Attachment.WebReadGroupPrivate() method
type pWebReadGroupPrivate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWebReadGroupPrivate) Extend(fnct func(m.AttachmentSet, webtypes.WebReadGroupParams) []models.FieldMap) pWebReadGroupPrivate {
	return pWebReadGroupPrivate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWebReadGroupPrivate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWebReadGroupPrivate{}

// WebReadGroupPrivate returns a pointer to the WebReadGroupPrivate Method.
func (c MethodsCollection) WebReadGroupPrivate() pWebReadGroupPrivate {
	return pWebReadGroupPrivate{
		Method: c.MustGet("WebReadGroupPrivate"),
	}
}

// pWebSearchRead holds the metadata of the Attachment.WebSearchRead() method
type pWebSearchRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWebSearchRead) Extend(fnct func(m.AttachmentSet, webtypes.SearchParams) webtypes.SearchReadResult) pWebSearchRead {
	return pWebSearchRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWebSearchRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWebSearchRead{}

// WebSearchRead returns a pointer to the WebSearchRead Method.
func (c MethodsCollection) WebSearchRead() pWebSearchRead {
	return pWebSearchRead{
		Method: c.MustGet("WebSearchRead"),
	}
}

// pWithContext holds the metadata of the Attachment.WithContext() method
type pWithContext struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWithContext) Extend(fnct func(m.AttachmentSet, string, interface{}) m.AttachmentSet) pWithContext {
	return pWithContext{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWithContext) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWithContext{}

// WithContext returns a pointer to the WithContext Method.
func (c MethodsCollection) WithContext() pWithContext {
	return pWithContext{
		Method: c.MustGet("WithContext"),
	}
}

// pWithEnv holds the metadata of the Attachment.WithEnv() method
type pWithEnv struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWithEnv) Extend(fnct func(m.AttachmentSet, models.Environment) m.AttachmentSet) pWithEnv {
	return pWithEnv{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWithEnv) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWithEnv{}

// WithEnv returns a pointer to the WithEnv Method.
func (c MethodsCollection) WithEnv() pWithEnv {
	return pWithEnv{
		Method: c.MustGet("WithEnv"),
	}
}

// pWithNewContext holds the metadata of the Attachment.WithNewContext() method
type pWithNewContext struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWithNewContext) Extend(fnct func(m.AttachmentSet, *types.Context) m.AttachmentSet) pWithNewContext {
	return pWithNewContext{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWithNewContext) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWithNewContext{}

// WithNewContext returns a pointer to the WithNewContext Method.
func (c MethodsCollection) WithNewContext() pWithNewContext {
	return pWithNewContext{
		Method: c.MustGet("WithNewContext"),
	}
}

// pWrite holds the metadata of the Attachment.Write() method
type pWrite struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWrite) Extend(fnct func(m.AttachmentSet, m.AttachmentData) bool) pWrite {
	return pWrite{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWrite) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWrite{}

// Write returns a pointer to the Write Method.
func (c MethodsCollection) Write() pWrite {
	return pWrite{
		Method: c.MustGet("Write"),
	}
}

// ------- DATA STRUCT ---------

// AttachmentData is used to hold values of an Attachment object instance
// when creating or updating a AttachmentSet.
type AttachmentData struct {
	*models.ModelData
}

// Set sets the given field with the given value.
// If the field already exists, then it is updated with value.
// Otherwise, a new entry is inserted.
//
// It returns the given AttachmentData so that calls can be chained
func (d AttachmentData) Set(field models.FieldName, value interface{}) m.AttachmentData {
	return &AttachmentData{
		d.ModelData.Set(field, value),
	}
}

// Unset removes the value of the given field if it exists.
//
// It returns the given ModelData so that calls can be chained
func (d AttachmentData) Unset(field models.FieldName) m.AttachmentData {
	return &AttachmentData{
		d.ModelData.Unset(field),
	}
}

// Copy returns a copy of this AttachmentData
func (d AttachmentData) Copy() m.AttachmentData {
	return &AttachmentData{
		d.ModelData.Copy(),
	}
}

// MergeWith updates this AttachmentData with the given other AttachmentData
// If a field of the other AttachmentData already exists here, the value is overridden,
// otherwise, the field is inserted.
func (d AttachmentData) MergeWith(other m.AttachmentData) {
	d.ModelData.MergeWith(other.Underlying())
}

// AccessToken returns the value of the AccessToken field.
// If this AccessToken is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) AccessToken() string {
	val := d.ModelData.Get(models.NewFieldName("AccessToken", "access_token"))
	if !d.Has(models.NewFieldName("AccessToken", "access_token")) {
		return *new(string)
	}
	return val.(string)
}

// HasAccessToken returns true if AccessToken is set in this AttachmentData
func (d AttachmentData) HasAccessToken() bool {
	return d.ModelData.Has(models.NewFieldName("AccessToken", "access_token"))
}

// SetAccessToken sets the AccessToken field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetAccessToken(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("AccessToken", "access_token"), value)
	return d
}

// UnsetAccessToken removes the value of the AccessToken field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetAccessToken() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("AccessToken", "access_token"))
	return d
}

// CheckSum returns the value of the CheckSum field.
// If this CheckSum is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) CheckSum() string {
	val := d.ModelData.Get(models.NewFieldName("CheckSum", "check_sum"))
	if !d.Has(models.NewFieldName("CheckSum", "check_sum")) {
		return *new(string)
	}
	return val.(string)
}

// HasCheckSum returns true if CheckSum is set in this AttachmentData
func (d AttachmentData) HasCheckSum() bool {
	return d.ModelData.Has(models.NewFieldName("CheckSum", "check_sum"))
}

// SetCheckSum sets the CheckSum field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetCheckSum(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("CheckSum", "check_sum"), value)
	return d
}

// UnsetCheckSum removes the value of the CheckSum field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetCheckSum() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("CheckSum", "check_sum"))
	return d
}

// Company returns the value of the Company field.
// If this Company is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) Company() m.CompanySet {
	val := d.ModelData.Get(models.NewFieldName("Company", "company_id"))
	if !d.Has(models.NewFieldName("Company", "company_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Company")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.CompanySet)
}

// HasCompany returns true if Company is set in this AttachmentData
func (d AttachmentData) HasCompany() bool {
	return d.ModelData.Has(models.NewFieldName("Company", "company_id"))
}

// SetCompany sets the Company field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetCompany(value m.CompanySet) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("Company", "company_id"), value)
	return d
}

// UnsetCompany removes the value of the Company field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetCompany() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("Company", "company_id"))
	return d
}

// CreateCompany stores the related CompanyData to be used to create
// a related record on the fly for Company.
//
// This method can be called multiple times to create multiple records
func (d AttachmentData) CreateCompany(related m.CompanyData) m.AttachmentData {
	d.ModelData.Create(models.NewFieldName("Company", "company_id"), related.Underlying())
	return d
}

// CreateDate returns the value of the CreateDate field.
// If this CreateDate is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) CreateDate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("CreateDate", "create_date"))
	if !d.Has(models.NewFieldName("CreateDate", "create_date")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasCreateDate returns true if CreateDate is set in this AttachmentData
func (d AttachmentData) HasCreateDate() bool {
	return d.ModelData.Has(models.NewFieldName("CreateDate", "create_date"))
}

// SetCreateDate sets the CreateDate field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetCreateDate(value dates.DateTime) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("CreateDate", "create_date"), value)
	return d
}

// UnsetCreateDate removes the value of the CreateDate field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetCreateDate() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("CreateDate", "create_date"))
	return d
}

// CreateUID returns the value of the CreateUID field.
// If this CreateUID is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) CreateUID() int64 {
	val := d.ModelData.Get(models.NewFieldName("CreateUID", "create_uid"))
	if !d.Has(models.NewFieldName("CreateUID", "create_uid")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasCreateUID returns true if CreateUID is set in this AttachmentData
func (d AttachmentData) HasCreateUID() bool {
	return d.ModelData.Has(models.NewFieldName("CreateUID", "create_uid"))
}

// SetCreateUID sets the CreateUID field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetCreateUID(value int64) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("CreateUID", "create_uid"), value)
	return d
}

// UnsetCreateUID removes the value of the CreateUID field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetCreateUID() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("CreateUID", "create_uid"))
	return d
}

// DBDatas returns the value of the DBDatas field.
// If this DBDatas is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) DBDatas() string {
	val := d.ModelData.Get(models.NewFieldName("DBDatas", "db_datas"))
	if !d.Has(models.NewFieldName("DBDatas", "db_datas")) {
		return *new(string)
	}
	return val.(string)
}

// HasDBDatas returns true if DBDatas is set in this AttachmentData
func (d AttachmentData) HasDBDatas() bool {
	return d.ModelData.Has(models.NewFieldName("DBDatas", "db_datas"))
}

// SetDBDatas sets the DBDatas field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetDBDatas(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("DBDatas", "db_datas"), value)
	return d
}

// UnsetDBDatas removes the value of the DBDatas field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetDBDatas() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("DBDatas", "db_datas"))
	return d
}

// Datas returns the value of the Datas field.
// If this Datas is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) Datas() string {
	val := d.ModelData.Get(models.NewFieldName("Datas", "datas"))
	if !d.Has(models.NewFieldName("Datas", "datas")) {
		return *new(string)
	}
	return val.(string)
}

// HasDatas returns true if Datas is set in this AttachmentData
func (d AttachmentData) HasDatas() bool {
	return d.ModelData.Has(models.NewFieldName("Datas", "datas"))
}

// SetDatas sets the Datas field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetDatas(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("Datas", "datas"), value)
	return d
}

// UnsetDatas removes the value of the Datas field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetDatas() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("Datas", "datas"))
	return d
}

// Description returns the value of the Description field.
// If this Description is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) Description() string {
	val := d.ModelData.Get(models.NewFieldName("Description", "description"))
	if !d.Has(models.NewFieldName("Description", "description")) {
		return *new(string)
	}
	return val.(string)
}

// HasDescription returns true if Description is set in this AttachmentData
func (d AttachmentData) HasDescription() bool {
	return d.ModelData.Has(models.NewFieldName("Description", "description"))
}

// SetDescription sets the Description field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetDescription(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("Description", "description"), value)
	return d
}

// UnsetDescription removes the value of the Description field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetDescription() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("Description", "description"))
	return d
}

// DisplayName returns the value of the DisplayName field.
// If this DisplayName is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) DisplayName() string {
	val := d.ModelData.Get(models.NewFieldName("DisplayName", "display_name"))
	if !d.Has(models.NewFieldName("DisplayName", "display_name")) {
		return *new(string)
	}
	return val.(string)
}

// HasDisplayName returns true if DisplayName is set in this AttachmentData
func (d AttachmentData) HasDisplayName() bool {
	return d.ModelData.Has(models.NewFieldName("DisplayName", "display_name"))
}

// SetDisplayName sets the DisplayName field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetDisplayName(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("DisplayName", "display_name"), value)
	return d
}

// UnsetDisplayName removes the value of the DisplayName field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetDisplayName() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("DisplayName", "display_name"))
	return d
}

// FileSize returns the value of the FileSize field.
// If this FileSize is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) FileSize() int {
	val := d.ModelData.Get(models.NewFieldName("FileSize", "file_size"))
	if !d.Has(models.NewFieldName("FileSize", "file_size")) {
		return *new(int)
	}
	return val.(int)
}

// HasFileSize returns true if FileSize is set in this AttachmentData
func (d AttachmentData) HasFileSize() bool {
	return d.ModelData.Has(models.NewFieldName("FileSize", "file_size"))
}

// SetFileSize sets the FileSize field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetFileSize(value int) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("FileSize", "file_size"), value)
	return d
}

// UnsetFileSize removes the value of the FileSize field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetFileSize() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("FileSize", "file_size"))
	return d
}

// HexyaExternalID returns the value of the HexyaExternalID field.
// If this HexyaExternalID is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) HexyaExternalID() string {
	val := d.ModelData.Get(models.NewFieldName("HexyaExternalID", "hexya_external_id"))
	if !d.Has(models.NewFieldName("HexyaExternalID", "hexya_external_id")) {
		return *new(string)
	}
	return val.(string)
}

// HasHexyaExternalID returns true if HexyaExternalID is set in this AttachmentData
func (d AttachmentData) HasHexyaExternalID() bool {
	return d.ModelData.Has(models.NewFieldName("HexyaExternalID", "hexya_external_id"))
}

// SetHexyaExternalID sets the HexyaExternalID field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetHexyaExternalID(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("HexyaExternalID", "hexya_external_id"), value)
	return d
}

// UnsetHexyaExternalID removes the value of the HexyaExternalID field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetHexyaExternalID() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("HexyaExternalID", "hexya_external_id"))
	return d
}

// HexyaVersion returns the value of the HexyaVersion field.
// If this HexyaVersion is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) HexyaVersion() int {
	val := d.ModelData.Get(models.NewFieldName("HexyaVersion", "hexya_version"))
	if !d.Has(models.NewFieldName("HexyaVersion", "hexya_version")) {
		return *new(int)
	}
	return val.(int)
}

// HasHexyaVersion returns true if HexyaVersion is set in this AttachmentData
func (d AttachmentData) HasHexyaVersion() bool {
	return d.ModelData.Has(models.NewFieldName("HexyaVersion", "hexya_version"))
}

// SetHexyaVersion sets the HexyaVersion field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetHexyaVersion(value int) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("HexyaVersion", "hexya_version"), value)
	return d
}

// UnsetHexyaVersion removes the value of the HexyaVersion field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetHexyaVersion() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("HexyaVersion", "hexya_version"))
	return d
}

// ID returns the value of the ID field.
// If this ID is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) ID() int64 {
	val := d.ModelData.Get(models.NewFieldName("ID", "id"))
	if !d.Has(models.NewFieldName("ID", "id")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasID returns true if ID is set in this AttachmentData
func (d AttachmentData) HasID() bool {
	return d.ModelData.Has(models.NewFieldName("ID", "id"))
}

// SetID sets the ID field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetID(value int64) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("ID", "id"), value)
	return d
}

// UnsetID removes the value of the ID field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetID() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("ID", "id"))
	return d
}

// IndexContent returns the value of the IndexContent field.
// If this IndexContent is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) IndexContent() string {
	val := d.ModelData.Get(models.NewFieldName("IndexContent", "index_content"))
	if !d.Has(models.NewFieldName("IndexContent", "index_content")) {
		return *new(string)
	}
	return val.(string)
}

// HasIndexContent returns true if IndexContent is set in this AttachmentData
func (d AttachmentData) HasIndexContent() bool {
	return d.ModelData.Has(models.NewFieldName("IndexContent", "index_content"))
}

// SetIndexContent sets the IndexContent field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetIndexContent(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("IndexContent", "index_content"), value)
	return d
}

// UnsetIndexContent removes the value of the IndexContent field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetIndexContent() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("IndexContent", "index_content"))
	return d
}

// LastUpdate returns the value of the LastUpdate field.
// If this LastUpdate is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) LastUpdate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("LastUpdate", "__last_update"))
	if !d.Has(models.NewFieldName("LastUpdate", "__last_update")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasLastUpdate returns true if LastUpdate is set in this AttachmentData
func (d AttachmentData) HasLastUpdate() bool {
	return d.ModelData.Has(models.NewFieldName("LastUpdate", "__last_update"))
}

// SetLastUpdate sets the LastUpdate field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetLastUpdate(value dates.DateTime) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("LastUpdate", "__last_update"), value)
	return d
}

// UnsetLastUpdate removes the value of the LastUpdate field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetLastUpdate() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("LastUpdate", "__last_update"))
	return d
}

// MimeType returns the value of the MimeType field.
// If this MimeType is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) MimeType() string {
	val := d.ModelData.Get(models.NewFieldName("MimeType", "mime_type"))
	if !d.Has(models.NewFieldName("MimeType", "mime_type")) {
		return *new(string)
	}
	return val.(string)
}

// HasMimeType returns true if MimeType is set in this AttachmentData
func (d AttachmentData) HasMimeType() bool {
	return d.ModelData.Has(models.NewFieldName("MimeType", "mime_type"))
}

// SetMimeType sets the MimeType field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetMimeType(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("MimeType", "mime_type"), value)
	return d
}

// UnsetMimeType removes the value of the MimeType field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetMimeType() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("MimeType", "mime_type"))
	return d
}

// Name returns the value of the Name field.
// If this Name is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) Name() string {
	val := d.ModelData.Get(models.NewFieldName("Name", "name"))
	if !d.Has(models.NewFieldName("Name", "name")) {
		return *new(string)
	}
	return val.(string)
}

// HasName returns true if Name is set in this AttachmentData
func (d AttachmentData) HasName() bool {
	return d.ModelData.Has(models.NewFieldName("Name", "name"))
}

// SetName sets the Name field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetName(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("Name", "name"), value)
	return d
}

// UnsetName removes the value of the Name field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetName() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("Name", "name"))
	return d
}

// Public returns the value of the Public field.
// If this Public is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) Public() bool {
	val := d.ModelData.Get(models.NewFieldName("Public", "public"))
	if !d.Has(models.NewFieldName("Public", "public")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasPublic returns true if Public is set in this AttachmentData
func (d AttachmentData) HasPublic() bool {
	return d.ModelData.Has(models.NewFieldName("Public", "public"))
}

// SetPublic sets the Public field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetPublic(value bool) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("Public", "public"), value)
	return d
}

// UnsetPublic removes the value of the Public field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetPublic() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("Public", "public"))
	return d
}

// ResField returns the value of the ResField field.
// If this ResField is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) ResField() string {
	val := d.ModelData.Get(models.NewFieldName("ResField", "res_field"))
	if !d.Has(models.NewFieldName("ResField", "res_field")) {
		return *new(string)
	}
	return val.(string)
}

// HasResField returns true if ResField is set in this AttachmentData
func (d AttachmentData) HasResField() bool {
	return d.ModelData.Has(models.NewFieldName("ResField", "res_field"))
}

// SetResField sets the ResField field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetResField(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("ResField", "res_field"), value)
	return d
}

// UnsetResField removes the value of the ResField field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetResField() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("ResField", "res_field"))
	return d
}

// ResID returns the value of the ResID field.
// If this ResID is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) ResID() int64 {
	val := d.ModelData.Get(models.NewFieldName("ResID", "res_id"))
	if !d.Has(models.NewFieldName("ResID", "res_id")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasResID returns true if ResID is set in this AttachmentData
func (d AttachmentData) HasResID() bool {
	return d.ModelData.Has(models.NewFieldName("ResID", "res_id"))
}

// SetResID sets the ResID field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetResID(value int64) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("ResID", "res_id"), value)
	return d
}

// UnsetResID removes the value of the ResID field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetResID() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("ResID", "res_id"))
	return d
}

// ResModel returns the value of the ResModel field.
// If this ResModel is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) ResModel() string {
	val := d.ModelData.Get(models.NewFieldName("ResModel", "res_model"))
	if !d.Has(models.NewFieldName("ResModel", "res_model")) {
		return *new(string)
	}
	return val.(string)
}

// HasResModel returns true if ResModel is set in this AttachmentData
func (d AttachmentData) HasResModel() bool {
	return d.ModelData.Has(models.NewFieldName("ResModel", "res_model"))
}

// SetResModel sets the ResModel field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetResModel(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("ResModel", "res_model"), value)
	return d
}

// UnsetResModel removes the value of the ResModel field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetResModel() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("ResModel", "res_model"))
	return d
}

// ResName returns the value of the ResName field.
// If this ResName is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) ResName() string {
	val := d.ModelData.Get(models.NewFieldName("ResName", "res_name"))
	if !d.Has(models.NewFieldName("ResName", "res_name")) {
		return *new(string)
	}
	return val.(string)
}

// HasResName returns true if ResName is set in this AttachmentData
func (d AttachmentData) HasResName() bool {
	return d.ModelData.Has(models.NewFieldName("ResName", "res_name"))
}

// SetResName sets the ResName field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetResName(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("ResName", "res_name"), value)
	return d
}

// UnsetResName removes the value of the ResName field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetResName() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("ResName", "res_name"))
	return d
}

// StoreFname returns the value of the StoreFname field.
// If this StoreFname is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) StoreFname() string {
	val := d.ModelData.Get(models.NewFieldName("StoreFname", "store_fname"))
	if !d.Has(models.NewFieldName("StoreFname", "store_fname")) {
		return *new(string)
	}
	return val.(string)
}

// HasStoreFname returns true if StoreFname is set in this AttachmentData
func (d AttachmentData) HasStoreFname() bool {
	return d.ModelData.Has(models.NewFieldName("StoreFname", "store_fname"))
}

// SetStoreFname sets the StoreFname field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetStoreFname(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("StoreFname", "store_fname"), value)
	return d
}

// UnsetStoreFname removes the value of the StoreFname field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetStoreFname() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("StoreFname", "store_fname"))
	return d
}

// Type returns the value of the Type field.
// If this Type is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) Type() string {
	val := d.ModelData.Get(models.NewFieldName("Type", "type"))
	if !d.Has(models.NewFieldName("Type", "type")) {
		return *new(string)
	}
	return val.(string)
}

// HasType returns true if Type is set in this AttachmentData
func (d AttachmentData) HasType() bool {
	return d.ModelData.Has(models.NewFieldName("Type", "type"))
}

// SetType sets the Type field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetType(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("Type", "type"), value)
	return d
}

// UnsetType removes the value of the Type field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetType() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("Type", "type"))
	return d
}

// URL returns the value of the URL field.
// If this URL is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) URL() string {
	val := d.ModelData.Get(models.NewFieldName("URL", "url"))
	if !d.Has(models.NewFieldName("URL", "url")) {
		return *new(string)
	}
	return val.(string)
}

// HasURL returns true if URL is set in this AttachmentData
func (d AttachmentData) HasURL() bool {
	return d.ModelData.Has(models.NewFieldName("URL", "url"))
}

// SetURL sets the URL field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetURL(value string) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("URL", "url"), value)
	return d
}

// UnsetURL removes the value of the URL field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetURL() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("URL", "url"))
	return d
}

// WriteDate returns the value of the WriteDate field.
// If this WriteDate is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) WriteDate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("WriteDate", "write_date"))
	if !d.Has(models.NewFieldName("WriteDate", "write_date")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasWriteDate returns true if WriteDate is set in this AttachmentData
func (d AttachmentData) HasWriteDate() bool {
	return d.ModelData.Has(models.NewFieldName("WriteDate", "write_date"))
}

// SetWriteDate sets the WriteDate field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetWriteDate(value dates.DateTime) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("WriteDate", "write_date"), value)
	return d
}

// UnsetWriteDate removes the value of the WriteDate field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetWriteDate() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("WriteDate", "write_date"))
	return d
}

// WriteUID returns the value of the WriteUID field.
// If this WriteUID is not set in this AttachmentData, then
// the Go zero value for the type is returned.
func (d AttachmentData) WriteUID() int64 {
	val := d.ModelData.Get(models.NewFieldName("WriteUID", "write_uid"))
	if !d.Has(models.NewFieldName("WriteUID", "write_uid")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasWriteUID returns true if WriteUID is set in this AttachmentData
func (d AttachmentData) HasWriteUID() bool {
	return d.ModelData.Has(models.NewFieldName("WriteUID", "write_uid"))
}

// SetWriteUID sets the WriteUID field with the given value.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) SetWriteUID(value int64) m.AttachmentData {
	d.ModelData.Set(models.NewFieldName("WriteUID", "write_uid"), value)
	return d
}

// UnsetWriteUID removes the value of the WriteUID field if it exists.
// It returns this AttachmentData so that calls can be chained.
func (d AttachmentData) UnsetWriteUID() m.AttachmentData {
	d.ModelData.Unset(models.NewFieldName("WriteUID", "write_uid"))
	return d
}

var _ m.AttachmentData = new(AttachmentData)
var _ m.AttachmentData = AttachmentData{}

// ------ AGGREGATE ROW --------

// A AttachmentGroupAggregateRow holds a row of results of a query with a group by clause
// - Values holds the values of the actual query
// - Count is the number of lines aggregated into this one
// - Condition can be used to query the aggregated rows separately if needed
type AttachmentGroupAggregateRow struct {
	values    m.AttachmentData
	count     int
	condition q.AttachmentCondition
}

// Values returns the values of the actual query
func (a AttachmentGroupAggregateRow) Values() m.AttachmentData {
	return a.values
}

// Count returns the number of lines aggregated into this one
func (a AttachmentGroupAggregateRow) Count() int {
	return a.count
}

// Condition can be used to query the aggregated rows separately if needed
func (a AttachmentGroupAggregateRow) Condition() q.AttachmentCondition {
	return a.condition
}

// ------- RECORD SET ---------

// AttachmentSet is an autogenerated type to handle Attachment objects.
type AttachmentSet struct {
	*models.RecordCollection
}

var _ models.RecordSet = AttachmentSet{}

// AttachmentSetHexyaFunc is a dummy function to uniquely match interfaces.
func (s AttachmentSet) AttachmentSetHexyaFunc() {}

// IsValid returns true if this RecordSet has been initialized.
func (s AttachmentSet) IsValid() bool {
	if s.RecordCollection == nil {
		return false
	}
	return s.RecordCollection.IsValid()
}

// ForceLoad reloads the cache for the given fields and updates the ids of this AttachmentSet.
//
// If no fields are given, all DB columns of the Attachment model are retrieved.
//
// It also returns this AttachmentSet.
func (s AttachmentSet) ForceLoad(fields ...models.FieldName) m.AttachmentSet {
	s.RecordCollection.ForceLoad(fields...)
	return s
}

// Records returns a slice with all the records of this RecordSet, as singleton
// RecordSets
func (s AttachmentSet) Records() []m.AttachmentSet {
	recs := s.RecordCollection.Records()
	res := make([]m.AttachmentSet, len(recs))
	for i, rec := range recs {
		res[i] = rec.Wrap("Attachment").(m.AttachmentSet)
	}
	return res
}

// CartesianProduct returns the cartesian product of this AttachmentSet with others.
func (s AttachmentSet) CartesianProduct(others ...m.AttachmentSet) []m.AttachmentSet {
	otherSet := make([]models.RecordSet, len(others))
	for i, o := range others {
		otherSet[i] = o
	}
	recs := s.RecordCollection.CartesianProduct(otherSet...)
	res := make([]m.AttachmentSet, len(recs))
	for i, rec := range recs {
		res[i] = rec.Wrap("Attachment").(m.AttachmentSet)
	}
	return res
}

// First returns the values of the first Record of the RecordSet as a pointer to a AttachmentData.
//
// If this RecordSet is empty, it returns an empty AttachmentData.
func (s AttachmentSet) First() m.AttachmentData {
	return &AttachmentData{
		s.RecordCollection.First(),
	}
}

// All returns the values of all Records of the RecordCollection as a slice of AttachmentData pointers.
func (s AttachmentSet) All() []m.AttachmentData {
	allSlice := s.RecordCollection.All()
	res := make([]m.AttachmentData, len(allSlice))
	for i, v := range allSlice {
		res[i] = &AttachmentData{v}
	}
	return res
}

// Sorted returns a new AttachmentSet sorted according to the given less function.
//
// The less function should return true if rs1 < rs2
func (s AttachmentSet) Sorted(less func(rs1, rs2 m.AttachmentSet) bool) m.AttachmentSet {
	res := s.RecordCollection.Sorted(func(rc1 models.RecordSet, rc2 models.RecordSet) bool {
		return less(AttachmentSet{RecordCollection: rc1.Collection()}, AttachmentSet{RecordCollection: rc2.Collection()})
	})
	return res.Wrap("Attachment").(m.AttachmentSet)
}

// Filtered returns a new AttachmentSet with only the elements of this record set
// for which test is true.
//
// Note that if this AttachmentSet is not fully loaded, this function will call the database
// to load the fields before doing the filtering. In this case, it might be more efficient
// to search the database directly with the filter condition.
func (s AttachmentSet) Filtered(test func(rs m.AttachmentSet) bool) m.AttachmentSet {
	res := s.RecordCollection.Filtered(func(rc models.RecordSet) bool {
		return test(AttachmentSet{RecordCollection: rc.Collection()})
	})
	return res.Wrap("Attachment").(m.AttachmentSet)
}

// AccessToken is a getter for the value of the "AccessToken" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) AccessToken() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("AccessToken", "access_token")).(string)
	return res
}

// SetAccessToken is a setter for the value of the "AccessToken" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetAccessToken panics if the RecordSet is empty.
func (s AttachmentSet) SetAccessToken(value string) {
	s.RecordCollection.Set(models.NewFieldName("AccessToken", "access_token"), value)
}

// CheckSum is a getter for the value of the "CheckSum" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) CheckSum() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CheckSum", "check_sum")).(string)
	return res
}

// SetCheckSum is a setter for the value of the "CheckSum" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCheckSum panics if the RecordSet is empty.
func (s AttachmentSet) SetCheckSum(value string) {
	s.RecordCollection.Set(models.NewFieldName("CheckSum", "check_sum"), value)
}

// Company is a getter for the value of the "Company" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) Company() m.CompanySet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Company", "company_id")).(models.RecordSet).Collection().Wrap("Company").(m.CompanySet)
	return res
}

// SetCompany is a setter for the value of the "Company" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCompany panics if the RecordSet is empty.
func (s AttachmentSet) SetCompany(value m.CompanySet) {
	s.RecordCollection.Set(models.NewFieldName("Company", "company_id"), value)
}

// CreateDate is a getter for the value of the "CreateDate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) CreateDate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CreateDate", "create_date")).(dates.DateTime)
	return res
}

// SetCreateDate is a setter for the value of the "CreateDate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCreateDate panics if the RecordSet is empty.
func (s AttachmentSet) SetCreateDate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("CreateDate", "create_date"), value)
}

// CreateUID is a getter for the value of the "CreateUID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) CreateUID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CreateUID", "create_uid")).(int64)
	return res
}

// SetCreateUID is a setter for the value of the "CreateUID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCreateUID panics if the RecordSet is empty.
func (s AttachmentSet) SetCreateUID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("CreateUID", "create_uid"), value)
}

// DBDatas is a getter for the value of the "DBDatas" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) DBDatas() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("DBDatas", "db_datas")).(string)
	return res
}

// SetDBDatas is a setter for the value of the "DBDatas" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetDBDatas panics if the RecordSet is empty.
func (s AttachmentSet) SetDBDatas(value string) {
	s.RecordCollection.Set(models.NewFieldName("DBDatas", "db_datas"), value)
}

// Datas is a getter for the value of the "Datas" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) Datas() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Datas", "datas")).(string)
	return res
}

// SetDatas is a setter for the value of the "Datas" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetDatas panics if the RecordSet is empty.
func (s AttachmentSet) SetDatas(value string) {
	s.RecordCollection.Set(models.NewFieldName("Datas", "datas"), value)
}

// Description is a getter for the value of the "Description" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) Description() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Description", "description")).(string)
	return res
}

// SetDescription is a setter for the value of the "Description" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetDescription panics if the RecordSet is empty.
func (s AttachmentSet) SetDescription(value string) {
	s.RecordCollection.Set(models.NewFieldName("Description", "description"), value)
}

// DisplayName is a getter for the value of the "DisplayName" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) DisplayName() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("DisplayName", "display_name")).(string)
	return res
}

// SetDisplayName is a setter for the value of the "DisplayName" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetDisplayName panics if the RecordSet is empty.
func (s AttachmentSet) SetDisplayName(value string) {
	s.RecordCollection.Set(models.NewFieldName("DisplayName", "display_name"), value)
}

// FileSize is a getter for the value of the "FileSize" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) FileSize() int {
	res, _ := s.RecordCollection.Get(models.NewFieldName("FileSize", "file_size")).(int)
	return res
}

// SetFileSize is a setter for the value of the "FileSize" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetFileSize panics if the RecordSet is empty.
func (s AttachmentSet) SetFileSize(value int) {
	s.RecordCollection.Set(models.NewFieldName("FileSize", "file_size"), value)
}

// HexyaExternalID is a getter for the value of the "HexyaExternalID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) HexyaExternalID() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("HexyaExternalID", "hexya_external_id")).(string)
	return res
}

// SetHexyaExternalID is a setter for the value of the "HexyaExternalID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetHexyaExternalID panics if the RecordSet is empty.
func (s AttachmentSet) SetHexyaExternalID(value string) {
	s.RecordCollection.Set(models.NewFieldName("HexyaExternalID", "hexya_external_id"), value)
}

// HexyaVersion is a getter for the value of the "HexyaVersion" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) HexyaVersion() int {
	res, _ := s.RecordCollection.Get(models.NewFieldName("HexyaVersion", "hexya_version")).(int)
	return res
}

// SetHexyaVersion is a setter for the value of the "HexyaVersion" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetHexyaVersion panics if the RecordSet is empty.
func (s AttachmentSet) SetHexyaVersion(value int) {
	s.RecordCollection.Set(models.NewFieldName("HexyaVersion", "hexya_version"), value)
}

// ID is a getter for the value of the "ID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) ID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ID", "id")).(int64)
	return res
}

// SetID is a setter for the value of the "ID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetID panics if the RecordSet is empty.
func (s AttachmentSet) SetID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("ID", "id"), value)
}

// IndexContent is a getter for the value of the "IndexContent" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) IndexContent() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("IndexContent", "index_content")).(string)
	return res
}

// SetIndexContent is a setter for the value of the "IndexContent" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetIndexContent panics if the RecordSet is empty.
func (s AttachmentSet) SetIndexContent(value string) {
	s.RecordCollection.Set(models.NewFieldName("IndexContent", "index_content"), value)
}

// LastUpdate is a getter for the value of the "LastUpdate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) LastUpdate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("LastUpdate", "__last_update")).(dates.DateTime)
	return res
}

// SetLastUpdate is a setter for the value of the "LastUpdate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLastUpdate panics if the RecordSet is empty.
func (s AttachmentSet) SetLastUpdate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("LastUpdate", "__last_update"), value)
}

// MimeType is a getter for the value of the "MimeType" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) MimeType() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("MimeType", "mime_type")).(string)
	return res
}

// SetMimeType is a setter for the value of the "MimeType" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetMimeType panics if the RecordSet is empty.
func (s AttachmentSet) SetMimeType(value string) {
	s.RecordCollection.Set(models.NewFieldName("MimeType", "mime_type"), value)
}

// Name is a getter for the value of the "Name" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) Name() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Name", "name")).(string)
	return res
}

// SetName is a setter for the value of the "Name" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetName panics if the RecordSet is empty.
func (s AttachmentSet) SetName(value string) {
	s.RecordCollection.Set(models.NewFieldName("Name", "name"), value)
}

// Public is a getter for the value of the "Public" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) Public() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Public", "public")).(bool)
	return res
}

// SetPublic is a setter for the value of the "Public" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetPublic panics if the RecordSet is empty.
func (s AttachmentSet) SetPublic(value bool) {
	s.RecordCollection.Set(models.NewFieldName("Public", "public"), value)
}

// ResField is a getter for the value of the "ResField" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) ResField() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ResField", "res_field")).(string)
	return res
}

// SetResField is a setter for the value of the "ResField" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetResField panics if the RecordSet is empty.
func (s AttachmentSet) SetResField(value string) {
	s.RecordCollection.Set(models.NewFieldName("ResField", "res_field"), value)
}

// ResID is a getter for the value of the "ResID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) ResID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ResID", "res_id")).(int64)
	return res
}

// SetResID is a setter for the value of the "ResID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetResID panics if the RecordSet is empty.
func (s AttachmentSet) SetResID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("ResID", "res_id"), value)
}

// ResModel is a getter for the value of the "ResModel" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) ResModel() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ResModel", "res_model")).(string)
	return res
}

// SetResModel is a setter for the value of the "ResModel" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetResModel panics if the RecordSet is empty.
func (s AttachmentSet) SetResModel(value string) {
	s.RecordCollection.Set(models.NewFieldName("ResModel", "res_model"), value)
}

// ResName is a getter for the value of the "ResName" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) ResName() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ResName", "res_name")).(string)
	return res
}

// SetResName is a setter for the value of the "ResName" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetResName panics if the RecordSet is empty.
func (s AttachmentSet) SetResName(value string) {
	s.RecordCollection.Set(models.NewFieldName("ResName", "res_name"), value)
}

// StoreFname is a getter for the value of the "StoreFname" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) StoreFname() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("StoreFname", "store_fname")).(string)
	return res
}

// SetStoreFname is a setter for the value of the "StoreFname" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetStoreFname panics if the RecordSet is empty.
func (s AttachmentSet) SetStoreFname(value string) {
	s.RecordCollection.Set(models.NewFieldName("StoreFname", "store_fname"), value)
}

// Type is a getter for the value of the "Type" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) Type() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Type", "type")).(string)
	return res
}

// SetType is a setter for the value of the "Type" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetType panics if the RecordSet is empty.
func (s AttachmentSet) SetType(value string) {
	s.RecordCollection.Set(models.NewFieldName("Type", "type"), value)
}

// URL is a getter for the value of the "URL" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) URL() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("URL", "url")).(string)
	return res
}

// SetURL is a setter for the value of the "URL" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetURL panics if the RecordSet is empty.
func (s AttachmentSet) SetURL(value string) {
	s.RecordCollection.Set(models.NewFieldName("URL", "url"), value)
}

// WriteDate is a getter for the value of the "WriteDate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) WriteDate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("WriteDate", "write_date")).(dates.DateTime)
	return res
}

// SetWriteDate is a setter for the value of the "WriteDate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetWriteDate panics if the RecordSet is empty.
func (s AttachmentSet) SetWriteDate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("WriteDate", "write_date"), value)
}

// WriteUID is a getter for the value of the "WriteUID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s AttachmentSet) WriteUID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("WriteUID", "write_uid")).(int64)
	return res
}

// SetWriteUID is a setter for the value of the "WriteUID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetWriteUID panics if the RecordSet is empty.
func (s AttachmentSet) SetWriteUID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("WriteUID", "write_uid"), value)
}

// Super returns a RecordSet with a modified callstack so that call to the current
// method will execute the next method layer.
//
// This method is meant to be used inside a method layer function to call its parent,
// such as:
//
//    func (rs h.MyRecordSet) MyMethod() string {
//        res := rs.Super().MyMethod()
//        res += " ok!"
//        return res
//    }
//
// Calls to a different method than the current method will call its next layer only
// if the current method has been called from a layer of the other method. Otherwise,
// it will be the same as calling the other method directly.
func (s AttachmentSet) Super() m.AttachmentSet {
	return s.RecordCollection.Super().Wrap("Attachment").(m.AttachmentSet)
}

// ModelData returns a new AttachmentData object populated with the values
// of the given FieldMap.
func (s AttachmentSet) ModelData(fMap models.FieldMap) m.AttachmentData {
	res := &AttachmentData{
		models.NewModelData(models.Registry.MustGet("Attachment")),
	}
	for k, v := range fMap {
		res.Set(models.Registry.MustGet("Attachment").FieldName(k), v)
	}
	return res
}

// ActionArchive sets Active=false on a recordset, by calling ToggleActive to take the
// corresponding actions according to the model
func (s AttachmentSet) ActionArchive() {
	s.Collection().Call("ActionArchive")
}

// ActionGet returns the action for displaying attachments
func (s AttachmentSet) ActionGet() *actions.Action {
	res := s.Collection().Call("ActionGet")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// ActionUnarchive sets Active=true on a recordset, by calling ToggleActive to take the
// corresponding actions according to the model
func (s AttachmentSet) ActionUnarchive() {
	s.Collection().Call("ActionUnarchive")
}

// AddDomainLimitOffset adds the given domain, limit, offset
// and order to the current RecordSet query.
func (s AttachmentSet) AddDomainLimitOffset(domain domains.Domain, limit int, offset int, order string) m.AttachmentSet {
	res := s.Collection().Call("AddDomainLimitOffset", domain, limit, offset, order)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// AddModifiers adds the modifiers attribute nodes to given xml doc.
func (s AttachmentSet) AddModifiers(doc *etree.Document, fieldInfos map[string]*models.FieldInfo) {
	s.Collection().Call("AddModifiers", doc, fieldInfos)
}

// AddNameToRelations returns the given RecordData after getting the name of all 2one relation ids
func (s AttachmentSet) AddNamesToRelations(data models.RecordData, fInfos map[string]*models.FieldInfo) models.RecordData {
	res := s.Collection().Call("AddNamesToRelations", data, fInfos)
	resTyped, _ := res.(models.RecordData)
	return resTyped
}

// Aggregates returns the result of this RecordSet query, which must by a grouped query.
func (s AttachmentSet) Aggregates(fieldNames ...models.FieldName) []m.AttachmentGroupAggregateRow {
	res := s.Collection().Call("Aggregates", fieldNames)
	resTyped, _ := res.([]m.AttachmentGroupAggregateRow)
	return resTyped
}

// Browse returns a new RecordSet with only the records with the given ids.
// Note that this function is just a shorcut for Search on a list of ids.
func (s AttachmentSet) Browse(ids []int64) m.AttachmentSet {
	res := s.Collection().Call("Browse", ids)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// BrowseOne returns a new RecordSet with only the record with the given id.
// Note that this function is just a shorcut for Search on a given id.
func (s AttachmentSet) BrowseOne(id int64) m.AttachmentSet {
	res := s.Collection().Call("BrowseOne", id)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Check restricts the access to an ir.attachment, according to referred model
// In the 'document' module, it is overridden to relax this hard rule, since
// more complex ones apply there.
//
// This method panics if the user does not have the access rights.
func (s AttachmentSet) Check(mode string, values m.AttachmentData) {
	s.Collection().Call("Check", mode, values)
}

// CheckAccessRights verifies that the operation given by "operation" is allowed for
// the current user according to the access rights.
//
// operation must be one of "read", "create", "unlink", "write".
func (s AttachmentSet) CheckAccessRights(args webtypes.CheckAccessRightsArgs) bool {
	res := s.Collection().Call("CheckAccessRights", args)
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckContents updates the given values
func (s AttachmentSet) CheckContents(values m.AttachmentData) m.AttachmentData {
	res := s.Collection().Call("CheckContents", values)
	resTyped, _ := res.(m.AttachmentData)
	return resTyped
}

// CheckExecutionPermission panics if the current user is not allowed to execute the given method.
//
// If dontPanic is false, this function will panic, otherwise it returns true
// if the user has the execution permission and false otherwise.
func (s AttachmentSet) CheckExecutionPermission(method *models.Method, dontPanic ...bool) bool {
	res := s.Collection().Call("CheckExecutionPermission", method, dontPanic)
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckRecursion verifies that there is no loop in a hierarchical structure of records,
// by following the parent relationship using the 'Parent' field until a loop is detected or
// until a top-level record is found.
//
// It returns true if no loop was found, false otherwise`,
func (s AttachmentSet) CheckRecursion() bool {
	res := s.Collection().Call("CheckRecursion")
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckServingAttachment limits creation and modification of served attachments
// to the members of the serving groups.
func (s AttachmentSet) CheckServingAttachments() {
	s.Collection().Call("CheckServingAttachments")
}

// ComputeCheckSum computes the SHA1 checksum of the given data
func (s AttachmentSet) ComputeCheckSum(data string) string {
	res := s.Collection().Call("ComputeCheckSum", data)
	resTyped, _ := res.(string)
	return resTyped
}

// ComputeDatas returns the data of the attachment, reading either from file or database
func (s AttachmentSet) ComputeDatas() m.AttachmentData {
	res := s.Collection().Call("ComputeDatas")
	resTyped, _ := res.(m.AttachmentData)
	return resTyped
}

// ComputeDisplayName updates the DisplayName field with the result of NameGet
func (s AttachmentSet) ComputeDisplayName() *models.ModelData {
	res := s.Collection().Call("ComputeDisplayName")
	resTyped, _ := res.(*models.ModelData)
	return resTyped
}

// ComputeLastUpdate returns the last datetime at which the record has been updated.
func (s AttachmentSet) ComputeLastUpdate() *models.ModelData {
	res := s.Collection().Call("ComputeLastUpdate")
	resTyped, _ := res.(*models.ModelData)
	return resTyped
}

// ComputeMimeType of the given values
func (s AttachmentSet) ComputeMimeType(values m.AttachmentData) string {
	res := s.Collection().Call("ComputeMimeType", values)
	resTyped, _ := res.(string)
	return resTyped
}

// ComputeResName computes the display name of the ressource this document is attached to.
func (s AttachmentSet) ComputeResName() m.AttachmentData {
	res := s.Collection().Call("ComputeResName")
	resTyped, _ := res.(m.AttachmentData)
	return resTyped
}

// Copy duplicates the given Attachment record, overridding values with overrides.
func (s AttachmentSet) Copy(overrides m.AttachmentData) m.AttachmentSet {
	res := s.Collection().Call("Copy", overrides)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// CopyData copies given record's data with all its fields values, overriding values with overrides.
func (s AttachmentSet) CopyData(overrides m.AttachmentData) m.AttachmentData {
	res := s.Collection().Call("CopyData", overrides)
	resTyped, _ := res.(models.RecordData)
	return resTyped.Underlying().Wrap().(m.AttachmentData)
}

// Create inserts a Attachment record in the database from the given data.
// Returns the created AttachmentSet.
func (s AttachmentSet) Create(data m.AttachmentData) m.AttachmentSet {
	res := s.Collection().Call("Create", data)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// DefaultGet returns a AttachmentData with the default values for the model.
func (s AttachmentSet) DefaultGet() m.AttachmentData {
	res := s.Collection().Call("DefaultGet")
	resTyped, _ := res.(models.RecordData)
	return resTyped.Underlying().Wrap().(m.AttachmentData)
}

// Enqueue queues the execution of the given method with the given arguments on this recordset.
// description will be the name given to the job.
func (s AttachmentSet) Enqueue(description string, method models.Methoder, arguments ...interface{}) m.QueueJobSet {
	res := s.Collection().Call("Enqueue", description, method, arguments)
	resTyped, _ := res.(m.QueueJobSet)
	return resTyped
}

// Equals returns true if this RecordSet is the same as other
// i.e. they are of the same model and have the same ids
func (s AttachmentSet) Equals(other m.AttachmentSet) bool {
	res := s.Collection().Call("Equals", other)
	resTyped, _ := res.(bool)
	return resTyped
}

// ExecuteO2MActions executes the actions on one2many fields given by
// the list of triplets received from the client
func (s AttachmentSet) ExecuteO2MActions(fieldName models.FieldName, info *models.FieldInfo, value interface{}) interface{} {
	res := s.Collection().Call("ExecuteO2MActions", fieldName, info, value)
	resTyped, _ := res.(interface{})
	return resTyped
}

// Fetch query the database with the current filter and returns a RecordSet
// with the queries ids.
//
// Fetch is lazy and only return ids. Use Load() instead if you want to fetch all fields.
func (s AttachmentSet) Fetch() m.AttachmentSet {
	res := s.Collection().Call("Fetch")
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// FieldGet returns the definition of the given field.
// The string, help, and selection (if present) attributes are translated.
func (s AttachmentSet) FieldGet(field models.FieldName) *models.FieldInfo {
	res := s.Collection().Call("FieldGet", field)
	resTyped, _ := res.(*models.FieldInfo)
	return resTyped
}

// FieldsGet returns the definition of each field.
// The embedded fields are included.
// The string, help, and selection (if present) attributes are translated.
//
// The result map is indexed by the fields JSON names.
func (s AttachmentSet) FieldsGet(args models.FieldsGetArgs) map[string]*models.FieldInfo {
	res := s.Collection().Call("FieldsGet", args)
	resTyped, _ := res.(map[string]*models.FieldInfo)
	return resTyped
}

// FieldsViewGet is the base implementation of the 'FieldsViewGet' method which
// gets the detailed composition of the requested view like fields, mixin,
// view architecture.
func (s AttachmentSet) FieldsViewGet(args webtypes.FieldsViewGetParams) *webtypes.FieldsViewData {
	res := s.Collection().Call("FieldsViewGet", args)
	resTyped, _ := res.(*webtypes.FieldsViewData)
	return resTyped
}

// FileDelete adds the given file name to the checklist for the garbage collector
func (s AttachmentSet) FileDelete(fName string) {
	s.Collection().Call("FileDelete", fName)
}

// FileGC performs the garbage collection of the filestore.`,
func (s AttachmentSet) FileGC() {
	s.Collection().Call("FileGC")
}

// FileRead returns the base64 encoded content of the given fileName (relative path).
// If binSize is true, it returns the file size instead as a human readable string`,
func (s AttachmentSet) FileRead(fileName string, binSize bool) string {
	res := s.Collection().Call("FileRead", fileName, binSize)
	resTyped, _ := res.(string)
	return resTyped
}

// FileStore returns the directory in which the attachment files are saved.
func (s AttachmentSet) FileStore() string {
	res := s.Collection().Call("FileStore")
	resTyped, _ := res.(string)
	return resTyped
}

// FileWrite writes value into the file given by sha. If the file already exists, nothing is done.
//
// It returns the filename of the written file.`,
func (s AttachmentSet) FileWrite(value string, sha string) string {
	res := s.Collection().Call("FileWrite", value, sha)
	resTyped, _ := res.(string)
	return resTyped
}

// ForceStorage forces all attachments to be stored in the currently configured storage
func (s AttachmentSet) ForceStorage() bool {
	res := s.Collection().Call("ForceStorage")
	resTyped, _ := res.(bool)
	return resTyped
}

// FormatRelationFields returns the given data with all relation fields converted to int64 or []int64
func (s AttachmentSet) FormatRelationFields(data models.RecordData, fInfos map[string]*models.FieldInfo) models.RecordData {
	res := s.Collection().Call("FormatRelationFields", data, fInfos)
	resTyped, _ := res.(models.RecordData)
	return resTyped
}

// FullPath returns the given relative path as a full sanitized path
func (s AttachmentSet) FullPath(path string) string {
	res := s.Collection().Call("FullPath", path)
	resTyped, _ := res.(string)
	return resTyped
}

// GenerateAccessToken generates and store a random access token for these attachments
func (s AttachmentSet) GenerateAccessToken() []string {
	res := s.Collection().Call("GenerateAccessToken")
	resTyped, _ := res.([]string)
	return resTyped
}

// GenerateToken generates and return a single random accessToken.
// Base implementation returns a UUID.
func (s AttachmentSet) GenerateToken() string {
	res := s.Collection().Call("GenerateToken")
	resTyped, _ := res.(string)
	return resTyped
}

// GetAttachmentByKey returns the attachment with the given key
func (s AttachmentSet) GetAttachmentByKey(key string, extraCond q.AttachmentCondition, orders []string) m.AttachmentSet {
	res := s.Collection().Call("GetAttachmentByKey", key, extraCond, orders)
	resTyped, _ := res.(m.AttachmentSet)
	return resTyped
}

// GetDatasRelatedValues compute the fields that depend on data
func (s AttachmentSet) GetDatasRelatedValues(data string, mimeType string) m.AttachmentData {
	res := s.Collection().Call("GetDatasRelatedValues", data, mimeType)
	resTyped, _ := res.(m.AttachmentData)
	return resTyped
}

// GetFormviewAction returns an action to open the document.
// This method is meant to be overridden in addons that want
// to give specific view ids for example.`,
func (s AttachmentSet) GetFormviewAction() *actions.Action {
	res := s.Collection().Call("GetFormviewAction")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// GetFormviewID returns an view id to open the document with.
// This method is meant to be overridden in addons that want
// to give specific view ids for example.
func (s AttachmentSet) GetFormviewId() string {
	res := s.Collection().Call("GetFormviewId")
	resTyped, _ := res.(string)
	return resTyped
}

// GetPath returns the relative and full paths of the file with the given sha.
// This methods creates the directory if it does not exist.`,
func (s AttachmentSet) GetPath(sha string) (string, string) {
	res := s.Collection().CallMulti("GetPath", sha)
	resTyped0, _ := res[0].(string)
	resTyped1, _ := res[1].(string)
	return resTyped0, resTyped1
}

// GetRecord returns the Recordset with the given externalID. It panics if the externalID does not exist.
func (s AttachmentSet) GetRecord(externalID string) m.AttachmentSet {
	res := s.Collection().Call("GetRecord", externalID)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// GetServeAttachment returns the serve attachments
func (s AttachmentSet) GetServeAttachment(url string, extraCond q.AttachmentCondition, extraFields models.FieldNames, orders []string) []models.RecordData {
	res := s.Collection().Call("GetServeAttachment", url, extraCond, extraFields, orders)
	resTyped, _ := res.([]models.RecordData)
	return resTyped
}

// GetServingGroups returns groups allowed tp create and write serving attachments.
//
// An attachment record may be used as a fallback in the
// http dispatch if its type field is set to "binary" and its url
// field is set as the request's url. Only the groups returned by
// this method are allowed to create and write on such records.
func (s AttachmentSet) GetServingGroups() m.GroupSet {
	res := s.Collection().Call("GetServingGroups")
	resTyped, _ := res.(m.GroupSet)
	return resTyped
}

// GetToolbar returns a toolbar populated with the actions linked to this model
func (s AttachmentSet) GetToolbar() webtypes.Toolbar {
	res := s.Collection().Call("GetToolbar")
	resTyped, _ := res.(webtypes.Toolbar)
	return resTyped
}

// GroupBy returns a new RecordSet grouped with the given GROUP BY expressions.
func (s AttachmentSet) GroupBy(exprs ...models.FieldName) m.AttachmentSet {
	res := s.Collection().Call("GroupBy", exprs)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Index computes the index content of the given filename, or binary data.
func (s AttachmentSet) Index(binData string, fileType string) string {
	res := s.Collection().Call("Index", binData, fileType)
	resTyped, _ := res.(string)
	return resTyped
}

// Intersect returns a new RecordCollection with only the records that are both
// in this RecordCollection and in the other RecordSet.
func (s AttachmentSet) Intersect(other m.AttachmentSet) m.AttachmentSet {
	res := s.Collection().Call("Intersect", other)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// InverseDatas stores the given data either in database or in file.
func (s AttachmentSet) InverseDatas(val string) {
	s.Collection().Call("InverseDatas", val)
}

// Limit returns a new RecordSet with only the first 'limit' records.
func (s AttachmentSet) Limit(limit int) m.AttachmentSet {
	res := s.Collection().Call("Limit", limit)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Load looks up cache for fields of the RecordCollection and
// query database for missing values.
// fields are the fields to retrieve in the expression format,
// i.e. "User.Profile.Age" or "user_id.profile_id.age".
// If no fields are given, all DB columns of the RecordCollection's
// model are retrieved.
func (s AttachmentSet) Load(fields ...models.FieldName) m.AttachmentSet {
	res := s.Collection().Call("Load", fields)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// LoadViews returns the data for all the views and filters required in the parameters.
func (s AttachmentSet) LoadViews(args webtypes.LoadViewsArgs) *webtypes.LoadViewsData {
	res := s.Collection().Call("LoadViews", args)
	resTyped, _ := res.(*webtypes.LoadViewsData)
	return resTyped
}

// ManageGroupsOnFields adds the invisible attribute to fields nodes if the current
// user does not belong to one of the groups of the 'groups' attribute
func (s AttachmentSet) ManageGroupsOnFields(doc *etree.Document, fieldInfos map[string]*models.FieldInfo) {
	s.Collection().Call("ManageGroupsOnFields", doc, fieldInfos)
}

// MarkForGC adds fName in a checklist for filestore garbage collection.
func (s AttachmentSet) MarkForGC(fName string) {
	s.Collection().Call("MarkForGC", fName)
}

// NameGet retrieves the human readable name of this record.`,
func (s AttachmentSet) NameGet() string {
	res := s.Collection().Call("NameGet")
	resTyped, _ := res.(string)
	return resTyped
}

// NameSearch searches for records that have a display name matching the given
// "name" pattern when compared with the given "operator", while also
// matching the optional search domain ("args").
//
// This is used for example to provide suggestions based on a partial
// value for a relational field. Sometimes be seen as the inverse
// function of NameGet but it is not guaranteed to be.
func (s AttachmentSet) NameSearch(params webtypes.NameSearchParams) []webtypes.RecordIDWithName {
	res := s.Collection().Call("NameSearch", params)
	resTyped, _ := res.([]webtypes.RecordIDWithName)
	return resTyped
}

// New creates a Attachment record in memory from the given data.
// Such AttachmentSet has a negative ID and cannot be reloaded from the database
func (s AttachmentSet) New(data m.AttachmentData) m.AttachmentSet {
	res := s.Collection().Call("New", data)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// NormalizeM2MData converts the list of triplets received from the client into the final list of ids
// to keep in the Many2Many relationship of this model through the given field.
func (s AttachmentSet) NormalizeM2MData(fieldName models.FieldName, info *models.FieldInfo, value interface{}) interface{} {
	res := s.Collection().Call("NormalizeM2MData", fieldName, info, value)
	resTyped, _ := res.(interface{})
	return resTyped
}

// Offset returns a new RecordSet with only the records starting at offset
func (s AttachmentSet) Offset(offset int) m.AttachmentSet {
	res := s.Collection().Call("Offset", offset)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Onchange returns the values that must be modified according to each field's Onchange
// method in the pseudo-record given as params.Values`,
func (s AttachmentSet) Onchange(params models.OnchangeParams) models.OnchangeResult {
	res := s.Collection().Call("Onchange", params)
	resTyped, _ := res.(models.OnchangeResult)
	return resTyped
}

// OrderBy returns a new RecordSet ordered by the given ORDER BY expressions.
// Each expression contains a field name and optionally one of "asc" or "desc", such as:
//
// rs.OrderBy("Company", "Name desc")
func (s AttachmentSet) OrderBy(exprs ...string) m.AttachmentSet {
	res := s.Collection().Call("OrderBy", exprs)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// PostAddCreate is called after an attachment is uploaded.
// It can be overridden to implement specific behaviour after attachment creation.
func (s AttachmentSet) PostAddCreate() {
	s.Collection().Call("PostAddCreate")
}

// PostProcessCreateValues updates FK of related records created at the same time.
//
// This method is meant to be called with the second returned value of ProcessCreateValues
// after record creation.
func (s AttachmentSet) PostProcessCreateValues(data models.RecordData) {
	s.Collection().Call("PostProcessCreateValues", data)
}

// PostProcessFilters transforms a map[models.FieldName]models.Conditioner
// in a map[string][]interface{} which acts as a map of domains.
func (s AttachmentSet) PostProcessFilters(in map[models.FieldName]models.Conditioner) map[string][]interface{} {
	res := s.Collection().Call("PostProcessFilters", in)
	resTyped, _ := res.(map[string][]interface{})
	return resTyped
}

// ProcessCreateValues updates the given data values for Create method to be
// compatible with the ORM, in particular for relation fields.
//
// It returns a first FieldMap to be used as argument to the Create method, and
// a second map to be used with a subsequent call to PostProcessCreateValues (for
// updating FKs pointing to the newly created record).
func (s AttachmentSet) ProcessCreateValues(data models.RecordData) (models.RecordData, models.RecordData) {
	res := s.Collection().CallMulti("ProcessCreateValues", data)
	resTyped0, _ := res[0].(models.RecordData)
	resTyped1, _ := res[1].(models.RecordData)
	return resTyped0, resTyped1
}

// ProcessElementAttrs returns a modifiers map according to the domain
// in attrs of the given element
func (s AttachmentSet) ProcessElementAttrs(element *etree.Element, fieldInfos map[string]*models.FieldInfo) map[string]interface{} {
	res := s.Collection().Call("ProcessElementAttrs", element, fieldInfos)
	resTyped, _ := res.(map[string]interface{})
	return resTyped
}

// ProcessFieldElementModifiers modifies the given modifiers map by taking into account:
// - 'invisible', 'readonly' and 'required' attributes in field tags
// - 'ReadOnly' and 'Required' parameters of the model's field'
// It returns the modified map.
func (s AttachmentSet) ProcessFieldElementModifiers(element *etree.Element, fieldInfos map[string]*models.FieldInfo, modifiers map[string]interface{}) map[string]interface{} {
	res := s.Collection().Call("ProcessFieldElementModifiers", element, fieldInfos, modifiers)
	resTyped, _ := res.(map[string]interface{})
	return resTyped
}

// ProcessView makes all the necessary modifications to the view
// arch and returns the new xml string.`,
func (s AttachmentSet) ProcessView(arch *etree.Document, fieldInfos map[string]*models.FieldInfo) string {
	res := s.Collection().Call("ProcessView", arch, fieldInfos)
	resTyped, _ := res.(string)
	return resTyped
}

// ProcessWriteValues updates the given data values for Write method to be
// compatible with the ORM, in particular for relation fields
func (s AttachmentSet) ProcessWriteValues(data models.RecordData) models.RecordData {
	res := s.Collection().Call("ProcessWriteValues", data)
	resTyped, _ := res.(models.RecordData)
	return resTyped
}

// Read reads the database and returns a slice of FieldMap of the given model.
func (s AttachmentSet) Read(fields models.FieldNames) []models.RecordData {
	res := s.Collection().Call("Read", fields)
	resTyped, _ := res.([]models.RecordData)
	return resTyped
}

// ReadGroup gets a list of record aggregates according to the given parameters.
func (s AttachmentSet) ReadGroup(params webtypes.ReadGroupParams) []models.FieldMap {
	res := s.Collection().Call("ReadGroup", params)
	resTyped, _ := res.([]models.FieldMap)
	return resTyped
}

// ReadGroupAllowedFields returns the fields by which a non-admin user is allowed to group by
func (s AttachmentSet) ReadGroupAllowedFields() models.FieldNames {
	res := s.Collection().Call("ReadGroupAllowedFields")
	resTyped, _ := res.(models.FieldNames)
	return resTyped
}

// SQLFromCondition returns the WHERE clause sql and arguments corresponding to
// the given condition.`,
func (s AttachmentSet) SQLFromCondition(c *models.Condition) (string, models.SQLParams) {
	res := s.Collection().CallMulti("SQLFromCondition", c)
	resTyped0, _ := res[0].(string)
	resTyped1, _ := res[1].(models.SQLParams)
	return resTyped0, resTyped1
}

// Search returns a new AttachmentSet filtering on the current one with the additional given Condition
func (s AttachmentSet) Search(condition q.AttachmentCondition) m.AttachmentSet {
	res := s.Collection().Call("Search", condition)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// SearchAll returns a RecordSet with all items of the table, regardless of the
// current RecordSet query. It is mainly meant to be used on an empty RecordSet.
func (s AttachmentSet) SearchAll() m.AttachmentSet {
	res := s.Collection().Call("SearchAll")
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// SearchByName searches for Attachment records that have a display name matching the given
// "name" pattern when compared with the given "op" operator, while also
// matching the optional search condition ("additionalCond").
//
// This is used for example to provide suggestions based on a partial
// value for a relational field. Sometimes be seen as the inverse
// function of NameGet but it is not guaranteed to be.
func (s AttachmentSet) SearchByName(name string, op operator.Operator, additionalCond q.AttachmentCondition, limit int) m.AttachmentSet {
	res := s.Collection().Call("SearchByName", name, op, additionalCond, limit)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// SearchCount fetch from the database the number of records that match the RecordSet conditions.
func (s AttachmentSet) SearchCount() int {
	res := s.Collection().Call("SearchCount")
	resTyped, _ := res.(int)
	return resTyped
}

// SearchDomain execute a search on the given domain.
func (s AttachmentSet) SearchDomain(domain domains.Domain) m.CommonMixinSet {
	res := s.Collection().Call("SearchDomain", domain)
	resTyped, _ := res.(m.CommonMixinSet)
	return resTyped
}

// SearchRead retrieves database records according to the filters defined in params.
func (s AttachmentSet) SearchRead(params webtypes.SearchParams) []models.RecordData {
	res := s.Collection().Call("SearchRead", params)
	resTyped, _ := res.([]models.RecordData)
	return resTyped
}

// SortedByField returns a new record set with the same records as rc but sorted by the given field.
// If reverse is true, the sort is done in reversed order
func (s AttachmentSet) SortedByField(namer models.FieldName, reverse bool) m.AttachmentSet {
	res := s.Collection().Call("SortedByField", namer, reverse)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// SortedDefault returns a new record set with the same records as rc but sorted according
// to the default order of this model
func (s AttachmentSet) SortedDefault() m.AttachmentSet {
	res := s.Collection().Call("SortedDefault")
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Storage returns the configured storage mechanism for attachments (e.g. database, file, etc.)
func (s AttachmentSet) Storage() string {
	res := s.Collection().Call("Storage")
	resTyped, _ := res.(string)
	return resTyped
}

// Subtract returns a RecordSet with the Records that are in this
// RecordCollection but not in the given 'other' one.
// The result is guaranteed to be a set of unique records.
func (s AttachmentSet) Subtract(other m.AttachmentSet) m.AttachmentSet {
	res := s.Collection().Call("Subtract", other)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Sudo returns a new RecordSet with the given userID
// or the superuser ID if not specified
func (s AttachmentSet) Sudo(userID ...int64) m.AttachmentSet {
	res := s.Collection().Call("Sudo", userID)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// ToggleActive toggles the Active field of this object if it exists.
func (s AttachmentSet) ToggleActive() {
	s.Collection().Call("ToggleActive")
}

// Union returns a new RecordSet that is the union of this RecordSet and the given
// "other" RecordSet. The result is guaranteed to be a set of unique records.
func (s AttachmentSet) Union(other m.AttachmentSet) m.AttachmentSet {
	res := s.Collection().Call("Union", other)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Unlink deletes the given records in the database.
func (s AttachmentSet) Unlink() int64 {
	res := s.Collection().Call("Unlink")
	resTyped, _ := res.(int64)
	return resTyped
}

// WebReadGroup returns the result of a read_group (and optionally search for and read records inside each
// group), and the total number of groups matching the search domain.
func (s AttachmentSet) WebReadGroup(params webtypes.WebReadGroupParams) webtypes.WebReadGroupResult {
	res := s.Collection().Call("WebReadGroup", params)
	resTyped, _ := res.(webtypes.WebReadGroupResult)
	return resTyped
}

// WebReadGroupPrivate performs a read_group and optionally a web_search_read for each group.
func (s AttachmentSet) WebReadGroupPrivate(params webtypes.WebReadGroupParams) []models.FieldMap {
	res := s.Collection().Call("WebReadGroupPrivate", params)
	resTyped, _ := res.([]models.FieldMap)
	return resTyped
}

// WebSearchRead performs a search_read and a search_count.
func (s AttachmentSet) WebSearchRead(params webtypes.SearchParams) webtypes.SearchReadResult {
	res := s.Collection().Call("WebSearchRead", params)
	resTyped, _ := res.(webtypes.SearchReadResult)
	return resTyped
}

// WithContext returns a copy of the current RecordSet with
// its context extended by the given key and value.
func (s AttachmentSet) WithContext(key string, value interface{}) m.AttachmentSet {
	res := s.Collection().Call("WithContext", key, value)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// WithEnv returns a copy of the current RecordSet with the given Environment.
func (s AttachmentSet) WithEnv(env models.Environment) m.AttachmentSet {
	res := s.Collection().Call("WithEnv", env)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// WithNewContext returns a copy of the current RecordSet with its context
// replaced by the given one.
func (s AttachmentSet) WithNewContext(context *types.Context) m.AttachmentSet {
	res := s.Collection().Call("WithNewContext", context)
	resTyped := res.(models.RecordSet).Collection().Wrap("Attachment").(m.AttachmentSet)
	return resTyped
}

// Write is the base implementation of the 'Write' method which updates
// Attachment records in the database with the given data.
func (s AttachmentSet) Write(data m.AttachmentData) bool {
	res := s.Collection().Call("Write", data)
	resTyped, _ := res.(bool)
	return resTyped
}

// Aggregates returns the result of this RecordSet query, which must by a grouped query.
func m_Attachment_Aggregates(rs AttachmentSet, fieldNames ...models.FieldName) []m.AttachmentGroupAggregateRow {
	lines := rs.RecordCollection.Aggregates(fieldNames...)
	res := make([]m.AttachmentGroupAggregateRow, len(lines))
	for i, l := range lines {
		res[i] = AttachmentGroupAggregateRow{
			values: l.Values.Wrap().(m.AttachmentData),
			count:  l.Count,
			condition: q.AttachmentCondition{
				Condition: l.Condition,
			},
		}
	}
	return res
}

func init() {
	models.CreateModel("Attachment", 0)
	models.Registry.MustGet("Attachment").AddFields(map[string]models.FieldDefinition{
		"CreateDate":      models.DummyField{},
		"CreateUID":       models.DummyField{},
		"DisplayName":     models.DummyField{},
		"HexyaExternalID": models.DummyField{},
		"HexyaVersion":    models.DummyField{},
		"LastUpdate":      models.DummyField{},
		"WriteDate":       models.DummyField{},
		"WriteUID":        models.DummyField{},
	})
	models.Registry.MustGet("Attachment").AddEmptyMethod("ActionArchive")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ActionGet")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ActionUnarchive")
	models.Registry.MustGet("Attachment").AddEmptyMethod("AddDomainLimitOffset")
	models.Registry.MustGet("Attachment").AddEmptyMethod("AddModifiers")
	models.Registry.MustGet("Attachment").AddEmptyMethod("AddNamesToRelations")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Browse")
	models.Registry.MustGet("Attachment").AddEmptyMethod("BrowseOne")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Check")
	models.Registry.MustGet("Attachment").AddEmptyMethod("CheckAccessRights")
	models.Registry.MustGet("Attachment").AddEmptyMethod("CheckContents")
	models.Registry.MustGet("Attachment").AddEmptyMethod("CheckExecutionPermission")
	models.Registry.MustGet("Attachment").AddEmptyMethod("CheckRecursion")
	models.Registry.MustGet("Attachment").AddEmptyMethod("CheckServingAttachments")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ComputeCheckSum")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ComputeDatas")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ComputeDisplayName")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ComputeLastUpdate")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ComputeMimeType")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ComputeResName")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Copy")
	models.Registry.MustGet("Attachment").AddEmptyMethod("CopyData")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Create")
	models.Registry.MustGet("Attachment").AddEmptyMethod("DefaultGet")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Enqueue")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Equals")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ExecuteO2MActions")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Fetch")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FieldGet")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FieldsGet")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FieldsViewGet")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FileDelete")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FileGC")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FileRead")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FileStore")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FileWrite")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ForceStorage")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FormatRelationFields")
	models.Registry.MustGet("Attachment").AddEmptyMethod("FullPath")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GenerateAccessToken")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GenerateToken")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetAttachmentByKey")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetDatasRelatedValues")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetFormviewAction")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetFormviewId")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetPath")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetRecord")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetServeAttachment")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetServingGroups")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GetToolbar")
	models.Registry.MustGet("Attachment").AddEmptyMethod("GroupBy")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Index")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Intersect")
	models.Registry.MustGet("Attachment").AddEmptyMethod("InverseDatas")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Limit")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Load")
	models.Registry.MustGet("Attachment").AddEmptyMethod("LoadViews")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ManageGroupsOnFields")
	models.Registry.MustGet("Attachment").AddEmptyMethod("MarkForGC")
	models.Registry.MustGet("Attachment").AddEmptyMethod("NameGet")
	models.Registry.MustGet("Attachment").AddEmptyMethod("NameSearch")
	models.Registry.MustGet("Attachment").AddEmptyMethod("New")
	models.Registry.MustGet("Attachment").AddEmptyMethod("NormalizeM2MData")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Offset")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Onchange")
	models.Registry.MustGet("Attachment").AddEmptyMethod("OrderBy")
	models.Registry.MustGet("Attachment").AddEmptyMethod("PostAddCreate")
	models.Registry.MustGet("Attachment").AddEmptyMethod("PostProcessCreateValues")
	models.Registry.MustGet("Attachment").AddEmptyMethod("PostProcessFilters")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ProcessCreateValues")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ProcessElementAttrs")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ProcessFieldElementModifiers")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ProcessView")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ProcessWriteValues")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Read")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ReadGroup")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ReadGroupAllowedFields")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SQLFromCondition")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Search")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SearchAll")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SearchByName")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SearchCount")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SearchDomain")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SearchRead")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SortedByField")
	models.Registry.MustGet("Attachment").AddEmptyMethod("SortedDefault")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Storage")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Subtract")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Sudo")
	models.Registry.MustGet("Attachment").AddEmptyMethod("ToggleActive")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Union")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Unlink")
	models.Registry.MustGet("Attachment").AddEmptyMethod("WebReadGroup")
	models.Registry.MustGet("Attachment").AddEmptyMethod("WebReadGroupPrivate")
	models.Registry.MustGet("Attachment").AddEmptyMethod("WebSearchRead")
	models.Registry.MustGet("Attachment").AddEmptyMethod("WithContext")
	models.Registry.MustGet("Attachment").AddEmptyMethod("WithEnv")
	models.Registry.MustGet("Attachment").AddEmptyMethod("WithNewContext")
	models.Registry.MustGet("Attachment").AddEmptyMethod("Write")
	models.Registry.MustGet("Attachment").NewMethod("Aggregates", m_Attachment_Aggregates)
	models.RegisterRecordSetWrapper("Attachment", AttachmentSet{})
	models.RegisterModelDataWrapper("Attachment", AttachmentData{})
}
