// This file is autogenerated by hexya-generate
// DO NOT MODIFY THIS FILE - ANY CHANGES WILL BE OVERWRITTEN

package user

import (
	"github.com/beevik/etree"
	"github.com/hexya-addons/web/domains"
	"github.com/hexya-addons/web/webtypes"
	"github.com/hexya-erp/hexya/src/actions"
	"github.com/hexya-erp/hexya/src/models"
	"github.com/hexya-erp/hexya/src/models/operator"
	"github.com/hexya-erp/hexya/src/models/types"
	"github.com/hexya-erp/hexya/src/models/types/dates"
	"github.com/hexya-erp/pool/m"
	"github.com/hexya-erp/pool/q"
)

// ------- FIELD COLLECTION ----------

// A FieldsCollection is the collection of fields
// of the User model.
type FieldsCollection struct {
	*models.FieldsCollection
}

// ActionID returns a pointer to the ActionID Field.
func (c FieldsCollection) ActionID() *models.Field {
	return c.MustGet("ActionID")
}

// Active returns a pointer to the Active Field.
func (c FieldsCollection) Active() *models.Field {
	return c.MustGet("Active")
}

// ActiveLangCount returns a pointer to the ActiveLangCount Field.
func (c FieldsCollection) ActiveLangCount() *models.Field {
	return c.MustGet("ActiveLangCount")
}

// ActivePartner returns a pointer to the ActivePartner Field.
func (c FieldsCollection) ActivePartner() *models.Field {
	return c.MustGet("ActivePartner")
}

// Banks returns a pointer to the Banks Field.
func (c FieldsCollection) Banks() *models.Field {
	return c.MustGet("Banks")
}

// Barcode returns a pointer to the Barcode Field.
func (c FieldsCollection) Barcode() *models.Field {
	return c.MustGet("Barcode")
}

// Categories returns a pointer to the Categories Field.
func (c FieldsCollection) Categories() *models.Field {
	return c.MustGet("Categories")
}

// ChatterPosition returns a pointer to the ChatterPosition Field.
func (c FieldsCollection) ChatterPosition() *models.Field {
	return c.MustGet("ChatterPosition")
}

// Children returns a pointer to the Children Field.
func (c FieldsCollection) Children() *models.Field {
	return c.MustGet("Children")
}

// City returns a pointer to the City Field.
func (c FieldsCollection) City() *models.Field {
	return c.MustGet("City")
}

// Color returns a pointer to the Color Field.
func (c FieldsCollection) Color() *models.Field {
	return c.MustGet("Color")
}

// Comment returns a pointer to the Comment Field.
func (c FieldsCollection) Comment() *models.Field {
	return c.MustGet("Comment")
}

// CommercialCompanyName returns a pointer to the CommercialCompanyName Field.
func (c FieldsCollection) CommercialCompanyName() *models.Field {
	return c.MustGet("CommercialCompanyName")
}

// CommercialPartner returns a pointer to the CommercialPartner Field.
func (c FieldsCollection) CommercialPartner() *models.Field {
	return c.MustGet("CommercialPartner")
}

// Companies returns a pointer to the Companies Field.
func (c FieldsCollection) Companies() *models.Field {
	return c.MustGet("Companies")
}

// CompaniesCount returns a pointer to the CompaniesCount Field.
func (c FieldsCollection) CompaniesCount() *models.Field {
	return c.MustGet("CompaniesCount")
}

// Company returns a pointer to the Company Field.
func (c FieldsCollection) Company() *models.Field {
	return c.MustGet("Company")
}

// CompanyName returns a pointer to the CompanyName Field.
func (c FieldsCollection) CompanyName() *models.Field {
	return c.MustGet("CompanyName")
}

// CompanyType returns a pointer to the CompanyType Field.
func (c FieldsCollection) CompanyType() *models.Field {
	return c.MustGet("CompanyType")
}

// ContactAddress returns a pointer to the ContactAddress Field.
func (c FieldsCollection) ContactAddress() *models.Field {
	return c.MustGet("ContactAddress")
}

// Country returns a pointer to the Country Field.
func (c FieldsCollection) Country() *models.Field {
	return c.MustGet("Country")
}

// CreateDate returns a pointer to the CreateDate Field.
func (c FieldsCollection) CreateDate() *models.Field {
	return c.MustGet("CreateDate")
}

// CreateUID returns a pointer to the CreateUID Field.
func (c FieldsCollection) CreateUID() *models.Field {
	return c.MustGet("CreateUID")
}

// CreditLimit returns a pointer to the CreditLimit Field.
func (c FieldsCollection) CreditLimit() *models.Field {
	return c.MustGet("CreditLimit")
}

// Date returns a pointer to the Date Field.
func (c FieldsCollection) Date() *models.Field {
	return c.MustGet("Date")
}

// DisplayName returns a pointer to the DisplayName Field.
func (c FieldsCollection) DisplayName() *models.Field {
	return c.MustGet("DisplayName")
}

// Email returns a pointer to the Email Field.
func (c FieldsCollection) Email() *models.Field {
	return c.MustGet("Email")
}

// EmailFormatted returns a pointer to the EmailFormatted Field.
func (c FieldsCollection) EmailFormatted() *models.Field {
	return c.MustGet("EmailFormatted")
}

// Employee returns a pointer to the Employee Field.
func (c FieldsCollection) Employee() *models.Field {
	return c.MustGet("Employee")
}

// Function returns a pointer to the Function Field.
func (c FieldsCollection) Function() *models.Field {
	return c.MustGet("Function")
}

// Groups returns a pointer to the Groups Field.
func (c FieldsCollection) Groups() *models.Field {
	return c.MustGet("Groups")
}

// GroupsCount returns a pointer to the GroupsCount Field.
func (c FieldsCollection) GroupsCount() *models.Field {
	return c.MustGet("GroupsCount")
}

// HexyaExternalID returns a pointer to the HexyaExternalID Field.
func (c FieldsCollection) HexyaExternalID() *models.Field {
	return c.MustGet("HexyaExternalID")
}

// HexyaVersion returns a pointer to the HexyaVersion Field.
func (c FieldsCollection) HexyaVersion() *models.Field {
	return c.MustGet("HexyaVersion")
}

// ID returns a pointer to the ID Field.
func (c FieldsCollection) ID() *models.Field {
	return c.MustGet("ID")
}

// Image returns a pointer to the Image Field.
func (c FieldsCollection) Image() *models.Field {
	return c.MustGet("Image")
}

// ImageMedium returns a pointer to the ImageMedium Field.
func (c FieldsCollection) ImageMedium() *models.Field {
	return c.MustGet("ImageMedium")
}

// ImageSmall returns a pointer to the ImageSmall Field.
func (c FieldsCollection) ImageSmall() *models.Field {
	return c.MustGet("ImageSmall")
}

// Industry returns a pointer to the Industry Field.
func (c FieldsCollection) Industry() *models.Field {
	return c.MustGet("Industry")
}

// IsCompany returns a pointer to the IsCompany Field.
func (c FieldsCollection) IsCompany() *models.Field {
	return c.MustGet("IsCompany")
}

// Lang returns a pointer to the Lang Field.
func (c FieldsCollection) Lang() *models.Field {
	return c.MustGet("Lang")
}

// LastUpdate returns a pointer to the LastUpdate Field.
func (c FieldsCollection) LastUpdate() *models.Field {
	return c.MustGet("LastUpdate")
}

// Latitude returns a pointer to the Latitude Field.
func (c FieldsCollection) Latitude() *models.Field {
	return c.MustGet("Latitude")
}

// Login returns a pointer to the Login Field.
func (c FieldsCollection) Login() *models.Field {
	return c.MustGet("Login")
}

// LoginDate returns a pointer to the LoginDate Field.
func (c FieldsCollection) LoginDate() *models.Field {
	return c.MustGet("LoginDate")
}

// Logs returns a pointer to the Logs Field.
func (c FieldsCollection) Logs() *models.Field {
	return c.MustGet("Logs")
}

// Longitude returns a pointer to the Longitude Field.
func (c FieldsCollection) Longitude() *models.Field {
	return c.MustGet("Longitude")
}

// Mobile returns a pointer to the Mobile Field.
func (c FieldsCollection) Mobile() *models.Field {
	return c.MustGet("Mobile")
}

// Name returns a pointer to the Name Field.
func (c FieldsCollection) Name() *models.Field {
	return c.MustGet("Name")
}

// NewPassword returns a pointer to the NewPassword Field.
func (c FieldsCollection) NewPassword() *models.Field {
	return c.MustGet("NewPassword")
}

// Parent returns a pointer to the Parent Field.
func (c FieldsCollection) Parent() *models.Field {
	return c.MustGet("Parent")
}

// ParentName returns a pointer to the ParentName Field.
func (c FieldsCollection) ParentName() *models.Field {
	return c.MustGet("ParentName")
}

// Partner returns a pointer to the Partner Field.
func (c FieldsCollection) Partner() *models.Field {
	return c.MustGet("Partner")
}

// PartnerShare returns a pointer to the PartnerShare Field.
func (c FieldsCollection) PartnerShare() *models.Field {
	return c.MustGet("PartnerShare")
}

// Password returns a pointer to the Password Field.
func (c FieldsCollection) Password() *models.Field {
	return c.MustGet("Password")
}

// Phone returns a pointer to the Phone Field.
func (c FieldsCollection) Phone() *models.Field {
	return c.MustGet("Phone")
}

// Ref returns a pointer to the Ref Field.
func (c FieldsCollection) Ref() *models.Field {
	return c.MustGet("Ref")
}

// SameVATPartner returns a pointer to the SameVATPartner Field.
func (c FieldsCollection) SameVATPartner() *models.Field {
	return c.MustGet("SameVATPartner")
}

// Share returns a pointer to the Share Field.
func (c FieldsCollection) Share() *models.Field {
	return c.MustGet("Share")
}

// SidebarVisible returns a pointer to the SidebarVisible Field.
func (c FieldsCollection) SidebarVisible() *models.Field {
	return c.MustGet("SidebarVisible")
}

// Signature returns a pointer to the Signature Field.
func (c FieldsCollection) Signature() *models.Field {
	return c.MustGet("Signature")
}

// State returns a pointer to the State Field.
func (c FieldsCollection) State() *models.Field {
	return c.MustGet("State")
}

// Street returns a pointer to the Street Field.
func (c FieldsCollection) Street() *models.Field {
	return c.MustGet("Street")
}

// Street2 returns a pointer to the Street2 Field.
func (c FieldsCollection) Street2() *models.Field {
	return c.MustGet("Street2")
}

// TZ returns a pointer to the TZ Field.
func (c FieldsCollection) TZ() *models.Field {
	return c.MustGet("TZ")
}

// TZOffset returns a pointer to the TZOffset Field.
func (c FieldsCollection) TZOffset() *models.Field {
	return c.MustGet("TZOffset")
}

// Title returns a pointer to the Title Field.
func (c FieldsCollection) Title() *models.Field {
	return c.MustGet("Title")
}

// Type returns a pointer to the Type Field.
func (c FieldsCollection) Type() *models.Field {
	return c.MustGet("Type")
}

// User returns a pointer to the User Field.
func (c FieldsCollection) User() *models.Field {
	return c.MustGet("User")
}

// Users returns a pointer to the Users Field.
func (c FieldsCollection) Users() *models.Field {
	return c.MustGet("Users")
}

// VAT returns a pointer to the VAT Field.
func (c FieldsCollection) VAT() *models.Field {
	return c.MustGet("VAT")
}

// Website returns a pointer to the Website Field.
func (c FieldsCollection) Website() *models.Field {
	return c.MustGet("Website")
}

// WriteDate returns a pointer to the WriteDate Field.
func (c FieldsCollection) WriteDate() *models.Field {
	return c.MustGet("WriteDate")
}

// WriteUID returns a pointer to the WriteUID Field.
func (c FieldsCollection) WriteUID() *models.Field {
	return c.MustGet("WriteUID")
}

// Zip returns a pointer to the Zip Field.
func (c FieldsCollection) Zip() *models.Field {
	return c.MustGet("Zip")
}

// ------- METHOD COLLECTION ----------

// A MethodsCollection is the collection of methods
// of the User model.
type MethodsCollection struct {
	*models.MethodsCollection
}

// pActionArchive holds the metadata of the User.ActionArchive() method
type pActionArchive struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionArchive) Extend(fnct func(m.UserSet)) pActionArchive {
	return pActionArchive{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionArchive) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionArchive{}

// ActionArchive returns a pointer to the ActionArchive Method.
func (c MethodsCollection) ActionArchive() pActionArchive {
	return pActionArchive{
		Method: c.MustGet("ActionArchive"),
	}
}

// pActionGet holds the metadata of the User.ActionGet() method
type pActionGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionGet) Extend(fnct func(m.UserSet) *actions.Action) pActionGet {
	return pActionGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionGet{}

// ActionGet returns a pointer to the ActionGet Method.
func (c MethodsCollection) ActionGet() pActionGet {
	return pActionGet{
		Method: c.MustGet("ActionGet"),
	}
}

// pActionShowGroups holds the metadata of the User.ActionShowGroups() method
type pActionShowGroups struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionShowGroups) Extend(fnct func(m.UserSet) *actions.Action) pActionShowGroups {
	return pActionShowGroups{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionShowGroups) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionShowGroups{}

// ActionShowGroups returns a pointer to the ActionShowGroups Method.
func (c MethodsCollection) ActionShowGroups() pActionShowGroups {
	return pActionShowGroups{
		Method: c.MustGet("ActionShowGroups"),
	}
}

// pActionUnarchive holds the metadata of the User.ActionUnarchive() method
type pActionUnarchive struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pActionUnarchive) Extend(fnct func(m.UserSet)) pActionUnarchive {
	return pActionUnarchive{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pActionUnarchive) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pActionUnarchive{}

// ActionUnarchive returns a pointer to the ActionUnarchive Method.
func (c MethodsCollection) ActionUnarchive() pActionUnarchive {
	return pActionUnarchive{
		Method: c.MustGet("ActionUnarchive"),
	}
}

// pAddDomainLimitOffset holds the metadata of the User.AddDomainLimitOffset() method
type pAddDomainLimitOffset struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddDomainLimitOffset) Extend(fnct func(m.UserSet, domains.Domain, int, int, string) m.UserSet) pAddDomainLimitOffset {
	return pAddDomainLimitOffset{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddDomainLimitOffset) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddDomainLimitOffset{}

// AddDomainLimitOffset returns a pointer to the AddDomainLimitOffset Method.
func (c MethodsCollection) AddDomainLimitOffset() pAddDomainLimitOffset {
	return pAddDomainLimitOffset{
		Method: c.MustGet("AddDomainLimitOffset"),
	}
}

// pAddMandatoryGroups holds the metadata of the User.AddMandatoryGroups() method
type pAddMandatoryGroups struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddMandatoryGroups) Extend(fnct func(m.UserSet)) pAddMandatoryGroups {
	return pAddMandatoryGroups{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddMandatoryGroups) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddMandatoryGroups{}

// AddMandatoryGroups returns a pointer to the AddMandatoryGroups Method.
func (c MethodsCollection) AddMandatoryGroups() pAddMandatoryGroups {
	return pAddMandatoryGroups{
		Method: c.MustGet("AddMandatoryGroups"),
	}
}

// pAddModifiers holds the metadata of the User.AddModifiers() method
type pAddModifiers struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddModifiers) Extend(fnct func(m.UserSet, *etree.Document, map[string]*models.FieldInfo)) pAddModifiers {
	return pAddModifiers{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddModifiers) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddModifiers{}

// AddModifiers returns a pointer to the AddModifiers Method.
func (c MethodsCollection) AddModifiers() pAddModifiers {
	return pAddModifiers{
		Method: c.MustGet("AddModifiers"),
	}
}

// pAddNamesToRelations holds the metadata of the User.AddNamesToRelations() method
type pAddNamesToRelations struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAddNamesToRelations) Extend(fnct func(m.UserSet, models.RecordData, map[string]*models.FieldInfo) models.RecordData) pAddNamesToRelations {
	return pAddNamesToRelations{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAddNamesToRelations) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAddNamesToRelations{}

// AddNamesToRelations returns a pointer to the AddNamesToRelations Method.
func (c MethodsCollection) AddNamesToRelations() pAddNamesToRelations {
	return pAddNamesToRelations{
		Method: c.MustGet("AddNamesToRelations"),
	}
}

// pAggregates holds the metadata of the User.Aggregates() method
type pAggregates struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAggregates) Extend(fnct func(m.UserSet, ...models.FieldName) []m.UserGroupAggregateRow) pAggregates {
	return pAggregates{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAggregates) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAggregates{}

// Aggregates returns a pointer to the Aggregates Method.
func (c MethodsCollection) Aggregates() pAggregates {
	return pAggregates{
		Method: c.MustGet("Aggregates"),
	}
}

// pAuthenticate holds the metadata of the User.Authenticate() method
type pAuthenticate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pAuthenticate) Extend(fnct func(m.UserSet, string, string) int64) pAuthenticate {
	return pAuthenticate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pAuthenticate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pAuthenticate{}

// Authenticate returns a pointer to the Authenticate Method.
func (c MethodsCollection) Authenticate() pAuthenticate {
	return pAuthenticate{
		Method: c.MustGet("Authenticate"),
	}
}

// pBrowse holds the metadata of the User.Browse() method
type pBrowse struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pBrowse) Extend(fnct func(m.UserSet, []int64) m.UserSet) pBrowse {
	return pBrowse{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pBrowse) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pBrowse{}

// Browse returns a pointer to the Browse Method.
func (c MethodsCollection) Browse() pBrowse {
	return pBrowse{
		Method: c.MustGet("Browse"),
	}
}

// pBrowseOne holds the metadata of the User.BrowseOne() method
type pBrowseOne struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pBrowseOne) Extend(fnct func(m.UserSet, int64) m.UserSet) pBrowseOne {
	return pBrowseOne{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pBrowseOne) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pBrowseOne{}

// BrowseOne returns a pointer to the BrowseOne Method.
func (c MethodsCollection) BrowseOne() pBrowseOne {
	return pBrowseOne{
		Method: c.MustGet("BrowseOne"),
	}
}

// pCartesianProduct holds the metadata of the User.CartesianProduct() method
type pCartesianProduct struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCartesianProduct) Extend(fnct func(m.UserSet, ...m.UserSet) []m.UserSet) pCartesianProduct {
	return pCartesianProduct{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCartesianProduct) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCartesianProduct{}

// CartesianProduct returns a pointer to the CartesianProduct Method.
func (c MethodsCollection) CartesianProduct() pCartesianProduct {
	return pCartesianProduct{
		Method: c.MustGet("CartesianProduct"),
	}
}

// pChangePassword holds the metadata of the User.ChangePassword() method
type pChangePassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pChangePassword) Extend(fnct func(m.UserSet, string, string) bool) pChangePassword {
	return pChangePassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pChangePassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pChangePassword{}

// ChangePassword returns a pointer to the ChangePassword Method.
func (c MethodsCollection) ChangePassword() pChangePassword {
	return pChangePassword{
		Method: c.MustGet("ChangePassword"),
	}
}

// pCheckAccessRights holds the metadata of the User.CheckAccessRights() method
type pCheckAccessRights struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckAccessRights) Extend(fnct func(m.UserSet, webtypes.CheckAccessRightsArgs) bool) pCheckAccessRights {
	return pCheckAccessRights{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckAccessRights) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckAccessRights{}

// CheckAccessRights returns a pointer to the CheckAccessRights Method.
func (c MethodsCollection) CheckAccessRights() pCheckAccessRights {
	return pCheckAccessRights{
		Method: c.MustGet("CheckAccessRights"),
	}
}

// pCheckActionID holds the metadata of the User.CheckActionID() method
type pCheckActionID struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckActionID) Extend(fnct func(m.UserSet)) pCheckActionID {
	return pCheckActionID{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckActionID) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckActionID{}

// CheckActionID returns a pointer to the CheckActionID Method.
func (c MethodsCollection) CheckActionID() pCheckActionID {
	return pCheckActionID{
		Method: c.MustGet("CheckActionID"),
	}
}

// pCheckCompany holds the metadata of the User.CheckCompany() method
type pCheckCompany struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckCompany) Extend(fnct func(m.UserSet)) pCheckCompany {
	return pCheckCompany{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckCompany) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckCompany{}

// CheckCompany returns a pointer to the CheckCompany Method.
func (c MethodsCollection) CheckCompany() pCheckCompany {
	return pCheckCompany{
		Method: c.MustGet("CheckCompany"),
	}
}

// pCheckCredentials holds the metadata of the User.CheckCredentials() method
type pCheckCredentials struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckCredentials) Extend(fnct func(m.UserSet, string)) pCheckCredentials {
	return pCheckCredentials{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckCredentials) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckCredentials{}

// CheckCredentials returns a pointer to the CheckCredentials Method.
func (c MethodsCollection) CheckCredentials() pCheckCredentials {
	return pCheckCredentials{
		Method: c.MustGet("CheckCredentials"),
	}
}

// pCheckExecutionPermission holds the metadata of the User.CheckExecutionPermission() method
type pCheckExecutionPermission struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckExecutionPermission) Extend(fnct func(m.UserSet, *models.Method, ...bool) bool) pCheckExecutionPermission {
	return pCheckExecutionPermission{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckExecutionPermission) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckExecutionPermission{}

// CheckExecutionPermission returns a pointer to the CheckExecutionPermission Method.
func (c MethodsCollection) CheckExecutionPermission() pCheckExecutionPermission {
	return pCheckExecutionPermission{
		Method: c.MustGet("CheckExecutionPermission"),
	}
}

// pCheckGroupsSync holds the metadata of the User.CheckGroupsSync() method
type pCheckGroupsSync struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckGroupsSync) Extend(fnct func(m.UserSet) bool) pCheckGroupsSync {
	return pCheckGroupsSync{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckGroupsSync) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckGroupsSync{}

// CheckGroupsSync returns a pointer to the CheckGroupsSync Method.
func (c MethodsCollection) CheckGroupsSync() pCheckGroupsSync {
	return pCheckGroupsSync{
		Method: c.MustGet("CheckGroupsSync"),
	}
}

// pCheckOneUserType holds the metadata of the User.CheckOneUserType() method
type pCheckOneUserType struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckOneUserType) Extend(fnct func(m.UserSet)) pCheckOneUserType {
	return pCheckOneUserType{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckOneUserType) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckOneUserType{}

// CheckOneUserType returns a pointer to the CheckOneUserType Method.
func (c MethodsCollection) CheckOneUserType() pCheckOneUserType {
	return pCheckOneUserType{
		Method: c.MustGet("CheckOneUserType"),
	}
}

// pCheckRecursion holds the metadata of the User.CheckRecursion() method
type pCheckRecursion struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCheckRecursion) Extend(fnct func(m.UserSet) bool) pCheckRecursion {
	return pCheckRecursion{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCheckRecursion) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCheckRecursion{}

// CheckRecursion returns a pointer to the CheckRecursion Method.
func (c MethodsCollection) CheckRecursion() pCheckRecursion {
	return pCheckRecursion{
		Method: c.MustGet("CheckRecursion"),
	}
}

// pComputeAccessesCount holds the metadata of the User.ComputeAccessesCount() method
type pComputeAccessesCount struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeAccessesCount) Extend(fnct func(m.UserSet) m.UserData) pComputeAccessesCount {
	return pComputeAccessesCount{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeAccessesCount) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeAccessesCount{}

// ComputeAccessesCount returns a pointer to the ComputeAccessesCount Method.
func (c MethodsCollection) ComputeAccessesCount() pComputeAccessesCount {
	return pComputeAccessesCount{
		Method: c.MustGet("ComputeAccessesCount"),
	}
}

// pComputeCompaniesCount holds the metadata of the User.ComputeCompaniesCount() method
type pComputeCompaniesCount struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeCompaniesCount) Extend(fnct func(m.UserSet) m.UserData) pComputeCompaniesCount {
	return pComputeCompaniesCount{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeCompaniesCount) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeCompaniesCount{}

// ComputeCompaniesCount returns a pointer to the ComputeCompaniesCount Method.
func (c MethodsCollection) ComputeCompaniesCount() pComputeCompaniesCount {
	return pComputeCompaniesCount{
		Method: c.MustGet("ComputeCompaniesCount"),
	}
}

// pComputeDisplayName holds the metadata of the User.ComputeDisplayName() method
type pComputeDisplayName struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeDisplayName) Extend(fnct func(m.UserSet) *models.ModelData) pComputeDisplayName {
	return pComputeDisplayName{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeDisplayName) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeDisplayName{}

// ComputeDisplayName returns a pointer to the ComputeDisplayName Method.
func (c MethodsCollection) ComputeDisplayName() pComputeDisplayName {
	return pComputeDisplayName{
		Method: c.MustGet("ComputeDisplayName"),
	}
}

// pComputeLastUpdate holds the metadata of the User.ComputeLastUpdate() method
type pComputeLastUpdate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeLastUpdate) Extend(fnct func(m.UserSet) *models.ModelData) pComputeLastUpdate {
	return pComputeLastUpdate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeLastUpdate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeLastUpdate{}

// ComputeLastUpdate returns a pointer to the ComputeLastUpdate Method.
func (c MethodsCollection) ComputeLastUpdate() pComputeLastUpdate {
	return pComputeLastUpdate{
		Method: c.MustGet("ComputeLastUpdate"),
	}
}

// pComputePassword holds the metadata of the User.ComputePassword() method
type pComputePassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputePassword) Extend(fnct func(m.UserSet) m.UserData) pComputePassword {
	return pComputePassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputePassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputePassword{}

// ComputePassword returns a pointer to the ComputePassword Method.
func (c MethodsCollection) ComputePassword() pComputePassword {
	return pComputePassword{
		Method: c.MustGet("ComputePassword"),
	}
}

// pComputeSessionToken holds the metadata of the User.ComputeSessionToken() method
type pComputeSessionToken struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeSessionToken) Extend(fnct func(m.UserSet, string) string) pComputeSessionToken {
	return pComputeSessionToken{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeSessionToken) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeSessionToken{}

// ComputeSessionToken returns a pointer to the ComputeSessionToken Method.
func (c MethodsCollection) ComputeSessionToken() pComputeSessionToken {
	return pComputeSessionToken{
		Method: c.MustGet("ComputeSessionToken"),
	}
}

// pComputeShare holds the metadata of the User.ComputeShare() method
type pComputeShare struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeShare) Extend(fnct func(m.UserSet) m.UserData) pComputeShare {
	return pComputeShare{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeShare) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeShare{}

// ComputeShare returns a pointer to the ComputeShare Method.
func (c MethodsCollection) ComputeShare() pComputeShare {
	return pComputeShare{
		Method: c.MustGet("ComputeShare"),
	}
}

// pComputeTZOffset holds the metadata of the User.ComputeTZOffset() method
type pComputeTZOffset struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pComputeTZOffset) Extend(fnct func(m.UserSet) m.UserData) pComputeTZOffset {
	return pComputeTZOffset{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pComputeTZOffset) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pComputeTZOffset{}

// ComputeTZOffset returns a pointer to the ComputeTZOffset Method.
func (c MethodsCollection) ComputeTZOffset() pComputeTZOffset {
	return pComputeTZOffset{
		Method: c.MustGet("ComputeTZOffset"),
	}
}

// pContextGet holds the metadata of the User.ContextGet() method
type pContextGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pContextGet) Extend(fnct func(m.UserSet) *types.Context) pContextGet {
	return pContextGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pContextGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pContextGet{}

// ContextGet returns a pointer to the ContextGet Method.
func (c MethodsCollection) ContextGet() pContextGet {
	return pContextGet{
		Method: c.MustGet("ContextGet"),
	}
}

// pCopy holds the metadata of the User.Copy() method
type pCopy struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCopy) Extend(fnct func(m.UserSet, m.UserData) m.UserSet) pCopy {
	return pCopy{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCopy) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCopy{}

// Copy returns a pointer to the Copy Method.
func (c MethodsCollection) Copy() pCopy {
	return pCopy{
		Method: c.MustGet("Copy"),
	}
}

// pCopyData holds the metadata of the User.CopyData() method
type pCopyData struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCopyData) Extend(fnct func(m.UserSet, m.UserData) m.UserData) pCopyData {
	return pCopyData{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCopyData) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCopyData{}

// CopyData returns a pointer to the CopyData Method.
func (c MethodsCollection) CopyData() pCopyData {
	return pCopyData{
		Method: c.MustGet("CopyData"),
	}
}

// pCreate holds the metadata of the User.Create() method
type pCreate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCreate) Extend(fnct func(m.UserSet, m.UserData) m.UserSet) pCreate {
	return pCreate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCreate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCreate{}

// Create returns a pointer to the Create Method.
func (c MethodsCollection) Create() pCreate {
	return pCreate{
		Method: c.MustGet("Create"),
	}
}

// pCurrentUser holds the metadata of the User.CurrentUser() method
type pCurrentUser struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pCurrentUser) Extend(fnct func(m.UserSet) m.UserSet) pCurrentUser {
	return pCurrentUser{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pCurrentUser) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pCurrentUser{}

// CurrentUser returns a pointer to the CurrentUser Method.
func (c MethodsCollection) CurrentUser() pCurrentUser {
	return pCurrentUser{
		Method: c.MustGet("CurrentUser"),
	}
}

// pDefaultGet holds the metadata of the User.DefaultGet() method
type pDefaultGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pDefaultGet) Extend(fnct func(m.UserSet) m.UserData) pDefaultGet {
	return pDefaultGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pDefaultGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pDefaultGet{}

// DefaultGet returns a pointer to the DefaultGet Method.
func (c MethodsCollection) DefaultGet() pDefaultGet {
	return pDefaultGet{
		Method: c.MustGet("DefaultGet"),
	}
}

// pEnqueue holds the metadata of the User.Enqueue() method
type pEnqueue struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pEnqueue) Extend(fnct func(m.UserSet, string, models.Methoder, ...interface{}) m.QueueJobSet) pEnqueue {
	return pEnqueue{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pEnqueue) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pEnqueue{}

// Enqueue returns a pointer to the Enqueue Method.
func (c MethodsCollection) Enqueue() pEnqueue {
	return pEnqueue{
		Method: c.MustGet("Enqueue"),
	}
}

// pEquals holds the metadata of the User.Equals() method
type pEquals struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pEquals) Extend(fnct func(m.UserSet, m.UserSet) bool) pEquals {
	return pEquals{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pEquals) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pEquals{}

// Equals returns a pointer to the Equals Method.
func (c MethodsCollection) Equals() pEquals {
	return pEquals{
		Method: c.MustGet("Equals"),
	}
}

// pExecuteO2MActions holds the metadata of the User.ExecuteO2MActions() method
type pExecuteO2MActions struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pExecuteO2MActions) Extend(fnct func(m.UserSet, models.FieldName, *models.FieldInfo, interface{}) interface{}) pExecuteO2MActions {
	return pExecuteO2MActions{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pExecuteO2MActions) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pExecuteO2MActions{}

// ExecuteO2MActions returns a pointer to the ExecuteO2MActions Method.
func (c MethodsCollection) ExecuteO2MActions() pExecuteO2MActions {
	return pExecuteO2MActions{
		Method: c.MustGet("ExecuteO2MActions"),
	}
}

// pFetch holds the metadata of the User.Fetch() method
type pFetch struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFetch) Extend(fnct func(m.UserSet) m.UserSet) pFetch {
	return pFetch{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFetch) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFetch{}

// Fetch returns a pointer to the Fetch Method.
func (c MethodsCollection) Fetch() pFetch {
	return pFetch{
		Method: c.MustGet("Fetch"),
	}
}

// pFieldGet holds the metadata of the User.FieldGet() method
type pFieldGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFieldGet) Extend(fnct func(m.UserSet, models.FieldName) *models.FieldInfo) pFieldGet {
	return pFieldGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFieldGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFieldGet{}

// FieldGet returns a pointer to the FieldGet Method.
func (c MethodsCollection) FieldGet() pFieldGet {
	return pFieldGet{
		Method: c.MustGet("FieldGet"),
	}
}

// pFieldsGet holds the metadata of the User.FieldsGet() method
type pFieldsGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFieldsGet) Extend(fnct func(m.UserSet, models.FieldsGetArgs) map[string]*models.FieldInfo) pFieldsGet {
	return pFieldsGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFieldsGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFieldsGet{}

// FieldsGet returns a pointer to the FieldsGet Method.
func (c MethodsCollection) FieldsGet() pFieldsGet {
	return pFieldsGet{
		Method: c.MustGet("FieldsGet"),
	}
}

// pFieldsViewGet holds the metadata of the User.FieldsViewGet() method
type pFieldsViewGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFieldsViewGet) Extend(fnct func(m.UserSet, webtypes.FieldsViewGetParams) *webtypes.FieldsViewData) pFieldsViewGet {
	return pFieldsViewGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFieldsViewGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFieldsViewGet{}

// FieldsViewGet returns a pointer to the FieldsViewGet Method.
func (c MethodsCollection) FieldsViewGet() pFieldsViewGet {
	return pFieldsViewGet{
		Method: c.MustGet("FieldsViewGet"),
	}
}

// pFiltered holds the metadata of the User.Filtered() method
type pFiltered struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFiltered) Extend(fnct func(m.UserSet, func(m.UserSet) bool) m.UserSet) pFiltered {
	return pFiltered{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFiltered) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFiltered{}

// Filtered returns a pointer to the Filtered Method.
func (c MethodsCollection) Filtered() pFiltered {
	return pFiltered{
		Method: c.MustGet("Filtered"),
	}
}

// pFormatRelationFields holds the metadata of the User.FormatRelationFields() method
type pFormatRelationFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pFormatRelationFields) Extend(fnct func(m.UserSet, models.RecordData, map[string]*models.FieldInfo) models.RecordData) pFormatRelationFields {
	return pFormatRelationFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pFormatRelationFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pFormatRelationFields{}

// FormatRelationFields returns a pointer to the FormatRelationFields Method.
func (c MethodsCollection) FormatRelationFields() pFormatRelationFields {
	return pFormatRelationFields{
		Method: c.MustGet("FormatRelationFields"),
	}
}

// pGetCompany holds the metadata of the User.GetCompany() method
type pGetCompany struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetCompany) Extend(fnct func(m.UserSet) m.CompanySet) pGetCompany {
	return pGetCompany{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetCompany) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetCompany{}

// GetCompany returns a pointer to the GetCompany Method.
func (c MethodsCollection) GetCompany() pGetCompany {
	return pGetCompany{
		Method: c.MustGet("GetCompany"),
	}
}

// pGetCompanyCurrency holds the metadata of the User.GetCompanyCurrency() method
type pGetCompanyCurrency struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetCompanyCurrency) Extend(fnct func(m.UserSet) m.CurrencySet) pGetCompanyCurrency {
	return pGetCompanyCurrency{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetCompanyCurrency) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetCompanyCurrency{}

// GetCompanyCurrency returns a pointer to the GetCompanyCurrency Method.
func (c MethodsCollection) GetCompanyCurrency() pGetCompanyCurrency {
	return pGetCompanyCurrency{
		Method: c.MustGet("GetCompanyCurrency"),
	}
}

// pGetFormviewAction holds the metadata of the User.GetFormviewAction() method
type pGetFormviewAction struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetFormviewAction) Extend(fnct func(m.UserSet) *actions.Action) pGetFormviewAction {
	return pGetFormviewAction{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetFormviewAction) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetFormviewAction{}

// GetFormviewAction returns a pointer to the GetFormviewAction Method.
func (c MethodsCollection) GetFormviewAction() pGetFormviewAction {
	return pGetFormviewAction{
		Method: c.MustGet("GetFormviewAction"),
	}
}

// pGetFormviewId holds the metadata of the User.GetFormviewId() method
type pGetFormviewId struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetFormviewId) Extend(fnct func(m.UserSet) string) pGetFormviewId {
	return pGetFormviewId{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetFormviewId) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetFormviewId{}

// GetFormviewId returns a pointer to the GetFormviewId Method.
func (c MethodsCollection) GetFormviewId() pGetFormviewId {
	return pGetFormviewId{
		Method: c.MustGet("GetFormviewId"),
	}
}

// pGetLoginDomain holds the metadata of the User.GetLoginDomain() method
type pGetLoginDomain struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetLoginDomain) Extend(fnct func(m.UserSet, string) q.UserCondition) pGetLoginDomain {
	return pGetLoginDomain{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetLoginDomain) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetLoginDomain{}

// GetLoginDomain returns a pointer to the GetLoginDomain Method.
func (c MethodsCollection) GetLoginDomain() pGetLoginDomain {
	return pGetLoginDomain{
		Method: c.MustGet("GetLoginDomain"),
	}
}

// pGetRecord holds the metadata of the User.GetRecord() method
type pGetRecord struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetRecord) Extend(fnct func(m.UserSet, string) m.UserSet) pGetRecord {
	return pGetRecord{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetRecord) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetRecord{}

// GetRecord returns a pointer to the GetRecord Method.
func (c MethodsCollection) GetRecord() pGetRecord {
	return pGetRecord{
		Method: c.MustGet("GetRecord"),
	}
}

// pGetSessionTokenFields holds the metadata of the User.GetSessionTokenFields() method
type pGetSessionTokenFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetSessionTokenFields) Extend(fnct func(m.UserSet) models.FieldNames) pGetSessionTokenFields {
	return pGetSessionTokenFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetSessionTokenFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetSessionTokenFields{}

// GetSessionTokenFields returns a pointer to the GetSessionTokenFields Method.
func (c MethodsCollection) GetSessionTokenFields() pGetSessionTokenFields {
	return pGetSessionTokenFields{
		Method: c.MustGet("GetSessionTokenFields"),
	}
}

// pGetToolbar holds the metadata of the User.GetToolbar() method
type pGetToolbar struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGetToolbar) Extend(fnct func(m.UserSet) webtypes.Toolbar) pGetToolbar {
	return pGetToolbar{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGetToolbar) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGetToolbar{}

// GetToolbar returns a pointer to the GetToolbar Method.
func (c MethodsCollection) GetToolbar() pGetToolbar {
	return pGetToolbar{
		Method: c.MustGet("GetToolbar"),
	}
}

// pGroupBy holds the metadata of the User.GroupBy() method
type pGroupBy struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pGroupBy) Extend(fnct func(m.UserSet, ...models.FieldName) m.UserSet) pGroupBy {
	return pGroupBy{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pGroupBy) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pGroupBy{}

// GroupBy returns a pointer to the GroupBy Method.
func (c MethodsCollection) GroupBy() pGroupBy {
	return pGroupBy{
		Method: c.MustGet("GroupBy"),
	}
}

// pHasGroup holds the metadata of the User.HasGroup() method
type pHasGroup struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pHasGroup) Extend(fnct func(m.UserSet, string) bool) pHasGroup {
	return pHasGroup{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pHasGroup) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pHasGroup{}

// HasGroup returns a pointer to the HasGroup Method.
func (c MethodsCollection) HasGroup() pHasGroup {
	return pHasGroup{
		Method: c.MustGet("HasGroup"),
	}
}

// pHasMultipleGroups holds the metadata of the User.HasMultipleGroups() method
type pHasMultipleGroups struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pHasMultipleGroups) Extend(fnct func(m.UserSet, m.GroupSet) bool) pHasMultipleGroups {
	return pHasMultipleGroups{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pHasMultipleGroups) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pHasMultipleGroups{}

// HasMultipleGroups returns a pointer to the HasMultipleGroups Method.
func (c MethodsCollection) HasMultipleGroups() pHasMultipleGroups {
	return pHasMultipleGroups{
		Method: c.MustGet("HasMultipleGroups"),
	}
}

// pHashPassword holds the metadata of the User.HashPassword() method
type pHashPassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pHashPassword) Extend(fnct func(m.UserSet, string) string) pHashPassword {
	return pHashPassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pHashPassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pHashPassword{}

// HashPassword returns a pointer to the HashPassword Method.
func (c MethodsCollection) HashPassword() pHashPassword {
	return pHashPassword{
		Method: c.MustGet("HashPassword"),
	}
}

// pInit holds the metadata of the User.Init() method
type pInit struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pInit) Extend(fnct func(m.UserSet)) pInit {
	return pInit{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pInit) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pInit{}

// Init returns a pointer to the Init Method.
func (c MethodsCollection) Init() pInit {
	return pInit{
		Method: c.MustGet("Init"),
	}
}

// pIntersect holds the metadata of the User.Intersect() method
type pIntersect struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIntersect) Extend(fnct func(m.UserSet, m.UserSet) m.UserSet) pIntersect {
	return pIntersect{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIntersect) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIntersect{}

// Intersect returns a pointer to the Intersect Method.
func (c MethodsCollection) Intersect() pIntersect {
	return pIntersect{
		Method: c.MustGet("Intersect"),
	}
}

// pInverseNewPassword holds the metadata of the User.InverseNewPassword() method
type pInverseNewPassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pInverseNewPassword) Extend(fnct func(m.UserSet, string)) pInverseNewPassword {
	return pInverseNewPassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pInverseNewPassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pInverseNewPassword{}

// InverseNewPassword returns a pointer to the InverseNewPassword Method.
func (c MethodsCollection) InverseNewPassword() pInverseNewPassword {
	return pInverseNewPassword{
		Method: c.MustGet("InverseNewPassword"),
	}
}

// pInversePassword holds the metadata of the User.InversePassword() method
type pInversePassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pInversePassword) Extend(fnct func(m.UserSet, string)) pInversePassword {
	return pInversePassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pInversePassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pInversePassword{}

// InversePassword returns a pointer to the InversePassword Method.
func (c MethodsCollection) InversePassword() pInversePassword {
	return pInversePassword{
		Method: c.MustGet("InversePassword"),
	}
}

// pIsAdmin holds the metadata of the User.IsAdmin() method
type pIsAdmin struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIsAdmin) Extend(fnct func(m.UserSet) bool) pIsAdmin {
	return pIsAdmin{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIsAdmin) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIsAdmin{}

// IsAdmin returns a pointer to the IsAdmin Method.
func (c MethodsCollection) IsAdmin() pIsAdmin {
	return pIsAdmin{
		Method: c.MustGet("IsAdmin"),
	}
}

// pIsPublic holds the metadata of the User.IsPublic() method
type pIsPublic struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIsPublic) Extend(fnct func(m.UserSet) bool) pIsPublic {
	return pIsPublic{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIsPublic) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIsPublic{}

// IsPublic returns a pointer to the IsPublic Method.
func (c MethodsCollection) IsPublic() pIsPublic {
	return pIsPublic{
		Method: c.MustGet("IsPublic"),
	}
}

// pIsSuperUser holds the metadata of the User.IsSuperUser() method
type pIsSuperUser struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIsSuperUser) Extend(fnct func(m.UserSet) bool) pIsSuperUser {
	return pIsSuperUser{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIsSuperUser) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIsSuperUser{}

// IsSuperUser returns a pointer to the IsSuperUser Method.
func (c MethodsCollection) IsSuperUser() pIsSuperUser {
	return pIsSuperUser{
		Method: c.MustGet("IsSuperUser"),
	}
}

// pIsSystem holds the metadata of the User.IsSystem() method
type pIsSystem struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pIsSystem) Extend(fnct func(m.UserSet) bool) pIsSystem {
	return pIsSystem{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pIsSystem) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pIsSystem{}

// IsSystem returns a pointer to the IsSystem Method.
func (c MethodsCollection) IsSystem() pIsSystem {
	return pIsSystem{
		Method: c.MustGet("IsSystem"),
	}
}

// pLimit holds the metadata of the User.Limit() method
type pLimit struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pLimit) Extend(fnct func(m.UserSet, int) m.UserSet) pLimit {
	return pLimit{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pLimit) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pLimit{}

// Limit returns a pointer to the Limit Method.
func (c MethodsCollection) Limit() pLimit {
	return pLimit{
		Method: c.MustGet("Limit"),
	}
}

// pLoad holds the metadata of the User.Load() method
type pLoad struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pLoad) Extend(fnct func(m.UserSet, ...models.FieldName) m.UserSet) pLoad {
	return pLoad{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pLoad) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pLoad{}

// Load returns a pointer to the Load Method.
func (c MethodsCollection) Load() pLoad {
	return pLoad{
		Method: c.MustGet("Load"),
	}
}

// pLoadViews holds the metadata of the User.LoadViews() method
type pLoadViews struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pLoadViews) Extend(fnct func(m.UserSet, webtypes.LoadViewsArgs) *webtypes.LoadViewsData) pLoadViews {
	return pLoadViews{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pLoadViews) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pLoadViews{}

// LoadViews returns a pointer to the LoadViews Method.
func (c MethodsCollection) LoadViews() pLoadViews {
	return pLoadViews{
		Method: c.MustGet("LoadViews"),
	}
}

// pManageGroupsOnFields holds the metadata of the User.ManageGroupsOnFields() method
type pManageGroupsOnFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pManageGroupsOnFields) Extend(fnct func(m.UserSet, *etree.Document, map[string]*models.FieldInfo)) pManageGroupsOnFields {
	return pManageGroupsOnFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pManageGroupsOnFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pManageGroupsOnFields{}

// ManageGroupsOnFields returns a pointer to the ManageGroupsOnFields Method.
func (c MethodsCollection) ManageGroupsOnFields() pManageGroupsOnFields {
	return pManageGroupsOnFields{
		Method: c.MustGet("ManageGroupsOnFields"),
	}
}

// pNameGet holds the metadata of the User.NameGet() method
type pNameGet struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNameGet) Extend(fnct func(m.UserSet) string) pNameGet {
	return pNameGet{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNameGet) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNameGet{}

// NameGet returns a pointer to the NameGet Method.
func (c MethodsCollection) NameGet() pNameGet {
	return pNameGet{
		Method: c.MustGet("NameGet"),
	}
}

// pNameSearch holds the metadata of the User.NameSearch() method
type pNameSearch struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNameSearch) Extend(fnct func(m.UserSet, webtypes.NameSearchParams) []webtypes.RecordIDWithName) pNameSearch {
	return pNameSearch{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNameSearch) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNameSearch{}

// NameSearch returns a pointer to the NameSearch Method.
func (c MethodsCollection) NameSearch() pNameSearch {
	return pNameSearch{
		Method: c.MustGet("NameSearch"),
	}
}

// pNew holds the metadata of the User.New() method
type pNew struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNew) Extend(fnct func(m.UserSet, m.UserData) m.UserSet) pNew {
	return pNew{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNew) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNew{}

// New returns a pointer to the New Method.
func (c MethodsCollection) New() pNew {
	return pNew{
		Method: c.MustGet("New"),
	}
}

// pNormalizeM2MData holds the metadata of the User.NormalizeM2MData() method
type pNormalizeM2MData struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pNormalizeM2MData) Extend(fnct func(m.UserSet, models.FieldName, *models.FieldInfo, interface{}) interface{}) pNormalizeM2MData {
	return pNormalizeM2MData{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pNormalizeM2MData) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pNormalizeM2MData{}

// NormalizeM2MData returns a pointer to the NormalizeM2MData Method.
func (c MethodsCollection) NormalizeM2MData() pNormalizeM2MData {
	return pNormalizeM2MData{
		Method: c.MustGet("NormalizeM2MData"),
	}
}

// pOffset holds the metadata of the User.Offset() method
type pOffset struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOffset) Extend(fnct func(m.UserSet, int) m.UserSet) pOffset {
	return pOffset{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOffset) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOffset{}

// Offset returns a pointer to the Offset Method.
func (c MethodsCollection) Offset() pOffset {
	return pOffset{
		Method: c.MustGet("Offset"),
	}
}

// pOnchange holds the metadata of the User.Onchange() method
type pOnchange struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOnchange) Extend(fnct func(m.UserSet, models.OnchangeParams) models.OnchangeResult) pOnchange {
	return pOnchange{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOnchange) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOnchange{}

// Onchange returns a pointer to the Onchange Method.
func (c MethodsCollection) Onchange() pOnchange {
	return pOnchange{
		Method: c.MustGet("Onchange"),
	}
}

// pOnchangeLogin holds the metadata of the User.OnchangeLogin() method
type pOnchangeLogin struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOnchangeLogin) Extend(fnct func(m.UserSet) m.UserData) pOnchangeLogin {
	return pOnchangeLogin{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOnchangeLogin) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOnchangeLogin{}

// OnchangeLogin returns a pointer to the OnchangeLogin Method.
func (c MethodsCollection) OnchangeLogin() pOnchangeLogin {
	return pOnchangeLogin{
		Method: c.MustGet("OnchangeLogin"),
	}
}

// pOrderBy holds the metadata of the User.OrderBy() method
type pOrderBy struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pOrderBy) Extend(fnct func(m.UserSet, ...string) m.UserSet) pOrderBy {
	return pOrderBy{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pOrderBy) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pOrderBy{}

// OrderBy returns a pointer to the OrderBy Method.
func (c MethodsCollection) OrderBy() pOrderBy {
	return pOrderBy{
		Method: c.MustGet("OrderBy"),
	}
}

// pPostProcessCreateValues holds the metadata of the User.PostProcessCreateValues() method
type pPostProcessCreateValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPostProcessCreateValues) Extend(fnct func(m.UserSet, models.RecordData)) pPostProcessCreateValues {
	return pPostProcessCreateValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPostProcessCreateValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPostProcessCreateValues{}

// PostProcessCreateValues returns a pointer to the PostProcessCreateValues Method.
func (c MethodsCollection) PostProcessCreateValues() pPostProcessCreateValues {
	return pPostProcessCreateValues{
		Method: c.MustGet("PostProcessCreateValues"),
	}
}

// pPostProcessFilters holds the metadata of the User.PostProcessFilters() method
type pPostProcessFilters struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPostProcessFilters) Extend(fnct func(m.UserSet, map[models.FieldName]models.Conditioner) map[string][]interface{}) pPostProcessFilters {
	return pPostProcessFilters{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPostProcessFilters) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPostProcessFilters{}

// PostProcessFilters returns a pointer to the PostProcessFilters Method.
func (c MethodsCollection) PostProcessFilters() pPostProcessFilters {
	return pPostProcessFilters{
		Method: c.MustGet("PostProcessFilters"),
	}
}

// pPreferenceChangePassword holds the metadata of the User.PreferenceChangePassword() method
type pPreferenceChangePassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPreferenceChangePassword) Extend(fnct func(m.UserSet) *actions.Action) pPreferenceChangePassword {
	return pPreferenceChangePassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPreferenceChangePassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPreferenceChangePassword{}

// PreferenceChangePassword returns a pointer to the PreferenceChangePassword Method.
func (c MethodsCollection) PreferenceChangePassword() pPreferenceChangePassword {
	return pPreferenceChangePassword{
		Method: c.MustGet("PreferenceChangePassword"),
	}
}

// pPreferenceSave holds the metadata of the User.PreferenceSave() method
type pPreferenceSave struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pPreferenceSave) Extend(fnct func(m.UserSet) *actions.Action) pPreferenceSave {
	return pPreferenceSave{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pPreferenceSave) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pPreferenceSave{}

// PreferenceSave returns a pointer to the PreferenceSave Method.
func (c MethodsCollection) PreferenceSave() pPreferenceSave {
	return pPreferenceSave{
		Method: c.MustGet("PreferenceSave"),
	}
}

// pProcessCreateValues holds the metadata of the User.ProcessCreateValues() method
type pProcessCreateValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessCreateValues) Extend(fnct func(m.UserSet, models.RecordData) (models.RecordData, models.RecordData)) pProcessCreateValues {
	return pProcessCreateValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessCreateValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessCreateValues{}

// ProcessCreateValues returns a pointer to the ProcessCreateValues Method.
func (c MethodsCollection) ProcessCreateValues() pProcessCreateValues {
	return pProcessCreateValues{
		Method: c.MustGet("ProcessCreateValues"),
	}
}

// pProcessElementAttrs holds the metadata of the User.ProcessElementAttrs() method
type pProcessElementAttrs struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessElementAttrs) Extend(fnct func(m.UserSet, *etree.Element, map[string]*models.FieldInfo) map[string]interface{}) pProcessElementAttrs {
	return pProcessElementAttrs{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessElementAttrs) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessElementAttrs{}

// ProcessElementAttrs returns a pointer to the ProcessElementAttrs Method.
func (c MethodsCollection) ProcessElementAttrs() pProcessElementAttrs {
	return pProcessElementAttrs{
		Method: c.MustGet("ProcessElementAttrs"),
	}
}

// pProcessFieldElementModifiers holds the metadata of the User.ProcessFieldElementModifiers() method
type pProcessFieldElementModifiers struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessFieldElementModifiers) Extend(fnct func(m.UserSet, *etree.Element, map[string]*models.FieldInfo, map[string]interface{}) map[string]interface{}) pProcessFieldElementModifiers {
	return pProcessFieldElementModifiers{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessFieldElementModifiers) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessFieldElementModifiers{}

// ProcessFieldElementModifiers returns a pointer to the ProcessFieldElementModifiers Method.
func (c MethodsCollection) ProcessFieldElementModifiers() pProcessFieldElementModifiers {
	return pProcessFieldElementModifiers{
		Method: c.MustGet("ProcessFieldElementModifiers"),
	}
}

// pProcessView holds the metadata of the User.ProcessView() method
type pProcessView struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessView) Extend(fnct func(m.UserSet, *etree.Document, map[string]*models.FieldInfo) string) pProcessView {
	return pProcessView{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessView) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessView{}

// ProcessView returns a pointer to the ProcessView Method.
func (c MethodsCollection) ProcessView() pProcessView {
	return pProcessView{
		Method: c.MustGet("ProcessView"),
	}
}

// pProcessWriteValues holds the metadata of the User.ProcessWriteValues() method
type pProcessWriteValues struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pProcessWriteValues) Extend(fnct func(m.UserSet, models.RecordData) models.RecordData) pProcessWriteValues {
	return pProcessWriteValues{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pProcessWriteValues) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pProcessWriteValues{}

// ProcessWriteValues returns a pointer to the ProcessWriteValues Method.
func (c MethodsCollection) ProcessWriteValues() pProcessWriteValues {
	return pProcessWriteValues{
		Method: c.MustGet("ProcessWriteValues"),
	}
}

// pRead holds the metadata of the User.Read() method
type pRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pRead) Extend(fnct func(m.UserSet, models.FieldNames) []models.RecordData) pRead {
	return pRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pRead{}

// Read returns a pointer to the Read Method.
func (c MethodsCollection) Read() pRead {
	return pRead{
		Method: c.MustGet("Read"),
	}
}

// pReadGroup holds the metadata of the User.ReadGroup() method
type pReadGroup struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pReadGroup) Extend(fnct func(m.UserSet, webtypes.ReadGroupParams) []models.FieldMap) pReadGroup {
	return pReadGroup{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pReadGroup) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pReadGroup{}

// ReadGroup returns a pointer to the ReadGroup Method.
func (c MethodsCollection) ReadGroup() pReadGroup {
	return pReadGroup{
		Method: c.MustGet("ReadGroup"),
	}
}

// pSQLFromCondition holds the metadata of the User.SQLFromCondition() method
type pSQLFromCondition struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSQLFromCondition) Extend(fnct func(m.UserSet, *models.Condition) (string, models.SQLParams)) pSQLFromCondition {
	return pSQLFromCondition{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSQLFromCondition) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSQLFromCondition{}

// SQLFromCondition returns a pointer to the SQLFromCondition Method.
func (c MethodsCollection) SQLFromCondition() pSQLFromCondition {
	return pSQLFromCondition{
		Method: c.MustGet("SQLFromCondition"),
	}
}

// pSearch holds the metadata of the User.Search() method
type pSearch struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearch) Extend(fnct func(m.UserSet, q.UserCondition) m.UserSet) pSearch {
	return pSearch{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearch) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearch{}

// Search returns a pointer to the Search Method.
func (c MethodsCollection) Search() pSearch {
	return pSearch{
		Method: c.MustGet("Search"),
	}
}

// pSearchAll holds the metadata of the User.SearchAll() method
type pSearchAll struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchAll) Extend(fnct func(m.UserSet) m.UserSet) pSearchAll {
	return pSearchAll{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchAll) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchAll{}

// SearchAll returns a pointer to the SearchAll Method.
func (c MethodsCollection) SearchAll() pSearchAll {
	return pSearchAll{
		Method: c.MustGet("SearchAll"),
	}
}

// pSearchByName holds the metadata of the User.SearchByName() method
type pSearchByName struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchByName) Extend(fnct func(m.UserSet, string, operator.Operator, q.UserCondition, int) m.UserSet) pSearchByName {
	return pSearchByName{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchByName) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchByName{}

// SearchByName returns a pointer to the SearchByName Method.
func (c MethodsCollection) SearchByName() pSearchByName {
	return pSearchByName{
		Method: c.MustGet("SearchByName"),
	}
}

// pSearchCount holds the metadata of the User.SearchCount() method
type pSearchCount struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchCount) Extend(fnct func(m.UserSet) int) pSearchCount {
	return pSearchCount{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchCount) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchCount{}

// SearchCount returns a pointer to the SearchCount Method.
func (c MethodsCollection) SearchCount() pSearchCount {
	return pSearchCount{
		Method: c.MustGet("SearchCount"),
	}
}

// pSearchDomain holds the metadata of the User.SearchDomain() method
type pSearchDomain struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchDomain) Extend(fnct func(m.UserSet, domains.Domain) m.CommonMixinSet) pSearchDomain {
	return pSearchDomain{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchDomain) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchDomain{}

// SearchDomain returns a pointer to the SearchDomain Method.
func (c MethodsCollection) SearchDomain() pSearchDomain {
	return pSearchDomain{
		Method: c.MustGet("SearchDomain"),
	}
}

// pSearchRead holds the metadata of the User.SearchRead() method
type pSearchRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSearchRead) Extend(fnct func(m.UserSet, webtypes.SearchParams) []models.RecordData) pSearchRead {
	return pSearchRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSearchRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSearchRead{}

// SearchRead returns a pointer to the SearchRead Method.
func (c MethodsCollection) SearchRead() pSearchRead {
	return pSearchRead{
		Method: c.MustGet("SearchRead"),
	}
}

// pSelfReadableFields holds the metadata of the User.SelfReadableFields() method
type pSelfReadableFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSelfReadableFields) Extend(fnct func(m.UserSet) map[string]bool) pSelfReadableFields {
	return pSelfReadableFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSelfReadableFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSelfReadableFields{}

// SelfReadableFields returns a pointer to the SelfReadableFields Method.
func (c MethodsCollection) SelfReadableFields() pSelfReadableFields {
	return pSelfReadableFields{
		Method: c.MustGet("SelfReadableFields"),
	}
}

// pSelfWritableFields holds the metadata of the User.SelfWritableFields() method
type pSelfWritableFields struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSelfWritableFields) Extend(fnct func(m.UserSet) map[string]bool) pSelfWritableFields {
	return pSelfWritableFields{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSelfWritableFields) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSelfWritableFields{}

// SelfWritableFields returns a pointer to the SelfWritableFields Method.
func (c MethodsCollection) SelfWritableFields() pSelfWritableFields {
	return pSelfWritableFields{
		Method: c.MustGet("SelfWritableFields"),
	}
}

// pSorted holds the metadata of the User.Sorted() method
type pSorted struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSorted) Extend(fnct func(m.UserSet, func(m.UserSet, m.UserSet) bool) m.UserSet) pSorted {
	return pSorted{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSorted) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSorted{}

// Sorted returns a pointer to the Sorted Method.
func (c MethodsCollection) Sorted() pSorted {
	return pSorted{
		Method: c.MustGet("Sorted"),
	}
}

// pSortedByField holds the metadata of the User.SortedByField() method
type pSortedByField struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSortedByField) Extend(fnct func(m.UserSet, models.FieldName, bool) m.UserSet) pSortedByField {
	return pSortedByField{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSortedByField) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSortedByField{}

// SortedByField returns a pointer to the SortedByField Method.
func (c MethodsCollection) SortedByField() pSortedByField {
	return pSortedByField{
		Method: c.MustGet("SortedByField"),
	}
}

// pSortedDefault holds the metadata of the User.SortedDefault() method
type pSortedDefault struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSortedDefault) Extend(fnct func(m.UserSet) m.UserSet) pSortedDefault {
	return pSortedDefault{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSortedDefault) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSortedDefault{}

// SortedDefault returns a pointer to the SortedDefault Method.
func (c MethodsCollection) SortedDefault() pSortedDefault {
	return pSortedDefault{
		Method: c.MustGet("SortedDefault"),
	}
}

// pSubtract holds the metadata of the User.Subtract() method
type pSubtract struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSubtract) Extend(fnct func(m.UserSet, m.UserSet) m.UserSet) pSubtract {
	return pSubtract{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSubtract) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSubtract{}

// Subtract returns a pointer to the Subtract Method.
func (c MethodsCollection) Subtract() pSubtract {
	return pSubtract{
		Method: c.MustGet("Subtract"),
	}
}

// pSudo holds the metadata of the User.Sudo() method
type pSudo struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSudo) Extend(fnct func(m.UserSet, ...int64) m.UserSet) pSudo {
	return pSudo{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSudo) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSudo{}

// Sudo returns a pointer to the Sudo Method.
func (c MethodsCollection) Sudo() pSudo {
	return pSudo{
		Method: c.MustGet("Sudo"),
	}
}

// pSyncMemberships holds the metadata of the User.SyncMemberships() method
type pSyncMemberships struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pSyncMemberships) Extend(fnct func(m.UserSet)) pSyncMemberships {
	return pSyncMemberships{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pSyncMemberships) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pSyncMemberships{}

// SyncMemberships returns a pointer to the SyncMemberships Method.
func (c MethodsCollection) SyncMemberships() pSyncMemberships {
	return pSyncMemberships{
		Method: c.MustGet("SyncMemberships"),
	}
}

// pToggleActive holds the metadata of the User.ToggleActive() method
type pToggleActive struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pToggleActive) Extend(fnct func(m.UserSet)) pToggleActive {
	return pToggleActive{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pToggleActive) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pToggleActive{}

// ToggleActive returns a pointer to the ToggleActive Method.
func (c MethodsCollection) ToggleActive() pToggleActive {
	return pToggleActive{
		Method: c.MustGet("ToggleActive"),
	}
}

// pUnion holds the metadata of the User.Union() method
type pUnion struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pUnion) Extend(fnct func(m.UserSet, m.UserSet) m.UserSet) pUnion {
	return pUnion{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pUnion) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pUnion{}

// Union returns a pointer to the Union Method.
func (c MethodsCollection) Union() pUnion {
	return pUnion{
		Method: c.MustGet("Union"),
	}
}

// pUnlink holds the metadata of the User.Unlink() method
type pUnlink struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pUnlink) Extend(fnct func(m.UserSet) int64) pUnlink {
	return pUnlink{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pUnlink) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pUnlink{}

// Unlink returns a pointer to the Unlink Method.
func (c MethodsCollection) Unlink() pUnlink {
	return pUnlink{
		Method: c.MustGet("Unlink"),
	}
}

// pUpdateLastLogin holds the metadata of the User.UpdateLastLogin() method
type pUpdateLastLogin struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pUpdateLastLogin) Extend(fnct func(m.UserSet)) pUpdateLastLogin {
	return pUpdateLastLogin{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pUpdateLastLogin) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pUpdateLastLogin{}

// UpdateLastLogin returns a pointer to the UpdateLastLogin Method.
func (c MethodsCollection) UpdateLastLogin() pUpdateLastLogin {
	return pUpdateLastLogin{
		Method: c.MustGet("UpdateLastLogin"),
	}
}

// pVerifyPassword holds the metadata of the User.VerifyPassword() method
type pVerifyPassword struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pVerifyPassword) Extend(fnct func(m.UserSet, string, string) bool) pVerifyPassword {
	return pVerifyPassword{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pVerifyPassword) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pVerifyPassword{}

// VerifyPassword returns a pointer to the VerifyPassword Method.
func (c MethodsCollection) VerifyPassword() pVerifyPassword {
	return pVerifyPassword{
		Method: c.MustGet("VerifyPassword"),
	}
}

// pWebReadGroup holds the metadata of the User.WebReadGroup() method
type pWebReadGroup struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWebReadGroup) Extend(fnct func(m.UserSet, webtypes.WebReadGroupParams) webtypes.WebReadGroupResult) pWebReadGroup {
	return pWebReadGroup{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWebReadGroup) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWebReadGroup{}

// WebReadGroup returns a pointer to the WebReadGroup Method.
func (c MethodsCollection) WebReadGroup() pWebReadGroup {
	return pWebReadGroup{
		Method: c.MustGet("WebReadGroup"),
	}
}

// pWebReadGroupPrivate holds the metadata of the User.WebReadGroupPrivate() method
type pWebReadGroupPrivate struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWebReadGroupPrivate) Extend(fnct func(m.UserSet, webtypes.WebReadGroupParams) []models.FieldMap) pWebReadGroupPrivate {
	return pWebReadGroupPrivate{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWebReadGroupPrivate) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWebReadGroupPrivate{}

// WebReadGroupPrivate returns a pointer to the WebReadGroupPrivate Method.
func (c MethodsCollection) WebReadGroupPrivate() pWebReadGroupPrivate {
	return pWebReadGroupPrivate{
		Method: c.MustGet("WebReadGroupPrivate"),
	}
}

// pWebSearchRead holds the metadata of the User.WebSearchRead() method
type pWebSearchRead struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWebSearchRead) Extend(fnct func(m.UserSet, webtypes.SearchParams) webtypes.SearchReadResult) pWebSearchRead {
	return pWebSearchRead{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWebSearchRead) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWebSearchRead{}

// WebSearchRead returns a pointer to the WebSearchRead Method.
func (c MethodsCollection) WebSearchRead() pWebSearchRead {
	return pWebSearchRead{
		Method: c.MustGet("WebSearchRead"),
	}
}

// pWithContext holds the metadata of the User.WithContext() method
type pWithContext struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWithContext) Extend(fnct func(m.UserSet, string, interface{}) m.UserSet) pWithContext {
	return pWithContext{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWithContext) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWithContext{}

// WithContext returns a pointer to the WithContext Method.
func (c MethodsCollection) WithContext() pWithContext {
	return pWithContext{
		Method: c.MustGet("WithContext"),
	}
}

// pWithEnv holds the metadata of the User.WithEnv() method
type pWithEnv struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWithEnv) Extend(fnct func(m.UserSet, models.Environment) m.UserSet) pWithEnv {
	return pWithEnv{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWithEnv) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWithEnv{}

// WithEnv returns a pointer to the WithEnv Method.
func (c MethodsCollection) WithEnv() pWithEnv {
	return pWithEnv{
		Method: c.MustGet("WithEnv"),
	}
}

// pWithNewContext holds the metadata of the User.WithNewContext() method
type pWithNewContext struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWithNewContext) Extend(fnct func(m.UserSet, *types.Context) m.UserSet) pWithNewContext {
	return pWithNewContext{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWithNewContext) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWithNewContext{}

// WithNewContext returns a pointer to the WithNewContext Method.
func (c MethodsCollection) WithNewContext() pWithNewContext {
	return pWithNewContext{
		Method: c.MustGet("WithNewContext"),
	}
}

// pWrite holds the metadata of the User.Write() method
type pWrite struct {
	*models.Method
}

// Extend adds the given fnct function as a new layer on this method.
func (m pWrite) Extend(fnct func(m.UserSet, m.UserData) bool) pWrite {
	return pWrite{
		Method: m.Method.Extend(fnct),
	}
}

// Underlying returns a pointer to the underlying Method data object.
func (m pWrite) Underlying() *models.Method {
	return m.Method
}

var _ models.Methoder = pWrite{}

// Write returns a pointer to the Write Method.
func (c MethodsCollection) Write() pWrite {
	return pWrite{
		Method: c.MustGet("Write"),
	}
}

// ------- DATA STRUCT ---------

// UserData is used to hold values of an User object instance
// when creating or updating a UserSet.
type UserData struct {
	*models.ModelData
}

// Set sets the given field with the given value.
// If the field already exists, then it is updated with value.
// Otherwise, a new entry is inserted.
//
// It returns the given UserData so that calls can be chained
func (d UserData) Set(field models.FieldName, value interface{}) m.UserData {
	return &UserData{
		d.ModelData.Set(field, value),
	}
}

// Unset removes the value of the given field if it exists.
//
// It returns the given ModelData so that calls can be chained
func (d UserData) Unset(field models.FieldName) m.UserData {
	return &UserData{
		d.ModelData.Unset(field),
	}
}

// Copy returns a copy of this UserData
func (d UserData) Copy() m.UserData {
	return &UserData{
		d.ModelData.Copy(),
	}
}

// MergeWith updates this UserData with the given other UserData
// If a field of the other UserData already exists here, the value is overridden,
// otherwise, the field is inserted.
func (d UserData) MergeWith(other m.UserData) {
	d.ModelData.MergeWith(other.Underlying())
}

// ActionID returns the value of the ActionID field.
// If this ActionID is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ActionID() actions.ActionRef {
	val := d.ModelData.Get(models.NewFieldName("ActionID", "action_id"))
	if !d.Has(models.NewFieldName("ActionID", "action_id")) {
		return *new(actions.ActionRef)
	}
	return val.(actions.ActionRef)
}

// HasActionID returns true if ActionID is set in this UserData
func (d UserData) HasActionID() bool {
	return d.ModelData.Has(models.NewFieldName("ActionID", "action_id"))
}

// SetActionID sets the ActionID field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetActionID(value actions.ActionRef) m.UserData {
	d.ModelData.Set(models.NewFieldName("ActionID", "action_id"), value)
	return d
}

// UnsetActionID removes the value of the ActionID field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetActionID() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ActionID", "action_id"))
	return d
}

// Active returns the value of the Active field.
// If this Active is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Active() bool {
	val := d.ModelData.Get(models.NewFieldName("Active", "active"))
	if !d.Has(models.NewFieldName("Active", "active")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasActive returns true if Active is set in this UserData
func (d UserData) HasActive() bool {
	return d.ModelData.Has(models.NewFieldName("Active", "active"))
}

// SetActive sets the Active field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetActive(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("Active", "active"), value)
	return d
}

// UnsetActive removes the value of the Active field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetActive() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Active", "active"))
	return d
}

// ActiveLangCount returns the value of the ActiveLangCount field.
// If this ActiveLangCount is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ActiveLangCount() int {
	val := d.ModelData.Get(models.NewFieldName("ActiveLangCount", "active_lang_count"))
	if !d.Has(models.NewFieldName("ActiveLangCount", "active_lang_count")) {
		return *new(int)
	}
	return val.(int)
}

// HasActiveLangCount returns true if ActiveLangCount is set in this UserData
func (d UserData) HasActiveLangCount() bool {
	return d.ModelData.Has(models.NewFieldName("ActiveLangCount", "active_lang_count"))
}

// SetActiveLangCount sets the ActiveLangCount field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetActiveLangCount(value int) m.UserData {
	d.ModelData.Set(models.NewFieldName("ActiveLangCount", "active_lang_count"), value)
	return d
}

// UnsetActiveLangCount removes the value of the ActiveLangCount field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetActiveLangCount() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ActiveLangCount", "active_lang_count"))
	return d
}

// ActivePartner returns the value of the ActivePartner field.
// If this ActivePartner is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ActivePartner() bool {
	val := d.ModelData.Get(models.NewFieldName("ActivePartner", "active_partner"))
	if !d.Has(models.NewFieldName("ActivePartner", "active_partner")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasActivePartner returns true if ActivePartner is set in this UserData
func (d UserData) HasActivePartner() bool {
	return d.ModelData.Has(models.NewFieldName("ActivePartner", "active_partner"))
}

// SetActivePartner sets the ActivePartner field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetActivePartner(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("ActivePartner", "active_partner"), value)
	return d
}

// UnsetActivePartner removes the value of the ActivePartner field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetActivePartner() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ActivePartner", "active_partner"))
	return d
}

// Banks returns the value of the Banks field.
// If this Banks is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Banks() m.BankAccountSet {
	val := d.ModelData.Get(models.NewFieldName("Banks", "banks_ids"))
	if !d.Has(models.NewFieldName("Banks", "banks_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("BankAccount")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.BankAccountSet)
}

// HasBanks returns true if Banks is set in this UserData
func (d UserData) HasBanks() bool {
	return d.ModelData.Has(models.NewFieldName("Banks", "banks_ids"))
}

// SetBanks sets the Banks field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetBanks(value m.BankAccountSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Banks", "banks_ids"), value)
	return d
}

// UnsetBanks removes the value of the Banks field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetBanks() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Banks", "banks_ids"))
	return d
}

// CreateBanks stores the related BankAccountData to be used to create
// a related record on the fly for Banks.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateBanks(related m.BankAccountData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Banks", "banks_ids"), related.Underlying())
	return d
}

// Barcode returns the value of the Barcode field.
// If this Barcode is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Barcode() string {
	val := d.ModelData.Get(models.NewFieldName("Barcode", "barcode"))
	if !d.Has(models.NewFieldName("Barcode", "barcode")) {
		return *new(string)
	}
	return val.(string)
}

// HasBarcode returns true if Barcode is set in this UserData
func (d UserData) HasBarcode() bool {
	return d.ModelData.Has(models.NewFieldName("Barcode", "barcode"))
}

// SetBarcode sets the Barcode field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetBarcode(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Barcode", "barcode"), value)
	return d
}

// UnsetBarcode removes the value of the Barcode field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetBarcode() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Barcode", "barcode"))
	return d
}

// Categories returns the value of the Categories field.
// If this Categories is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Categories() m.PartnerCategorySet {
	val := d.ModelData.Get(models.NewFieldName("Categories", "category_ids"))
	if !d.Has(models.NewFieldName("Categories", "category_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("PartnerCategory")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerCategorySet)
}

// HasCategories returns true if Categories is set in this UserData
func (d UserData) HasCategories() bool {
	return d.ModelData.Has(models.NewFieldName("Categories", "category_ids"))
}

// SetCategories sets the Categories field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCategories(value m.PartnerCategorySet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Categories", "category_ids"), value)
	return d
}

// UnsetCategories removes the value of the Categories field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCategories() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Categories", "category_ids"))
	return d
}

// CreateCategories stores the related PartnerCategoryData to be used to create
// a related record on the fly for Categories.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateCategories(related m.PartnerCategoryData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Categories", "category_ids"), related.Underlying())
	return d
}

// ChatterPosition returns the value of the ChatterPosition field.
// If this ChatterPosition is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ChatterPosition() string {
	val := d.ModelData.Get(models.NewFieldName("ChatterPosition", "chatter_position"))
	if !d.Has(models.NewFieldName("ChatterPosition", "chatter_position")) {
		return *new(string)
	}
	return val.(string)
}

// HasChatterPosition returns true if ChatterPosition is set in this UserData
func (d UserData) HasChatterPosition() bool {
	return d.ModelData.Has(models.NewFieldName("ChatterPosition", "chatter_position"))
}

// SetChatterPosition sets the ChatterPosition field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetChatterPosition(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("ChatterPosition", "chatter_position"), value)
	return d
}

// UnsetChatterPosition removes the value of the ChatterPosition field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetChatterPosition() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ChatterPosition", "chatter_position"))
	return d
}

// Children returns the value of the Children field.
// If this Children is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Children() m.PartnerSet {
	val := d.ModelData.Get(models.NewFieldName("Children", "children_ids"))
	if !d.Has(models.NewFieldName("Children", "children_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Partner")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerSet)
}

// HasChildren returns true if Children is set in this UserData
func (d UserData) HasChildren() bool {
	return d.ModelData.Has(models.NewFieldName("Children", "children_ids"))
}

// SetChildren sets the Children field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetChildren(value m.PartnerSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Children", "children_ids"), value)
	return d
}

// UnsetChildren removes the value of the Children field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetChildren() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Children", "children_ids"))
	return d
}

// CreateChildren stores the related PartnerData to be used to create
// a related record on the fly for Children.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateChildren(related m.PartnerData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Children", "children_ids"), related.Underlying())
	return d
}

// City returns the value of the City field.
// If this City is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) City() string {
	val := d.ModelData.Get(models.NewFieldName("City", "city"))
	if !d.Has(models.NewFieldName("City", "city")) {
		return *new(string)
	}
	return val.(string)
}

// HasCity returns true if City is set in this UserData
func (d UserData) HasCity() bool {
	return d.ModelData.Has(models.NewFieldName("City", "city"))
}

// SetCity sets the City field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCity(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("City", "city"), value)
	return d
}

// UnsetCity removes the value of the City field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCity() m.UserData {
	d.ModelData.Unset(models.NewFieldName("City", "city"))
	return d
}

// Color returns the value of the Color field.
// If this Color is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Color() int64 {
	val := d.ModelData.Get(models.NewFieldName("Color", "color"))
	if !d.Has(models.NewFieldName("Color", "color")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasColor returns true if Color is set in this UserData
func (d UserData) HasColor() bool {
	return d.ModelData.Has(models.NewFieldName("Color", "color"))
}

// SetColor sets the Color field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetColor(value int64) m.UserData {
	d.ModelData.Set(models.NewFieldName("Color", "color"), value)
	return d
}

// UnsetColor removes the value of the Color field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetColor() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Color", "color"))
	return d
}

// Comment returns the value of the Comment field.
// If this Comment is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Comment() string {
	val := d.ModelData.Get(models.NewFieldName("Comment", "comment"))
	if !d.Has(models.NewFieldName("Comment", "comment")) {
		return *new(string)
	}
	return val.(string)
}

// HasComment returns true if Comment is set in this UserData
func (d UserData) HasComment() bool {
	return d.ModelData.Has(models.NewFieldName("Comment", "comment"))
}

// SetComment sets the Comment field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetComment(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Comment", "comment"), value)
	return d
}

// UnsetComment removes the value of the Comment field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetComment() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Comment", "comment"))
	return d
}

// CommercialCompanyName returns the value of the CommercialCompanyName field.
// If this CommercialCompanyName is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CommercialCompanyName() string {
	val := d.ModelData.Get(models.NewFieldName("CommercialCompanyName", "commercial_company_name"))
	if !d.Has(models.NewFieldName("CommercialCompanyName", "commercial_company_name")) {
		return *new(string)
	}
	return val.(string)
}

// HasCommercialCompanyName returns true if CommercialCompanyName is set in this UserData
func (d UserData) HasCommercialCompanyName() bool {
	return d.ModelData.Has(models.NewFieldName("CommercialCompanyName", "commercial_company_name"))
}

// SetCommercialCompanyName sets the CommercialCompanyName field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCommercialCompanyName(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("CommercialCompanyName", "commercial_company_name"), value)
	return d
}

// UnsetCommercialCompanyName removes the value of the CommercialCompanyName field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCommercialCompanyName() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CommercialCompanyName", "commercial_company_name"))
	return d
}

// CommercialPartner returns the value of the CommercialPartner field.
// If this CommercialPartner is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CommercialPartner() m.PartnerSet {
	val := d.ModelData.Get(models.NewFieldName("CommercialPartner", "commercial_partner_id"))
	if !d.Has(models.NewFieldName("CommercialPartner", "commercial_partner_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Partner")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerSet)
}

// HasCommercialPartner returns true if CommercialPartner is set in this UserData
func (d UserData) HasCommercialPartner() bool {
	return d.ModelData.Has(models.NewFieldName("CommercialPartner", "commercial_partner_id"))
}

// SetCommercialPartner sets the CommercialPartner field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCommercialPartner(value m.PartnerSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("CommercialPartner", "commercial_partner_id"), value)
	return d
}

// UnsetCommercialPartner removes the value of the CommercialPartner field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCommercialPartner() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CommercialPartner", "commercial_partner_id"))
	return d
}

// CreateCommercialPartner stores the related PartnerData to be used to create
// a related record on the fly for CommercialPartner.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateCommercialPartner(related m.PartnerData) m.UserData {
	d.ModelData.Create(models.NewFieldName("CommercialPartner", "commercial_partner_id"), related.Underlying())
	return d
}

// Companies returns the value of the Companies field.
// If this Companies is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Companies() m.CompanySet {
	val := d.ModelData.Get(models.NewFieldName("Companies", "company_ids"))
	if !d.Has(models.NewFieldName("Companies", "company_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Company")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.CompanySet)
}

// HasCompanies returns true if Companies is set in this UserData
func (d UserData) HasCompanies() bool {
	return d.ModelData.Has(models.NewFieldName("Companies", "company_ids"))
}

// SetCompanies sets the Companies field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCompanies(value m.CompanySet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Companies", "company_ids"), value)
	return d
}

// UnsetCompanies removes the value of the Companies field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCompanies() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Companies", "company_ids"))
	return d
}

// CreateCompanies stores the related CompanyData to be used to create
// a related record on the fly for Companies.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateCompanies(related m.CompanyData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Companies", "company_ids"), related.Underlying())
	return d
}

// CompaniesCount returns the value of the CompaniesCount field.
// If this CompaniesCount is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CompaniesCount() int {
	val := d.ModelData.Get(models.NewFieldName("CompaniesCount", "companies_count"))
	if !d.Has(models.NewFieldName("CompaniesCount", "companies_count")) {
		return *new(int)
	}
	return val.(int)
}

// HasCompaniesCount returns true if CompaniesCount is set in this UserData
func (d UserData) HasCompaniesCount() bool {
	return d.ModelData.Has(models.NewFieldName("CompaniesCount", "companies_count"))
}

// SetCompaniesCount sets the CompaniesCount field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCompaniesCount(value int) m.UserData {
	d.ModelData.Set(models.NewFieldName("CompaniesCount", "companies_count"), value)
	return d
}

// UnsetCompaniesCount removes the value of the CompaniesCount field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCompaniesCount() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CompaniesCount", "companies_count"))
	return d
}

// Company returns the value of the Company field.
// If this Company is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Company() m.CompanySet {
	val := d.ModelData.Get(models.NewFieldName("Company", "company_id"))
	if !d.Has(models.NewFieldName("Company", "company_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Company")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.CompanySet)
}

// HasCompany returns true if Company is set in this UserData
func (d UserData) HasCompany() bool {
	return d.ModelData.Has(models.NewFieldName("Company", "company_id"))
}

// SetCompany sets the Company field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCompany(value m.CompanySet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Company", "company_id"), value)
	return d
}

// UnsetCompany removes the value of the Company field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCompany() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Company", "company_id"))
	return d
}

// CreateCompany stores the related CompanyData to be used to create
// a related record on the fly for Company.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateCompany(related m.CompanyData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Company", "company_id"), related.Underlying())
	return d
}

// CompanyName returns the value of the CompanyName field.
// If this CompanyName is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CompanyName() string {
	val := d.ModelData.Get(models.NewFieldName("CompanyName", "company_name"))
	if !d.Has(models.NewFieldName("CompanyName", "company_name")) {
		return *new(string)
	}
	return val.(string)
}

// HasCompanyName returns true if CompanyName is set in this UserData
func (d UserData) HasCompanyName() bool {
	return d.ModelData.Has(models.NewFieldName("CompanyName", "company_name"))
}

// SetCompanyName sets the CompanyName field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCompanyName(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("CompanyName", "company_name"), value)
	return d
}

// UnsetCompanyName removes the value of the CompanyName field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCompanyName() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CompanyName", "company_name"))
	return d
}

// CompanyType returns the value of the CompanyType field.
// If this CompanyType is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CompanyType() string {
	val := d.ModelData.Get(models.NewFieldName("CompanyType", "company_type"))
	if !d.Has(models.NewFieldName("CompanyType", "company_type")) {
		return *new(string)
	}
	return val.(string)
}

// HasCompanyType returns true if CompanyType is set in this UserData
func (d UserData) HasCompanyType() bool {
	return d.ModelData.Has(models.NewFieldName("CompanyType", "company_type"))
}

// SetCompanyType sets the CompanyType field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCompanyType(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("CompanyType", "company_type"), value)
	return d
}

// UnsetCompanyType removes the value of the CompanyType field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCompanyType() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CompanyType", "company_type"))
	return d
}

// ContactAddress returns the value of the ContactAddress field.
// If this ContactAddress is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ContactAddress() string {
	val := d.ModelData.Get(models.NewFieldName("ContactAddress", "contact_address"))
	if !d.Has(models.NewFieldName("ContactAddress", "contact_address")) {
		return *new(string)
	}
	return val.(string)
}

// HasContactAddress returns true if ContactAddress is set in this UserData
func (d UserData) HasContactAddress() bool {
	return d.ModelData.Has(models.NewFieldName("ContactAddress", "contact_address"))
}

// SetContactAddress sets the ContactAddress field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetContactAddress(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("ContactAddress", "contact_address"), value)
	return d
}

// UnsetContactAddress removes the value of the ContactAddress field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetContactAddress() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ContactAddress", "contact_address"))
	return d
}

// Country returns the value of the Country field.
// If this Country is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Country() m.CountrySet {
	val := d.ModelData.Get(models.NewFieldName("Country", "country_id"))
	if !d.Has(models.NewFieldName("Country", "country_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Country")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.CountrySet)
}

// HasCountry returns true if Country is set in this UserData
func (d UserData) HasCountry() bool {
	return d.ModelData.Has(models.NewFieldName("Country", "country_id"))
}

// SetCountry sets the Country field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCountry(value m.CountrySet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Country", "country_id"), value)
	return d
}

// UnsetCountry removes the value of the Country field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCountry() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Country", "country_id"))
	return d
}

// CreateCountry stores the related CountryData to be used to create
// a related record on the fly for Country.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateCountry(related m.CountryData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Country", "country_id"), related.Underlying())
	return d
}

// CreateDate returns the value of the CreateDate field.
// If this CreateDate is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CreateDate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("CreateDate", "create_date"))
	if !d.Has(models.NewFieldName("CreateDate", "create_date")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasCreateDate returns true if CreateDate is set in this UserData
func (d UserData) HasCreateDate() bool {
	return d.ModelData.Has(models.NewFieldName("CreateDate", "create_date"))
}

// SetCreateDate sets the CreateDate field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCreateDate(value dates.DateTime) m.UserData {
	d.ModelData.Set(models.NewFieldName("CreateDate", "create_date"), value)
	return d
}

// UnsetCreateDate removes the value of the CreateDate field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCreateDate() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CreateDate", "create_date"))
	return d
}

// CreateUID returns the value of the CreateUID field.
// If this CreateUID is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CreateUID() int64 {
	val := d.ModelData.Get(models.NewFieldName("CreateUID", "create_uid"))
	if !d.Has(models.NewFieldName("CreateUID", "create_uid")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasCreateUID returns true if CreateUID is set in this UserData
func (d UserData) HasCreateUID() bool {
	return d.ModelData.Has(models.NewFieldName("CreateUID", "create_uid"))
}

// SetCreateUID sets the CreateUID field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCreateUID(value int64) m.UserData {
	d.ModelData.Set(models.NewFieldName("CreateUID", "create_uid"), value)
	return d
}

// UnsetCreateUID removes the value of the CreateUID field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCreateUID() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CreateUID", "create_uid"))
	return d
}

// CreditLimit returns the value of the CreditLimit field.
// If this CreditLimit is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) CreditLimit() float64 {
	val := d.ModelData.Get(models.NewFieldName("CreditLimit", "credit_limit"))
	if !d.Has(models.NewFieldName("CreditLimit", "credit_limit")) {
		return *new(float64)
	}
	return val.(float64)
}

// HasCreditLimit returns true if CreditLimit is set in this UserData
func (d UserData) HasCreditLimit() bool {
	return d.ModelData.Has(models.NewFieldName("CreditLimit", "credit_limit"))
}

// SetCreditLimit sets the CreditLimit field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetCreditLimit(value float64) m.UserData {
	d.ModelData.Set(models.NewFieldName("CreditLimit", "credit_limit"), value)
	return d
}

// UnsetCreditLimit removes the value of the CreditLimit field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetCreditLimit() m.UserData {
	d.ModelData.Unset(models.NewFieldName("CreditLimit", "credit_limit"))
	return d
}

// Date returns the value of the Date field.
// If this Date is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Date() dates.Date {
	val := d.ModelData.Get(models.NewFieldName("Date", "date"))
	if !d.Has(models.NewFieldName("Date", "date")) {
		return *new(dates.Date)
	}
	return val.(dates.Date)
}

// HasDate returns true if Date is set in this UserData
func (d UserData) HasDate() bool {
	return d.ModelData.Has(models.NewFieldName("Date", "date"))
}

// SetDate sets the Date field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetDate(value dates.Date) m.UserData {
	d.ModelData.Set(models.NewFieldName("Date", "date"), value)
	return d
}

// UnsetDate removes the value of the Date field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetDate() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Date", "date"))
	return d
}

// DisplayName returns the value of the DisplayName field.
// If this DisplayName is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) DisplayName() string {
	val := d.ModelData.Get(models.NewFieldName("DisplayName", "display_name"))
	if !d.Has(models.NewFieldName("DisplayName", "display_name")) {
		return *new(string)
	}
	return val.(string)
}

// HasDisplayName returns true if DisplayName is set in this UserData
func (d UserData) HasDisplayName() bool {
	return d.ModelData.Has(models.NewFieldName("DisplayName", "display_name"))
}

// SetDisplayName sets the DisplayName field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetDisplayName(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("DisplayName", "display_name"), value)
	return d
}

// UnsetDisplayName removes the value of the DisplayName field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetDisplayName() m.UserData {
	d.ModelData.Unset(models.NewFieldName("DisplayName", "display_name"))
	return d
}

// Email returns the value of the Email field.
// If this Email is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Email() string {
	val := d.ModelData.Get(models.NewFieldName("Email", "email"))
	if !d.Has(models.NewFieldName("Email", "email")) {
		return *new(string)
	}
	return val.(string)
}

// HasEmail returns true if Email is set in this UserData
func (d UserData) HasEmail() bool {
	return d.ModelData.Has(models.NewFieldName("Email", "email"))
}

// SetEmail sets the Email field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetEmail(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Email", "email"), value)
	return d
}

// UnsetEmail removes the value of the Email field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetEmail() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Email", "email"))
	return d
}

// EmailFormatted returns the value of the EmailFormatted field.
// If this EmailFormatted is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) EmailFormatted() string {
	val := d.ModelData.Get(models.NewFieldName("EmailFormatted", "email_formatted"))
	if !d.Has(models.NewFieldName("EmailFormatted", "email_formatted")) {
		return *new(string)
	}
	return val.(string)
}

// HasEmailFormatted returns true if EmailFormatted is set in this UserData
func (d UserData) HasEmailFormatted() bool {
	return d.ModelData.Has(models.NewFieldName("EmailFormatted", "email_formatted"))
}

// SetEmailFormatted sets the EmailFormatted field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetEmailFormatted(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("EmailFormatted", "email_formatted"), value)
	return d
}

// UnsetEmailFormatted removes the value of the EmailFormatted field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetEmailFormatted() m.UserData {
	d.ModelData.Unset(models.NewFieldName("EmailFormatted", "email_formatted"))
	return d
}

// Employee returns the value of the Employee field.
// If this Employee is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Employee() bool {
	val := d.ModelData.Get(models.NewFieldName("Employee", "employee"))
	if !d.Has(models.NewFieldName("Employee", "employee")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasEmployee returns true if Employee is set in this UserData
func (d UserData) HasEmployee() bool {
	return d.ModelData.Has(models.NewFieldName("Employee", "employee"))
}

// SetEmployee sets the Employee field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetEmployee(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("Employee", "employee"), value)
	return d
}

// UnsetEmployee removes the value of the Employee field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetEmployee() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Employee", "employee"))
	return d
}

// Function returns the value of the Function field.
// If this Function is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Function() string {
	val := d.ModelData.Get(models.NewFieldName("Function", "function"))
	if !d.Has(models.NewFieldName("Function", "function")) {
		return *new(string)
	}
	return val.(string)
}

// HasFunction returns true if Function is set in this UserData
func (d UserData) HasFunction() bool {
	return d.ModelData.Has(models.NewFieldName("Function", "function"))
}

// SetFunction sets the Function field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetFunction(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Function", "function"), value)
	return d
}

// UnsetFunction removes the value of the Function field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetFunction() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Function", "function"))
	return d
}

// Groups returns the value of the Groups field.
// If this Groups is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Groups() m.GroupSet {
	val := d.ModelData.Get(models.NewFieldName("Groups", "group_ids"))
	if !d.Has(models.NewFieldName("Groups", "group_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Group")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.GroupSet)
}

// HasGroups returns true if Groups is set in this UserData
func (d UserData) HasGroups() bool {
	return d.ModelData.Has(models.NewFieldName("Groups", "group_ids"))
}

// SetGroups sets the Groups field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetGroups(value m.GroupSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Groups", "group_ids"), value)
	return d
}

// UnsetGroups removes the value of the Groups field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetGroups() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Groups", "group_ids"))
	return d
}

// CreateGroups stores the related GroupData to be used to create
// a related record on the fly for Groups.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateGroups(related m.GroupData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Groups", "group_ids"), related.Underlying())
	return d
}

// GroupsCount returns the value of the GroupsCount field.
// If this GroupsCount is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) GroupsCount() int {
	val := d.ModelData.Get(models.NewFieldName("GroupsCount", "groups_count"))
	if !d.Has(models.NewFieldName("GroupsCount", "groups_count")) {
		return *new(int)
	}
	return val.(int)
}

// HasGroupsCount returns true if GroupsCount is set in this UserData
func (d UserData) HasGroupsCount() bool {
	return d.ModelData.Has(models.NewFieldName("GroupsCount", "groups_count"))
}

// SetGroupsCount sets the GroupsCount field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetGroupsCount(value int) m.UserData {
	d.ModelData.Set(models.NewFieldName("GroupsCount", "groups_count"), value)
	return d
}

// UnsetGroupsCount removes the value of the GroupsCount field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetGroupsCount() m.UserData {
	d.ModelData.Unset(models.NewFieldName("GroupsCount", "groups_count"))
	return d
}

// HexyaExternalID returns the value of the HexyaExternalID field.
// If this HexyaExternalID is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) HexyaExternalID() string {
	val := d.ModelData.Get(models.NewFieldName("HexyaExternalID", "hexya_external_id"))
	if !d.Has(models.NewFieldName("HexyaExternalID", "hexya_external_id")) {
		return *new(string)
	}
	return val.(string)
}

// HasHexyaExternalID returns true if HexyaExternalID is set in this UserData
func (d UserData) HasHexyaExternalID() bool {
	return d.ModelData.Has(models.NewFieldName("HexyaExternalID", "hexya_external_id"))
}

// SetHexyaExternalID sets the HexyaExternalID field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetHexyaExternalID(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("HexyaExternalID", "hexya_external_id"), value)
	return d
}

// UnsetHexyaExternalID removes the value of the HexyaExternalID field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetHexyaExternalID() m.UserData {
	d.ModelData.Unset(models.NewFieldName("HexyaExternalID", "hexya_external_id"))
	return d
}

// HexyaVersion returns the value of the HexyaVersion field.
// If this HexyaVersion is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) HexyaVersion() int {
	val := d.ModelData.Get(models.NewFieldName("HexyaVersion", "hexya_version"))
	if !d.Has(models.NewFieldName("HexyaVersion", "hexya_version")) {
		return *new(int)
	}
	return val.(int)
}

// HasHexyaVersion returns true if HexyaVersion is set in this UserData
func (d UserData) HasHexyaVersion() bool {
	return d.ModelData.Has(models.NewFieldName("HexyaVersion", "hexya_version"))
}

// SetHexyaVersion sets the HexyaVersion field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetHexyaVersion(value int) m.UserData {
	d.ModelData.Set(models.NewFieldName("HexyaVersion", "hexya_version"), value)
	return d
}

// UnsetHexyaVersion removes the value of the HexyaVersion field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetHexyaVersion() m.UserData {
	d.ModelData.Unset(models.NewFieldName("HexyaVersion", "hexya_version"))
	return d
}

// ID returns the value of the ID field.
// If this ID is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ID() int64 {
	val := d.ModelData.Get(models.NewFieldName("ID", "id"))
	if !d.Has(models.NewFieldName("ID", "id")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasID returns true if ID is set in this UserData
func (d UserData) HasID() bool {
	return d.ModelData.Has(models.NewFieldName("ID", "id"))
}

// SetID sets the ID field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetID(value int64) m.UserData {
	d.ModelData.Set(models.NewFieldName("ID", "id"), value)
	return d
}

// UnsetID removes the value of the ID field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetID() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ID", "id"))
	return d
}

// Image returns the value of the Image field.
// If this Image is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Image() string {
	val := d.ModelData.Get(models.NewFieldName("Image", "image"))
	if !d.Has(models.NewFieldName("Image", "image")) {
		return *new(string)
	}
	return val.(string)
}

// HasImage returns true if Image is set in this UserData
func (d UserData) HasImage() bool {
	return d.ModelData.Has(models.NewFieldName("Image", "image"))
}

// SetImage sets the Image field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetImage(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Image", "image"), value)
	return d
}

// UnsetImage removes the value of the Image field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetImage() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Image", "image"))
	return d
}

// ImageMedium returns the value of the ImageMedium field.
// If this ImageMedium is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ImageMedium() string {
	val := d.ModelData.Get(models.NewFieldName("ImageMedium", "image_medium"))
	if !d.Has(models.NewFieldName("ImageMedium", "image_medium")) {
		return *new(string)
	}
	return val.(string)
}

// HasImageMedium returns true if ImageMedium is set in this UserData
func (d UserData) HasImageMedium() bool {
	return d.ModelData.Has(models.NewFieldName("ImageMedium", "image_medium"))
}

// SetImageMedium sets the ImageMedium field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetImageMedium(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("ImageMedium", "image_medium"), value)
	return d
}

// UnsetImageMedium removes the value of the ImageMedium field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetImageMedium() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ImageMedium", "image_medium"))
	return d
}

// ImageSmall returns the value of the ImageSmall field.
// If this ImageSmall is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ImageSmall() string {
	val := d.ModelData.Get(models.NewFieldName("ImageSmall", "image_small"))
	if !d.Has(models.NewFieldName("ImageSmall", "image_small")) {
		return *new(string)
	}
	return val.(string)
}

// HasImageSmall returns true if ImageSmall is set in this UserData
func (d UserData) HasImageSmall() bool {
	return d.ModelData.Has(models.NewFieldName("ImageSmall", "image_small"))
}

// SetImageSmall sets the ImageSmall field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetImageSmall(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("ImageSmall", "image_small"), value)
	return d
}

// UnsetImageSmall removes the value of the ImageSmall field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetImageSmall() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ImageSmall", "image_small"))
	return d
}

// Industry returns the value of the Industry field.
// If this Industry is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Industry() m.PartnerIndustrySet {
	val := d.ModelData.Get(models.NewFieldName("Industry", "industry_id"))
	if !d.Has(models.NewFieldName("Industry", "industry_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("PartnerIndustry")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerIndustrySet)
}

// HasIndustry returns true if Industry is set in this UserData
func (d UserData) HasIndustry() bool {
	return d.ModelData.Has(models.NewFieldName("Industry", "industry_id"))
}

// SetIndustry sets the Industry field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetIndustry(value m.PartnerIndustrySet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Industry", "industry_id"), value)
	return d
}

// UnsetIndustry removes the value of the Industry field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetIndustry() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Industry", "industry_id"))
	return d
}

// CreateIndustry stores the related PartnerIndustryData to be used to create
// a related record on the fly for Industry.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateIndustry(related m.PartnerIndustryData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Industry", "industry_id"), related.Underlying())
	return d
}

// IsCompany returns the value of the IsCompany field.
// If this IsCompany is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) IsCompany() bool {
	val := d.ModelData.Get(models.NewFieldName("IsCompany", "is_company"))
	if !d.Has(models.NewFieldName("IsCompany", "is_company")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasIsCompany returns true if IsCompany is set in this UserData
func (d UserData) HasIsCompany() bool {
	return d.ModelData.Has(models.NewFieldName("IsCompany", "is_company"))
}

// SetIsCompany sets the IsCompany field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetIsCompany(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("IsCompany", "is_company"), value)
	return d
}

// UnsetIsCompany removes the value of the IsCompany field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetIsCompany() m.UserData {
	d.ModelData.Unset(models.NewFieldName("IsCompany", "is_company"))
	return d
}

// Lang returns the value of the Lang field.
// If this Lang is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Lang() string {
	val := d.ModelData.Get(models.NewFieldName("Lang", "lang"))
	if !d.Has(models.NewFieldName("Lang", "lang")) {
		return *new(string)
	}
	return val.(string)
}

// HasLang returns true if Lang is set in this UserData
func (d UserData) HasLang() bool {
	return d.ModelData.Has(models.NewFieldName("Lang", "lang"))
}

// SetLang sets the Lang field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLang(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Lang", "lang"), value)
	return d
}

// UnsetLang removes the value of the Lang field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLang() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Lang", "lang"))
	return d
}

// LastUpdate returns the value of the LastUpdate field.
// If this LastUpdate is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) LastUpdate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("LastUpdate", "__last_update"))
	if !d.Has(models.NewFieldName("LastUpdate", "__last_update")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasLastUpdate returns true if LastUpdate is set in this UserData
func (d UserData) HasLastUpdate() bool {
	return d.ModelData.Has(models.NewFieldName("LastUpdate", "__last_update"))
}

// SetLastUpdate sets the LastUpdate field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLastUpdate(value dates.DateTime) m.UserData {
	d.ModelData.Set(models.NewFieldName("LastUpdate", "__last_update"), value)
	return d
}

// UnsetLastUpdate removes the value of the LastUpdate field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLastUpdate() m.UserData {
	d.ModelData.Unset(models.NewFieldName("LastUpdate", "__last_update"))
	return d
}

// Latitude returns the value of the Latitude field.
// If this Latitude is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Latitude() float64 {
	val := d.ModelData.Get(models.NewFieldName("Latitude", "latitude"))
	if !d.Has(models.NewFieldName("Latitude", "latitude")) {
		return *new(float64)
	}
	return val.(float64)
}

// HasLatitude returns true if Latitude is set in this UserData
func (d UserData) HasLatitude() bool {
	return d.ModelData.Has(models.NewFieldName("Latitude", "latitude"))
}

// SetLatitude sets the Latitude field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLatitude(value float64) m.UserData {
	d.ModelData.Set(models.NewFieldName("Latitude", "latitude"), value)
	return d
}

// UnsetLatitude removes the value of the Latitude field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLatitude() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Latitude", "latitude"))
	return d
}

// Login returns the value of the Login field.
// If this Login is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Login() string {
	val := d.ModelData.Get(models.NewFieldName("Login", "login"))
	if !d.Has(models.NewFieldName("Login", "login")) {
		return *new(string)
	}
	return val.(string)
}

// HasLogin returns true if Login is set in this UserData
func (d UserData) HasLogin() bool {
	return d.ModelData.Has(models.NewFieldName("Login", "login"))
}

// SetLogin sets the Login field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLogin(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Login", "login"), value)
	return d
}

// UnsetLogin removes the value of the Login field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLogin() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Login", "login"))
	return d
}

// LoginDate returns the value of the LoginDate field.
// If this LoginDate is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) LoginDate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("LoginDate", "login_date"))
	if !d.Has(models.NewFieldName("LoginDate", "login_date")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasLoginDate returns true if LoginDate is set in this UserData
func (d UserData) HasLoginDate() bool {
	return d.ModelData.Has(models.NewFieldName("LoginDate", "login_date"))
}

// SetLoginDate sets the LoginDate field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLoginDate(value dates.DateTime) m.UserData {
	d.ModelData.Set(models.NewFieldName("LoginDate", "login_date"), value)
	return d
}

// UnsetLoginDate removes the value of the LoginDate field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLoginDate() m.UserData {
	d.ModelData.Unset(models.NewFieldName("LoginDate", "login_date"))
	return d
}

// Logs returns the value of the Logs field.
// If this Logs is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Logs() m.UserLogSet {
	val := d.ModelData.Get(models.NewFieldName("Logs", "log_ids"))
	if !d.Has(models.NewFieldName("Logs", "log_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("UserLog")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.UserLogSet)
}

// HasLogs returns true if Logs is set in this UserData
func (d UserData) HasLogs() bool {
	return d.ModelData.Has(models.NewFieldName("Logs", "log_ids"))
}

// SetLogs sets the Logs field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLogs(value m.UserLogSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Logs", "log_ids"), value)
	return d
}

// UnsetLogs removes the value of the Logs field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLogs() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Logs", "log_ids"))
	return d
}

// CreateLogs stores the related UserLogData to be used to create
// a related record on the fly for Logs.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateLogs(related m.UserLogData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Logs", "log_ids"), related.Underlying())
	return d
}

// Longitude returns the value of the Longitude field.
// If this Longitude is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Longitude() float64 {
	val := d.ModelData.Get(models.NewFieldName("Longitude", "longitude"))
	if !d.Has(models.NewFieldName("Longitude", "longitude")) {
		return *new(float64)
	}
	return val.(float64)
}

// HasLongitude returns true if Longitude is set in this UserData
func (d UserData) HasLongitude() bool {
	return d.ModelData.Has(models.NewFieldName("Longitude", "longitude"))
}

// SetLongitude sets the Longitude field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetLongitude(value float64) m.UserData {
	d.ModelData.Set(models.NewFieldName("Longitude", "longitude"), value)
	return d
}

// UnsetLongitude removes the value of the Longitude field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetLongitude() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Longitude", "longitude"))
	return d
}

// Mobile returns the value of the Mobile field.
// If this Mobile is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Mobile() string {
	val := d.ModelData.Get(models.NewFieldName("Mobile", "mobile"))
	if !d.Has(models.NewFieldName("Mobile", "mobile")) {
		return *new(string)
	}
	return val.(string)
}

// HasMobile returns true if Mobile is set in this UserData
func (d UserData) HasMobile() bool {
	return d.ModelData.Has(models.NewFieldName("Mobile", "mobile"))
}

// SetMobile sets the Mobile field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetMobile(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Mobile", "mobile"), value)
	return d
}

// UnsetMobile removes the value of the Mobile field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetMobile() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Mobile", "mobile"))
	return d
}

// Name returns the value of the Name field.
// If this Name is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Name() string {
	val := d.ModelData.Get(models.NewFieldName("Name", "name"))
	if !d.Has(models.NewFieldName("Name", "name")) {
		return *new(string)
	}
	return val.(string)
}

// HasName returns true if Name is set in this UserData
func (d UserData) HasName() bool {
	return d.ModelData.Has(models.NewFieldName("Name", "name"))
}

// SetName sets the Name field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetName(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Name", "name"), value)
	return d
}

// UnsetName removes the value of the Name field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetName() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Name", "name"))
	return d
}

// NewPassword returns the value of the NewPassword field.
// If this NewPassword is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) NewPassword() string {
	val := d.ModelData.Get(models.NewFieldName("NewPassword", "new_password"))
	if !d.Has(models.NewFieldName("NewPassword", "new_password")) {
		return *new(string)
	}
	return val.(string)
}

// HasNewPassword returns true if NewPassword is set in this UserData
func (d UserData) HasNewPassword() bool {
	return d.ModelData.Has(models.NewFieldName("NewPassword", "new_password"))
}

// SetNewPassword sets the NewPassword field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetNewPassword(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("NewPassword", "new_password"), value)
	return d
}

// UnsetNewPassword removes the value of the NewPassword field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetNewPassword() m.UserData {
	d.ModelData.Unset(models.NewFieldName("NewPassword", "new_password"))
	return d
}

// Parent returns the value of the Parent field.
// If this Parent is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Parent() m.PartnerSet {
	val := d.ModelData.Get(models.NewFieldName("Parent", "parent_id"))
	if !d.Has(models.NewFieldName("Parent", "parent_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Partner")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerSet)
}

// HasParent returns true if Parent is set in this UserData
func (d UserData) HasParent() bool {
	return d.ModelData.Has(models.NewFieldName("Parent", "parent_id"))
}

// SetParent sets the Parent field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetParent(value m.PartnerSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Parent", "parent_id"), value)
	return d
}

// UnsetParent removes the value of the Parent field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetParent() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Parent", "parent_id"))
	return d
}

// CreateParent stores the related PartnerData to be used to create
// a related record on the fly for Parent.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateParent(related m.PartnerData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Parent", "parent_id"), related.Underlying())
	return d
}

// ParentName returns the value of the ParentName field.
// If this ParentName is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) ParentName() string {
	val := d.ModelData.Get(models.NewFieldName("ParentName", "parent_name"))
	if !d.Has(models.NewFieldName("ParentName", "parent_name")) {
		return *new(string)
	}
	return val.(string)
}

// HasParentName returns true if ParentName is set in this UserData
func (d UserData) HasParentName() bool {
	return d.ModelData.Has(models.NewFieldName("ParentName", "parent_name"))
}

// SetParentName sets the ParentName field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetParentName(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("ParentName", "parent_name"), value)
	return d
}

// UnsetParentName removes the value of the ParentName field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetParentName() m.UserData {
	d.ModelData.Unset(models.NewFieldName("ParentName", "parent_name"))
	return d
}

// Partner returns the value of the Partner field.
// If this Partner is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Partner() m.PartnerSet {
	val := d.ModelData.Get(models.NewFieldName("Partner", "partner_id"))
	if !d.Has(models.NewFieldName("Partner", "partner_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Partner")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerSet)
}

// HasPartner returns true if Partner is set in this UserData
func (d UserData) HasPartner() bool {
	return d.ModelData.Has(models.NewFieldName("Partner", "partner_id"))
}

// SetPartner sets the Partner field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetPartner(value m.PartnerSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Partner", "partner_id"), value)
	return d
}

// UnsetPartner removes the value of the Partner field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetPartner() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Partner", "partner_id"))
	return d
}

// CreatePartner stores the related PartnerData to be used to create
// a related record on the fly for Partner.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreatePartner(related m.PartnerData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Partner", "partner_id"), related.Underlying())
	return d
}

// PartnerShare returns the value of the PartnerShare field.
// If this PartnerShare is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) PartnerShare() bool {
	val := d.ModelData.Get(models.NewFieldName("PartnerShare", "partner_share"))
	if !d.Has(models.NewFieldName("PartnerShare", "partner_share")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasPartnerShare returns true if PartnerShare is set in this UserData
func (d UserData) HasPartnerShare() bool {
	return d.ModelData.Has(models.NewFieldName("PartnerShare", "partner_share"))
}

// SetPartnerShare sets the PartnerShare field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetPartnerShare(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("PartnerShare", "partner_share"), value)
	return d
}

// UnsetPartnerShare removes the value of the PartnerShare field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetPartnerShare() m.UserData {
	d.ModelData.Unset(models.NewFieldName("PartnerShare", "partner_share"))
	return d
}

// Password returns the value of the Password field.
// If this Password is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Password() string {
	val := d.ModelData.Get(models.NewFieldName("Password", "password"))
	if !d.Has(models.NewFieldName("Password", "password")) {
		return *new(string)
	}
	return val.(string)
}

// HasPassword returns true if Password is set in this UserData
func (d UserData) HasPassword() bool {
	return d.ModelData.Has(models.NewFieldName("Password", "password"))
}

// SetPassword sets the Password field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetPassword(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Password", "password"), value)
	return d
}

// UnsetPassword removes the value of the Password field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetPassword() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Password", "password"))
	return d
}

// Phone returns the value of the Phone field.
// If this Phone is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Phone() string {
	val := d.ModelData.Get(models.NewFieldName("Phone", "phone"))
	if !d.Has(models.NewFieldName("Phone", "phone")) {
		return *new(string)
	}
	return val.(string)
}

// HasPhone returns true if Phone is set in this UserData
func (d UserData) HasPhone() bool {
	return d.ModelData.Has(models.NewFieldName("Phone", "phone"))
}

// SetPhone sets the Phone field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetPhone(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Phone", "phone"), value)
	return d
}

// UnsetPhone removes the value of the Phone field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetPhone() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Phone", "phone"))
	return d
}

// Ref returns the value of the Ref field.
// If this Ref is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Ref() string {
	val := d.ModelData.Get(models.NewFieldName("Ref", "ref"))
	if !d.Has(models.NewFieldName("Ref", "ref")) {
		return *new(string)
	}
	return val.(string)
}

// HasRef returns true if Ref is set in this UserData
func (d UserData) HasRef() bool {
	return d.ModelData.Has(models.NewFieldName("Ref", "ref"))
}

// SetRef sets the Ref field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetRef(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Ref", "ref"), value)
	return d
}

// UnsetRef removes the value of the Ref field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetRef() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Ref", "ref"))
	return d
}

// SameVATPartner returns the value of the SameVATPartner field.
// If this SameVATPartner is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) SameVATPartner() m.PartnerSet {
	val := d.ModelData.Get(models.NewFieldName("SameVATPartner", "same_vat_partner_id"))
	if !d.Has(models.NewFieldName("SameVATPartner", "same_vat_partner_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("Partner")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerSet)
}

// HasSameVATPartner returns true if SameVATPartner is set in this UserData
func (d UserData) HasSameVATPartner() bool {
	return d.ModelData.Has(models.NewFieldName("SameVATPartner", "same_vat_partner_id"))
}

// SetSameVATPartner sets the SameVATPartner field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetSameVATPartner(value m.PartnerSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("SameVATPartner", "same_vat_partner_id"), value)
	return d
}

// UnsetSameVATPartner removes the value of the SameVATPartner field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetSameVATPartner() m.UserData {
	d.ModelData.Unset(models.NewFieldName("SameVATPartner", "same_vat_partner_id"))
	return d
}

// CreateSameVATPartner stores the related PartnerData to be used to create
// a related record on the fly for SameVATPartner.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateSameVATPartner(related m.PartnerData) m.UserData {
	d.ModelData.Create(models.NewFieldName("SameVATPartner", "same_vat_partner_id"), related.Underlying())
	return d
}

// Share returns the value of the Share field.
// If this Share is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Share() bool {
	val := d.ModelData.Get(models.NewFieldName("Share", "share"))
	if !d.Has(models.NewFieldName("Share", "share")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasShare returns true if Share is set in this UserData
func (d UserData) HasShare() bool {
	return d.ModelData.Has(models.NewFieldName("Share", "share"))
}

// SetShare sets the Share field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetShare(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("Share", "share"), value)
	return d
}

// UnsetShare removes the value of the Share field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetShare() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Share", "share"))
	return d
}

// SidebarVisible returns the value of the SidebarVisible field.
// If this SidebarVisible is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) SidebarVisible() bool {
	val := d.ModelData.Get(models.NewFieldName("SidebarVisible", "sidebar_visible"))
	if !d.Has(models.NewFieldName("SidebarVisible", "sidebar_visible")) {
		return *new(bool)
	}
	return val.(bool)
}

// HasSidebarVisible returns true if SidebarVisible is set in this UserData
func (d UserData) HasSidebarVisible() bool {
	return d.ModelData.Has(models.NewFieldName("SidebarVisible", "sidebar_visible"))
}

// SetSidebarVisible sets the SidebarVisible field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetSidebarVisible(value bool) m.UserData {
	d.ModelData.Set(models.NewFieldName("SidebarVisible", "sidebar_visible"), value)
	return d
}

// UnsetSidebarVisible removes the value of the SidebarVisible field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetSidebarVisible() m.UserData {
	d.ModelData.Unset(models.NewFieldName("SidebarVisible", "sidebar_visible"))
	return d
}

// Signature returns the value of the Signature field.
// If this Signature is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Signature() string {
	val := d.ModelData.Get(models.NewFieldName("Signature", "signature"))
	if !d.Has(models.NewFieldName("Signature", "signature")) {
		return *new(string)
	}
	return val.(string)
}

// HasSignature returns true if Signature is set in this UserData
func (d UserData) HasSignature() bool {
	return d.ModelData.Has(models.NewFieldName("Signature", "signature"))
}

// SetSignature sets the Signature field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetSignature(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Signature", "signature"), value)
	return d
}

// UnsetSignature removes the value of the Signature field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetSignature() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Signature", "signature"))
	return d
}

// State returns the value of the State field.
// If this State is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) State() m.CountryStateSet {
	val := d.ModelData.Get(models.NewFieldName("State", "state_id"))
	if !d.Has(models.NewFieldName("State", "state_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("CountryState")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.CountryStateSet)
}

// HasState returns true if State is set in this UserData
func (d UserData) HasState() bool {
	return d.ModelData.Has(models.NewFieldName("State", "state_id"))
}

// SetState sets the State field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetState(value m.CountryStateSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("State", "state_id"), value)
	return d
}

// UnsetState removes the value of the State field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetState() m.UserData {
	d.ModelData.Unset(models.NewFieldName("State", "state_id"))
	return d
}

// CreateState stores the related CountryStateData to be used to create
// a related record on the fly for State.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateState(related m.CountryStateData) m.UserData {
	d.ModelData.Create(models.NewFieldName("State", "state_id"), related.Underlying())
	return d
}

// Street returns the value of the Street field.
// If this Street is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Street() string {
	val := d.ModelData.Get(models.NewFieldName("Street", "street"))
	if !d.Has(models.NewFieldName("Street", "street")) {
		return *new(string)
	}
	return val.(string)
}

// HasStreet returns true if Street is set in this UserData
func (d UserData) HasStreet() bool {
	return d.ModelData.Has(models.NewFieldName("Street", "street"))
}

// SetStreet sets the Street field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetStreet(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Street", "street"), value)
	return d
}

// UnsetStreet removes the value of the Street field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetStreet() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Street", "street"))
	return d
}

// Street2 returns the value of the Street2 field.
// If this Street2 is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Street2() string {
	val := d.ModelData.Get(models.NewFieldName("Street2", "street2"))
	if !d.Has(models.NewFieldName("Street2", "street2")) {
		return *new(string)
	}
	return val.(string)
}

// HasStreet2 returns true if Street2 is set in this UserData
func (d UserData) HasStreet2() bool {
	return d.ModelData.Has(models.NewFieldName("Street2", "street2"))
}

// SetStreet2 sets the Street2 field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetStreet2(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Street2", "street2"), value)
	return d
}

// UnsetStreet2 removes the value of the Street2 field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetStreet2() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Street2", "street2"))
	return d
}

// TZ returns the value of the TZ field.
// If this TZ is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) TZ() string {
	val := d.ModelData.Get(models.NewFieldName("TZ", "tz"))
	if !d.Has(models.NewFieldName("TZ", "tz")) {
		return *new(string)
	}
	return val.(string)
}

// HasTZ returns true if TZ is set in this UserData
func (d UserData) HasTZ() bool {
	return d.ModelData.Has(models.NewFieldName("TZ", "tz"))
}

// SetTZ sets the TZ field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetTZ(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("TZ", "tz"), value)
	return d
}

// UnsetTZ removes the value of the TZ field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetTZ() m.UserData {
	d.ModelData.Unset(models.NewFieldName("TZ", "tz"))
	return d
}

// TZOffset returns the value of the TZOffset field.
// If this TZOffset is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) TZOffset() string {
	val := d.ModelData.Get(models.NewFieldName("TZOffset", "tz_offset"))
	if !d.Has(models.NewFieldName("TZOffset", "tz_offset")) {
		return *new(string)
	}
	return val.(string)
}

// HasTZOffset returns true if TZOffset is set in this UserData
func (d UserData) HasTZOffset() bool {
	return d.ModelData.Has(models.NewFieldName("TZOffset", "tz_offset"))
}

// SetTZOffset sets the TZOffset field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetTZOffset(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("TZOffset", "tz_offset"), value)
	return d
}

// UnsetTZOffset removes the value of the TZOffset field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetTZOffset() m.UserData {
	d.ModelData.Unset(models.NewFieldName("TZOffset", "tz_offset"))
	return d
}

// Title returns the value of the Title field.
// If this Title is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Title() m.PartnerTitleSet {
	val := d.ModelData.Get(models.NewFieldName("Title", "title_id"))
	if !d.Has(models.NewFieldName("Title", "title_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("PartnerTitle")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.PartnerTitleSet)
}

// HasTitle returns true if Title is set in this UserData
func (d UserData) HasTitle() bool {
	return d.ModelData.Has(models.NewFieldName("Title", "title_id"))
}

// SetTitle sets the Title field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetTitle(value m.PartnerTitleSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Title", "title_id"), value)
	return d
}

// UnsetTitle removes the value of the Title field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetTitle() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Title", "title_id"))
	return d
}

// CreateTitle stores the related PartnerTitleData to be used to create
// a related record on the fly for Title.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateTitle(related m.PartnerTitleData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Title", "title_id"), related.Underlying())
	return d
}

// Type returns the value of the Type field.
// If this Type is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Type() string {
	val := d.ModelData.Get(models.NewFieldName("Type", "type"))
	if !d.Has(models.NewFieldName("Type", "type")) {
		return *new(string)
	}
	return val.(string)
}

// HasType returns true if Type is set in this UserData
func (d UserData) HasType() bool {
	return d.ModelData.Has(models.NewFieldName("Type", "type"))
}

// SetType sets the Type field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetType(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Type", "type"), value)
	return d
}

// UnsetType removes the value of the Type field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetType() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Type", "type"))
	return d
}

// User returns the value of the User field.
// If this User is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) User() m.UserSet {
	val := d.ModelData.Get(models.NewFieldName("User", "user_id"))
	if !d.Has(models.NewFieldName("User", "user_id")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("User")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.UserSet)
}

// HasUser returns true if User is set in this UserData
func (d UserData) HasUser() bool {
	return d.ModelData.Has(models.NewFieldName("User", "user_id"))
}

// SetUser sets the User field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetUser(value m.UserSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("User", "user_id"), value)
	return d
}

// UnsetUser removes the value of the User field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetUser() m.UserData {
	d.ModelData.Unset(models.NewFieldName("User", "user_id"))
	return d
}

// CreateUser stores the related UserData to be used to create
// a related record on the fly for User.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateUser(related m.UserData) m.UserData {
	d.ModelData.Create(models.NewFieldName("User", "user_id"), related.Underlying())
	return d
}

// Users returns the value of the Users field.
// If this Users is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Users() m.UserSet {
	val := d.ModelData.Get(models.NewFieldName("Users", "user_ids"))
	if !d.Has(models.NewFieldName("Users", "user_ids")) || val == nil || val == (*interface{})(nil) {
		val = models.InvalidRecordCollection("User")
	}
	return val.(models.RecordSet).Collection().Wrap().(m.UserSet)
}

// HasUsers returns true if Users is set in this UserData
func (d UserData) HasUsers() bool {
	return d.ModelData.Has(models.NewFieldName("Users", "user_ids"))
}

// SetUsers sets the Users field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetUsers(value m.UserSet) m.UserData {
	d.ModelData.Set(models.NewFieldName("Users", "user_ids"), value)
	return d
}

// UnsetUsers removes the value of the Users field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetUsers() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Users", "user_ids"))
	return d
}

// CreateUsers stores the related UserData to be used to create
// a related record on the fly for Users.
//
// This method can be called multiple times to create multiple records
func (d UserData) CreateUsers(related m.UserData) m.UserData {
	d.ModelData.Create(models.NewFieldName("Users", "user_ids"), related.Underlying())
	return d
}

// VAT returns the value of the VAT field.
// If this VAT is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) VAT() string {
	val := d.ModelData.Get(models.NewFieldName("VAT", "vat"))
	if !d.Has(models.NewFieldName("VAT", "vat")) {
		return *new(string)
	}
	return val.(string)
}

// HasVAT returns true if VAT is set in this UserData
func (d UserData) HasVAT() bool {
	return d.ModelData.Has(models.NewFieldName("VAT", "vat"))
}

// SetVAT sets the VAT field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetVAT(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("VAT", "vat"), value)
	return d
}

// UnsetVAT removes the value of the VAT field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetVAT() m.UserData {
	d.ModelData.Unset(models.NewFieldName("VAT", "vat"))
	return d
}

// Website returns the value of the Website field.
// If this Website is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Website() string {
	val := d.ModelData.Get(models.NewFieldName("Website", "website"))
	if !d.Has(models.NewFieldName("Website", "website")) {
		return *new(string)
	}
	return val.(string)
}

// HasWebsite returns true if Website is set in this UserData
func (d UserData) HasWebsite() bool {
	return d.ModelData.Has(models.NewFieldName("Website", "website"))
}

// SetWebsite sets the Website field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetWebsite(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Website", "website"), value)
	return d
}

// UnsetWebsite removes the value of the Website field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetWebsite() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Website", "website"))
	return d
}

// WriteDate returns the value of the WriteDate field.
// If this WriteDate is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) WriteDate() dates.DateTime {
	val := d.ModelData.Get(models.NewFieldName("WriteDate", "write_date"))
	if !d.Has(models.NewFieldName("WriteDate", "write_date")) {
		return *new(dates.DateTime)
	}
	return val.(dates.DateTime)
}

// HasWriteDate returns true if WriteDate is set in this UserData
func (d UserData) HasWriteDate() bool {
	return d.ModelData.Has(models.NewFieldName("WriteDate", "write_date"))
}

// SetWriteDate sets the WriteDate field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetWriteDate(value dates.DateTime) m.UserData {
	d.ModelData.Set(models.NewFieldName("WriteDate", "write_date"), value)
	return d
}

// UnsetWriteDate removes the value of the WriteDate field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetWriteDate() m.UserData {
	d.ModelData.Unset(models.NewFieldName("WriteDate", "write_date"))
	return d
}

// WriteUID returns the value of the WriteUID field.
// If this WriteUID is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) WriteUID() int64 {
	val := d.ModelData.Get(models.NewFieldName("WriteUID", "write_uid"))
	if !d.Has(models.NewFieldName("WriteUID", "write_uid")) {
		return *new(int64)
	}
	return val.(int64)
}

// HasWriteUID returns true if WriteUID is set in this UserData
func (d UserData) HasWriteUID() bool {
	return d.ModelData.Has(models.NewFieldName("WriteUID", "write_uid"))
}

// SetWriteUID sets the WriteUID field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetWriteUID(value int64) m.UserData {
	d.ModelData.Set(models.NewFieldName("WriteUID", "write_uid"), value)
	return d
}

// UnsetWriteUID removes the value of the WriteUID field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetWriteUID() m.UserData {
	d.ModelData.Unset(models.NewFieldName("WriteUID", "write_uid"))
	return d
}

// Zip returns the value of the Zip field.
// If this Zip is not set in this UserData, then
// the Go zero value for the type is returned.
func (d UserData) Zip() string {
	val := d.ModelData.Get(models.NewFieldName("Zip", "zip"))
	if !d.Has(models.NewFieldName("Zip", "zip")) {
		return *new(string)
	}
	return val.(string)
}

// HasZip returns true if Zip is set in this UserData
func (d UserData) HasZip() bool {
	return d.ModelData.Has(models.NewFieldName("Zip", "zip"))
}

// SetZip sets the Zip field with the given value.
// It returns this UserData so that calls can be chained.
func (d UserData) SetZip(value string) m.UserData {
	d.ModelData.Set(models.NewFieldName("Zip", "zip"), value)
	return d
}

// UnsetZip removes the value of the Zip field if it exists.
// It returns this UserData so that calls can be chained.
func (d UserData) UnsetZip() m.UserData {
	d.ModelData.Unset(models.NewFieldName("Zip", "zip"))
	return d
}

var _ m.UserData = new(UserData)
var _ m.UserData = UserData{}

// ------ AGGREGATE ROW --------

// A UserGroupAggregateRow holds a row of results of a query with a group by clause
// - Values holds the values of the actual query
// - Count is the number of lines aggregated into this one
// - Condition can be used to query the aggregated rows separately if needed
type UserGroupAggregateRow struct {
	values    m.UserData
	count     int
	condition q.UserCondition
}

// Values returns the values of the actual query
func (a UserGroupAggregateRow) Values() m.UserData {
	return a.values
}

// Count returns the number of lines aggregated into this one
func (a UserGroupAggregateRow) Count() int {
	return a.count
}

// Condition can be used to query the aggregated rows separately if needed
func (a UserGroupAggregateRow) Condition() q.UserCondition {
	return a.condition
}

// ------- RECORD SET ---------

// UserSet is an autogenerated type to handle User objects.
type UserSet struct {
	*models.RecordCollection
}

var _ models.RecordSet = UserSet{}

// UserSetHexyaFunc is a dummy function to uniquely match interfaces.
func (s UserSet) UserSetHexyaFunc() {}

// IsValid returns true if this RecordSet has been initialized.
func (s UserSet) IsValid() bool {
	if s.RecordCollection == nil {
		return false
	}
	return s.RecordCollection.IsValid()
}

// ForceLoad reloads the cache for the given fields and updates the ids of this UserSet.
//
// If no fields are given, all DB columns of the User model are retrieved.
//
// It also returns this UserSet.
func (s UserSet) ForceLoad(fields ...models.FieldName) m.UserSet {
	s.RecordCollection.ForceLoad(fields...)
	return s
}

// Records returns a slice with all the records of this RecordSet, as singleton
// RecordSets
func (s UserSet) Records() []m.UserSet {
	recs := s.RecordCollection.Records()
	res := make([]m.UserSet, len(recs))
	for i, rec := range recs {
		res[i] = rec.Wrap("User").(m.UserSet)
	}
	return res
}

// CartesianProduct returns the cartesian product of this UserSet with others.
func (s UserSet) CartesianProduct(others ...m.UserSet) []m.UserSet {
	otherSet := make([]models.RecordSet, len(others))
	for i, o := range others {
		otherSet[i] = o
	}
	recs := s.RecordCollection.CartesianProduct(otherSet...)
	res := make([]m.UserSet, len(recs))
	for i, rec := range recs {
		res[i] = rec.Wrap("User").(m.UserSet)
	}
	return res
}

// First returns the values of the first Record of the RecordSet as a pointer to a UserData.
//
// If this RecordSet is empty, it returns an empty UserData.
func (s UserSet) First() m.UserData {
	return &UserData{
		s.RecordCollection.First(),
	}
}

// All returns the values of all Records of the RecordCollection as a slice of UserData pointers.
func (s UserSet) All() []m.UserData {
	allSlice := s.RecordCollection.All()
	res := make([]m.UserData, len(allSlice))
	for i, v := range allSlice {
		res[i] = &UserData{v}
	}
	return res
}

// Sorted returns a new UserSet sorted according to the given less function.
//
// The less function should return true if rs1 < rs2
func (s UserSet) Sorted(less func(rs1, rs2 m.UserSet) bool) m.UserSet {
	res := s.RecordCollection.Sorted(func(rc1 models.RecordSet, rc2 models.RecordSet) bool {
		return less(UserSet{RecordCollection: rc1.Collection()}, UserSet{RecordCollection: rc2.Collection()})
	})
	return res.Wrap("User").(m.UserSet)
}

// Filtered returns a new UserSet with only the elements of this record set
// for which test is true.
//
// Note that if this UserSet is not fully loaded, this function will call the database
// to load the fields before doing the filtering. In this case, it might be more efficient
// to search the database directly with the filter condition.
func (s UserSet) Filtered(test func(rs m.UserSet) bool) m.UserSet {
	res := s.RecordCollection.Filtered(func(rc models.RecordSet) bool {
		return test(UserSet{RecordCollection: rc.Collection()})
	})
	return res.Wrap("User").(m.UserSet)
}

// ActionID is a getter for the value of the "ActionID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ActionID() actions.ActionRef {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ActionID", "action_id")).(actions.ActionRef)
	return res
}

// SetActionID is a setter for the value of the "ActionID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetActionID panics if the RecordSet is empty.
func (s UserSet) SetActionID(value actions.ActionRef) {
	s.RecordCollection.Set(models.NewFieldName("ActionID", "action_id"), value)
}

// Active is a getter for the value of the "Active" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Active() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Active", "active")).(bool)
	return res
}

// SetActive is a setter for the value of the "Active" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetActive panics if the RecordSet is empty.
func (s UserSet) SetActive(value bool) {
	s.RecordCollection.Set(models.NewFieldName("Active", "active"), value)
}

// ActiveLangCount is a getter for the value of the "ActiveLangCount" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ActiveLangCount() int {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ActiveLangCount", "active_lang_count")).(int)
	return res
}

// SetActiveLangCount is a setter for the value of the "ActiveLangCount" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetActiveLangCount panics if the RecordSet is empty.
func (s UserSet) SetActiveLangCount(value int) {
	s.RecordCollection.Set(models.NewFieldName("ActiveLangCount", "active_lang_count"), value)
}

// ActivePartner is a getter for the value of the "ActivePartner" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ActivePartner() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ActivePartner", "active_partner")).(bool)
	return res
}

// SetActivePartner is a setter for the value of the "ActivePartner" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetActivePartner panics if the RecordSet is empty.
func (s UserSet) SetActivePartner(value bool) {
	s.RecordCollection.Set(models.NewFieldName("ActivePartner", "active_partner"), value)
}

// Banks is a getter for the value of the "Banks" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Banks() m.BankAccountSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Banks", "banks_ids")).(models.RecordSet).Collection().Wrap("BankAccount").(m.BankAccountSet)
	return res
}

// SetBanks is a setter for the value of the "Banks" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetBanks panics if the RecordSet is empty.
func (s UserSet) SetBanks(value m.BankAccountSet) {
	s.RecordCollection.Set(models.NewFieldName("Banks", "banks_ids"), value)
}

// Barcode is a getter for the value of the "Barcode" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Barcode() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Barcode", "barcode")).(string)
	return res
}

// SetBarcode is a setter for the value of the "Barcode" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetBarcode panics if the RecordSet is empty.
func (s UserSet) SetBarcode(value string) {
	s.RecordCollection.Set(models.NewFieldName("Barcode", "barcode"), value)
}

// Categories is a getter for the value of the "Categories" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Categories() m.PartnerCategorySet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Categories", "category_ids")).(models.RecordSet).Collection().Wrap("PartnerCategory").(m.PartnerCategorySet)
	return res
}

// SetCategories is a setter for the value of the "Categories" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCategories panics if the RecordSet is empty.
func (s UserSet) SetCategories(value m.PartnerCategorySet) {
	s.RecordCollection.Set(models.NewFieldName("Categories", "category_ids"), value)
}

// ChatterPosition is a getter for the value of the "ChatterPosition" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ChatterPosition() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ChatterPosition", "chatter_position")).(string)
	return res
}

// SetChatterPosition is a setter for the value of the "ChatterPosition" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetChatterPosition panics if the RecordSet is empty.
func (s UserSet) SetChatterPosition(value string) {
	s.RecordCollection.Set(models.NewFieldName("ChatterPosition", "chatter_position"), value)
}

// Children is a getter for the value of the "Children" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Children() m.PartnerSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Children", "children_ids")).(models.RecordSet).Collection().Wrap("Partner").(m.PartnerSet)
	return res
}

// SetChildren is a setter for the value of the "Children" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetChildren panics if the RecordSet is empty.
func (s UserSet) SetChildren(value m.PartnerSet) {
	s.RecordCollection.Set(models.NewFieldName("Children", "children_ids"), value)
}

// City is a getter for the value of the "City" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) City() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("City", "city")).(string)
	return res
}

// SetCity is a setter for the value of the "City" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCity panics if the RecordSet is empty.
func (s UserSet) SetCity(value string) {
	s.RecordCollection.Set(models.NewFieldName("City", "city"), value)
}

// Color is a getter for the value of the "Color" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Color() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Color", "color")).(int64)
	return res
}

// SetColor is a setter for the value of the "Color" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetColor panics if the RecordSet is empty.
func (s UserSet) SetColor(value int64) {
	s.RecordCollection.Set(models.NewFieldName("Color", "color"), value)
}

// Comment is a getter for the value of the "Comment" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Comment() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Comment", "comment")).(string)
	return res
}

// SetComment is a setter for the value of the "Comment" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetComment panics if the RecordSet is empty.
func (s UserSet) SetComment(value string) {
	s.RecordCollection.Set(models.NewFieldName("Comment", "comment"), value)
}

// CommercialCompanyName is a getter for the value of the "CommercialCompanyName" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CommercialCompanyName() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CommercialCompanyName", "commercial_company_name")).(string)
	return res
}

// SetCommercialCompanyName is a setter for the value of the "CommercialCompanyName" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCommercialCompanyName panics if the RecordSet is empty.
func (s UserSet) SetCommercialCompanyName(value string) {
	s.RecordCollection.Set(models.NewFieldName("CommercialCompanyName", "commercial_company_name"), value)
}

// CommercialPartner is a getter for the value of the "CommercialPartner" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CommercialPartner() m.PartnerSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CommercialPartner", "commercial_partner_id")).(models.RecordSet).Collection().Wrap("Partner").(m.PartnerSet)
	return res
}

// SetCommercialPartner is a setter for the value of the "CommercialPartner" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCommercialPartner panics if the RecordSet is empty.
func (s UserSet) SetCommercialPartner(value m.PartnerSet) {
	s.RecordCollection.Set(models.NewFieldName("CommercialPartner", "commercial_partner_id"), value)
}

// Companies is a getter for the value of the "Companies" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Companies() m.CompanySet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Companies", "company_ids")).(models.RecordSet).Collection().Wrap("Company").(m.CompanySet)
	return res
}

// SetCompanies is a setter for the value of the "Companies" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCompanies panics if the RecordSet is empty.
func (s UserSet) SetCompanies(value m.CompanySet) {
	s.RecordCollection.Set(models.NewFieldName("Companies", "company_ids"), value)
}

// CompaniesCount is a getter for the value of the "CompaniesCount" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CompaniesCount() int {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CompaniesCount", "companies_count")).(int)
	return res
}

// SetCompaniesCount is a setter for the value of the "CompaniesCount" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCompaniesCount panics if the RecordSet is empty.
func (s UserSet) SetCompaniesCount(value int) {
	s.RecordCollection.Set(models.NewFieldName("CompaniesCount", "companies_count"), value)
}

// Company is a getter for the value of the "Company" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Company() m.CompanySet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Company", "company_id")).(models.RecordSet).Collection().Wrap("Company").(m.CompanySet)
	return res
}

// SetCompany is a setter for the value of the "Company" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCompany panics if the RecordSet is empty.
func (s UserSet) SetCompany(value m.CompanySet) {
	s.RecordCollection.Set(models.NewFieldName("Company", "company_id"), value)
}

// CompanyName is a getter for the value of the "CompanyName" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CompanyName() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CompanyName", "company_name")).(string)
	return res
}

// SetCompanyName is a setter for the value of the "CompanyName" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCompanyName panics if the RecordSet is empty.
func (s UserSet) SetCompanyName(value string) {
	s.RecordCollection.Set(models.NewFieldName("CompanyName", "company_name"), value)
}

// CompanyType is a getter for the value of the "CompanyType" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CompanyType() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CompanyType", "company_type")).(string)
	return res
}

// SetCompanyType is a setter for the value of the "CompanyType" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCompanyType panics if the RecordSet is empty.
func (s UserSet) SetCompanyType(value string) {
	s.RecordCollection.Set(models.NewFieldName("CompanyType", "company_type"), value)
}

// ContactAddress is a getter for the value of the "ContactAddress" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ContactAddress() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ContactAddress", "contact_address")).(string)
	return res
}

// SetContactAddress is a setter for the value of the "ContactAddress" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetContactAddress panics if the RecordSet is empty.
func (s UserSet) SetContactAddress(value string) {
	s.RecordCollection.Set(models.NewFieldName("ContactAddress", "contact_address"), value)
}

// Country is a getter for the value of the "Country" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Country() m.CountrySet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Country", "country_id")).(models.RecordSet).Collection().Wrap("Country").(m.CountrySet)
	return res
}

// SetCountry is a setter for the value of the "Country" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCountry panics if the RecordSet is empty.
func (s UserSet) SetCountry(value m.CountrySet) {
	s.RecordCollection.Set(models.NewFieldName("Country", "country_id"), value)
}

// CreateDate is a getter for the value of the "CreateDate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CreateDate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CreateDate", "create_date")).(dates.DateTime)
	return res
}

// SetCreateDate is a setter for the value of the "CreateDate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCreateDate panics if the RecordSet is empty.
func (s UserSet) SetCreateDate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("CreateDate", "create_date"), value)
}

// CreateUID is a getter for the value of the "CreateUID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CreateUID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CreateUID", "create_uid")).(int64)
	return res
}

// SetCreateUID is a setter for the value of the "CreateUID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCreateUID panics if the RecordSet is empty.
func (s UserSet) SetCreateUID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("CreateUID", "create_uid"), value)
}

// CreditLimit is a getter for the value of the "CreditLimit" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) CreditLimit() float64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("CreditLimit", "credit_limit")).(float64)
	return res
}

// SetCreditLimit is a setter for the value of the "CreditLimit" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetCreditLimit panics if the RecordSet is empty.
func (s UserSet) SetCreditLimit(value float64) {
	s.RecordCollection.Set(models.NewFieldName("CreditLimit", "credit_limit"), value)
}

// Date is a getter for the value of the "Date" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Date() dates.Date {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Date", "date")).(dates.Date)
	return res
}

// SetDate is a setter for the value of the "Date" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetDate panics if the RecordSet is empty.
func (s UserSet) SetDate(value dates.Date) {
	s.RecordCollection.Set(models.NewFieldName("Date", "date"), value)
}

// DisplayName is a getter for the value of the "DisplayName" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) DisplayName() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("DisplayName", "display_name")).(string)
	return res
}

// SetDisplayName is a setter for the value of the "DisplayName" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetDisplayName panics if the RecordSet is empty.
func (s UserSet) SetDisplayName(value string) {
	s.RecordCollection.Set(models.NewFieldName("DisplayName", "display_name"), value)
}

// Email is a getter for the value of the "Email" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Email() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Email", "email")).(string)
	return res
}

// SetEmail is a setter for the value of the "Email" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetEmail panics if the RecordSet is empty.
func (s UserSet) SetEmail(value string) {
	s.RecordCollection.Set(models.NewFieldName("Email", "email"), value)
}

// EmailFormatted is a getter for the value of the "EmailFormatted" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) EmailFormatted() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("EmailFormatted", "email_formatted")).(string)
	return res
}

// SetEmailFormatted is a setter for the value of the "EmailFormatted" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetEmailFormatted panics if the RecordSet is empty.
func (s UserSet) SetEmailFormatted(value string) {
	s.RecordCollection.Set(models.NewFieldName("EmailFormatted", "email_formatted"), value)
}

// Employee is a getter for the value of the "Employee" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Employee() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Employee", "employee")).(bool)
	return res
}

// SetEmployee is a setter for the value of the "Employee" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetEmployee panics if the RecordSet is empty.
func (s UserSet) SetEmployee(value bool) {
	s.RecordCollection.Set(models.NewFieldName("Employee", "employee"), value)
}

// Function is a getter for the value of the "Function" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Function() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Function", "function")).(string)
	return res
}

// SetFunction is a setter for the value of the "Function" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetFunction panics if the RecordSet is empty.
func (s UserSet) SetFunction(value string) {
	s.RecordCollection.Set(models.NewFieldName("Function", "function"), value)
}

// Groups is a getter for the value of the "Groups" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Groups() m.GroupSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Groups", "group_ids")).(models.RecordSet).Collection().Wrap("Group").(m.GroupSet)
	return res
}

// SetGroups is a setter for the value of the "Groups" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetGroups panics if the RecordSet is empty.
func (s UserSet) SetGroups(value m.GroupSet) {
	s.RecordCollection.Set(models.NewFieldName("Groups", "group_ids"), value)
}

// GroupsCount is a getter for the value of the "GroupsCount" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) GroupsCount() int {
	res, _ := s.RecordCollection.Get(models.NewFieldName("GroupsCount", "groups_count")).(int)
	return res
}

// SetGroupsCount is a setter for the value of the "GroupsCount" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetGroupsCount panics if the RecordSet is empty.
func (s UserSet) SetGroupsCount(value int) {
	s.RecordCollection.Set(models.NewFieldName("GroupsCount", "groups_count"), value)
}

// HexyaExternalID is a getter for the value of the "HexyaExternalID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) HexyaExternalID() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("HexyaExternalID", "hexya_external_id")).(string)
	return res
}

// SetHexyaExternalID is a setter for the value of the "HexyaExternalID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetHexyaExternalID panics if the RecordSet is empty.
func (s UserSet) SetHexyaExternalID(value string) {
	s.RecordCollection.Set(models.NewFieldName("HexyaExternalID", "hexya_external_id"), value)
}

// HexyaVersion is a getter for the value of the "HexyaVersion" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) HexyaVersion() int {
	res, _ := s.RecordCollection.Get(models.NewFieldName("HexyaVersion", "hexya_version")).(int)
	return res
}

// SetHexyaVersion is a setter for the value of the "HexyaVersion" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetHexyaVersion panics if the RecordSet is empty.
func (s UserSet) SetHexyaVersion(value int) {
	s.RecordCollection.Set(models.NewFieldName("HexyaVersion", "hexya_version"), value)
}

// ID is a getter for the value of the "ID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ID", "id")).(int64)
	return res
}

// SetID is a setter for the value of the "ID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetID panics if the RecordSet is empty.
func (s UserSet) SetID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("ID", "id"), value)
}

// Image is a getter for the value of the "Image" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Image() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Image", "image")).(string)
	return res
}

// SetImage is a setter for the value of the "Image" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetImage panics if the RecordSet is empty.
func (s UserSet) SetImage(value string) {
	s.RecordCollection.Set(models.NewFieldName("Image", "image"), value)
}

// ImageMedium is a getter for the value of the "ImageMedium" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ImageMedium() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ImageMedium", "image_medium")).(string)
	return res
}

// SetImageMedium is a setter for the value of the "ImageMedium" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetImageMedium panics if the RecordSet is empty.
func (s UserSet) SetImageMedium(value string) {
	s.RecordCollection.Set(models.NewFieldName("ImageMedium", "image_medium"), value)
}

// ImageSmall is a getter for the value of the "ImageSmall" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ImageSmall() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ImageSmall", "image_small")).(string)
	return res
}

// SetImageSmall is a setter for the value of the "ImageSmall" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetImageSmall panics if the RecordSet is empty.
func (s UserSet) SetImageSmall(value string) {
	s.RecordCollection.Set(models.NewFieldName("ImageSmall", "image_small"), value)
}

// Industry is a getter for the value of the "Industry" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Industry() m.PartnerIndustrySet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Industry", "industry_id")).(models.RecordSet).Collection().Wrap("PartnerIndustry").(m.PartnerIndustrySet)
	return res
}

// SetIndustry is a setter for the value of the "Industry" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetIndustry panics if the RecordSet is empty.
func (s UserSet) SetIndustry(value m.PartnerIndustrySet) {
	s.RecordCollection.Set(models.NewFieldName("Industry", "industry_id"), value)
}

// IsCompany is a getter for the value of the "IsCompany" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) IsCompany() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("IsCompany", "is_company")).(bool)
	return res
}

// SetIsCompany is a setter for the value of the "IsCompany" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetIsCompany panics if the RecordSet is empty.
func (s UserSet) SetIsCompany(value bool) {
	s.RecordCollection.Set(models.NewFieldName("IsCompany", "is_company"), value)
}

// Lang is a getter for the value of the "Lang" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Lang() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Lang", "lang")).(string)
	return res
}

// SetLang is a setter for the value of the "Lang" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLang panics if the RecordSet is empty.
func (s UserSet) SetLang(value string) {
	s.RecordCollection.Set(models.NewFieldName("Lang", "lang"), value)
}

// LastUpdate is a getter for the value of the "LastUpdate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) LastUpdate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("LastUpdate", "__last_update")).(dates.DateTime)
	return res
}

// SetLastUpdate is a setter for the value of the "LastUpdate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLastUpdate panics if the RecordSet is empty.
func (s UserSet) SetLastUpdate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("LastUpdate", "__last_update"), value)
}

// Latitude is a getter for the value of the "Latitude" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Latitude() float64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Latitude", "latitude")).(float64)
	return res
}

// SetLatitude is a setter for the value of the "Latitude" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLatitude panics if the RecordSet is empty.
func (s UserSet) SetLatitude(value float64) {
	s.RecordCollection.Set(models.NewFieldName("Latitude", "latitude"), value)
}

// Login is a getter for the value of the "Login" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Login() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Login", "login")).(string)
	return res
}

// SetLogin is a setter for the value of the "Login" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLogin panics if the RecordSet is empty.
func (s UserSet) SetLogin(value string) {
	s.RecordCollection.Set(models.NewFieldName("Login", "login"), value)
}

// LoginDate is a getter for the value of the "LoginDate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) LoginDate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("LoginDate", "login_date")).(dates.DateTime)
	return res
}

// SetLoginDate is a setter for the value of the "LoginDate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLoginDate panics if the RecordSet is empty.
func (s UserSet) SetLoginDate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("LoginDate", "login_date"), value)
}

// Logs is a getter for the value of the "Logs" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Logs() m.UserLogSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Logs", "log_ids")).(models.RecordSet).Collection().Wrap("UserLog").(m.UserLogSet)
	return res
}

// SetLogs is a setter for the value of the "Logs" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLogs panics if the RecordSet is empty.
func (s UserSet) SetLogs(value m.UserLogSet) {
	s.RecordCollection.Set(models.NewFieldName("Logs", "log_ids"), value)
}

// Longitude is a getter for the value of the "Longitude" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Longitude() float64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Longitude", "longitude")).(float64)
	return res
}

// SetLongitude is a setter for the value of the "Longitude" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetLongitude panics if the RecordSet is empty.
func (s UserSet) SetLongitude(value float64) {
	s.RecordCollection.Set(models.NewFieldName("Longitude", "longitude"), value)
}

// Mobile is a getter for the value of the "Mobile" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Mobile() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Mobile", "mobile")).(string)
	return res
}

// SetMobile is a setter for the value of the "Mobile" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetMobile panics if the RecordSet is empty.
func (s UserSet) SetMobile(value string) {
	s.RecordCollection.Set(models.NewFieldName("Mobile", "mobile"), value)
}

// Name is a getter for the value of the "Name" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Name() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Name", "name")).(string)
	return res
}

// SetName is a setter for the value of the "Name" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetName panics if the RecordSet is empty.
func (s UserSet) SetName(value string) {
	s.RecordCollection.Set(models.NewFieldName("Name", "name"), value)
}

// NewPassword is a getter for the value of the "NewPassword" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) NewPassword() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("NewPassword", "new_password")).(string)
	return res
}

// SetNewPassword is a setter for the value of the "NewPassword" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetNewPassword panics if the RecordSet is empty.
func (s UserSet) SetNewPassword(value string) {
	s.RecordCollection.Set(models.NewFieldName("NewPassword", "new_password"), value)
}

// Parent is a getter for the value of the "Parent" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Parent() m.PartnerSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Parent", "parent_id")).(models.RecordSet).Collection().Wrap("Partner").(m.PartnerSet)
	return res
}

// SetParent is a setter for the value of the "Parent" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetParent panics if the RecordSet is empty.
func (s UserSet) SetParent(value m.PartnerSet) {
	s.RecordCollection.Set(models.NewFieldName("Parent", "parent_id"), value)
}

// ParentName is a getter for the value of the "ParentName" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) ParentName() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("ParentName", "parent_name")).(string)
	return res
}

// SetParentName is a setter for the value of the "ParentName" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetParentName panics if the RecordSet is empty.
func (s UserSet) SetParentName(value string) {
	s.RecordCollection.Set(models.NewFieldName("ParentName", "parent_name"), value)
}

// Partner is a getter for the value of the "Partner" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Partner() m.PartnerSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Partner", "partner_id")).(models.RecordSet).Collection().Wrap("Partner").(m.PartnerSet)
	return res
}

// SetPartner is a setter for the value of the "Partner" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetPartner panics if the RecordSet is empty.
func (s UserSet) SetPartner(value m.PartnerSet) {
	s.RecordCollection.Set(models.NewFieldName("Partner", "partner_id"), value)
}

// PartnerShare is a getter for the value of the "PartnerShare" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) PartnerShare() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("PartnerShare", "partner_share")).(bool)
	return res
}

// SetPartnerShare is a setter for the value of the "PartnerShare" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetPartnerShare panics if the RecordSet is empty.
func (s UserSet) SetPartnerShare(value bool) {
	s.RecordCollection.Set(models.NewFieldName("PartnerShare", "partner_share"), value)
}

// Password is a getter for the value of the "Password" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Password() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Password", "password")).(string)
	return res
}

// SetPassword is a setter for the value of the "Password" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetPassword panics if the RecordSet is empty.
func (s UserSet) SetPassword(value string) {
	s.RecordCollection.Set(models.NewFieldName("Password", "password"), value)
}

// Phone is a getter for the value of the "Phone" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Phone() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Phone", "phone")).(string)
	return res
}

// SetPhone is a setter for the value of the "Phone" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetPhone panics if the RecordSet is empty.
func (s UserSet) SetPhone(value string) {
	s.RecordCollection.Set(models.NewFieldName("Phone", "phone"), value)
}

// Ref is a getter for the value of the "Ref" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Ref() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Ref", "ref")).(string)
	return res
}

// SetRef is a setter for the value of the "Ref" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetRef panics if the RecordSet is empty.
func (s UserSet) SetRef(value string) {
	s.RecordCollection.Set(models.NewFieldName("Ref", "ref"), value)
}

// SameVATPartner is a getter for the value of the "SameVATPartner" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) SameVATPartner() m.PartnerSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("SameVATPartner", "same_vat_partner_id")).(models.RecordSet).Collection().Wrap("Partner").(m.PartnerSet)
	return res
}

// SetSameVATPartner is a setter for the value of the "SameVATPartner" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetSameVATPartner panics if the RecordSet is empty.
func (s UserSet) SetSameVATPartner(value m.PartnerSet) {
	s.RecordCollection.Set(models.NewFieldName("SameVATPartner", "same_vat_partner_id"), value)
}

// Share is a getter for the value of the "Share" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Share() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Share", "share")).(bool)
	return res
}

// SetShare is a setter for the value of the "Share" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetShare panics if the RecordSet is empty.
func (s UserSet) SetShare(value bool) {
	s.RecordCollection.Set(models.NewFieldName("Share", "share"), value)
}

// SidebarVisible is a getter for the value of the "SidebarVisible" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) SidebarVisible() bool {
	res, _ := s.RecordCollection.Get(models.NewFieldName("SidebarVisible", "sidebar_visible")).(bool)
	return res
}

// SetSidebarVisible is a setter for the value of the "SidebarVisible" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetSidebarVisible panics if the RecordSet is empty.
func (s UserSet) SetSidebarVisible(value bool) {
	s.RecordCollection.Set(models.NewFieldName("SidebarVisible", "sidebar_visible"), value)
}

// Signature is a getter for the value of the "Signature" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Signature() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Signature", "signature")).(string)
	return res
}

// SetSignature is a setter for the value of the "Signature" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetSignature panics if the RecordSet is empty.
func (s UserSet) SetSignature(value string) {
	s.RecordCollection.Set(models.NewFieldName("Signature", "signature"), value)
}

// State is a getter for the value of the "State" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) State() m.CountryStateSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("State", "state_id")).(models.RecordSet).Collection().Wrap("CountryState").(m.CountryStateSet)
	return res
}

// SetState is a setter for the value of the "State" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetState panics if the RecordSet is empty.
func (s UserSet) SetState(value m.CountryStateSet) {
	s.RecordCollection.Set(models.NewFieldName("State", "state_id"), value)
}

// Street is a getter for the value of the "Street" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Street() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Street", "street")).(string)
	return res
}

// SetStreet is a setter for the value of the "Street" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetStreet panics if the RecordSet is empty.
func (s UserSet) SetStreet(value string) {
	s.RecordCollection.Set(models.NewFieldName("Street", "street"), value)
}

// Street2 is a getter for the value of the "Street2" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Street2() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Street2", "street2")).(string)
	return res
}

// SetStreet2 is a setter for the value of the "Street2" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetStreet2 panics if the RecordSet is empty.
func (s UserSet) SetStreet2(value string) {
	s.RecordCollection.Set(models.NewFieldName("Street2", "street2"), value)
}

// TZ is a getter for the value of the "TZ" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) TZ() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("TZ", "tz")).(string)
	return res
}

// SetTZ is a setter for the value of the "TZ" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetTZ panics if the RecordSet is empty.
func (s UserSet) SetTZ(value string) {
	s.RecordCollection.Set(models.NewFieldName("TZ", "tz"), value)
}

// TZOffset is a getter for the value of the "TZOffset" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) TZOffset() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("TZOffset", "tz_offset")).(string)
	return res
}

// SetTZOffset is a setter for the value of the "TZOffset" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetTZOffset panics if the RecordSet is empty.
func (s UserSet) SetTZOffset(value string) {
	s.RecordCollection.Set(models.NewFieldName("TZOffset", "tz_offset"), value)
}

// Title is a getter for the value of the "Title" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Title() m.PartnerTitleSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Title", "title_id")).(models.RecordSet).Collection().Wrap("PartnerTitle").(m.PartnerTitleSet)
	return res
}

// SetTitle is a setter for the value of the "Title" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetTitle panics if the RecordSet is empty.
func (s UserSet) SetTitle(value m.PartnerTitleSet) {
	s.RecordCollection.Set(models.NewFieldName("Title", "title_id"), value)
}

// Type is a getter for the value of the "Type" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Type() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Type", "type")).(string)
	return res
}

// SetType is a setter for the value of the "Type" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetType panics if the RecordSet is empty.
func (s UserSet) SetType(value string) {
	s.RecordCollection.Set(models.NewFieldName("Type", "type"), value)
}

// User is a getter for the value of the "User" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) User() m.UserSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("User", "user_id")).(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return res
}

// SetUser is a setter for the value of the "User" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetUser panics if the RecordSet is empty.
func (s UserSet) SetUser(value m.UserSet) {
	s.RecordCollection.Set(models.NewFieldName("User", "user_id"), value)
}

// Users is a getter for the value of the "Users" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Users() m.UserSet {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Users", "user_ids")).(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return res
}

// SetUsers is a setter for the value of the "Users" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetUsers panics if the RecordSet is empty.
func (s UserSet) SetUsers(value m.UserSet) {
	s.RecordCollection.Set(models.NewFieldName("Users", "user_ids"), value)
}

// VAT is a getter for the value of the "VAT" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) VAT() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("VAT", "vat")).(string)
	return res
}

// SetVAT is a setter for the value of the "VAT" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetVAT panics if the RecordSet is empty.
func (s UserSet) SetVAT(value string) {
	s.RecordCollection.Set(models.NewFieldName("VAT", "vat"), value)
}

// Website is a getter for the value of the "Website" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Website() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Website", "website")).(string)
	return res
}

// SetWebsite is a setter for the value of the "Website" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetWebsite panics if the RecordSet is empty.
func (s UserSet) SetWebsite(value string) {
	s.RecordCollection.Set(models.NewFieldName("Website", "website"), value)
}

// WriteDate is a getter for the value of the "WriteDate" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) WriteDate() dates.DateTime {
	res, _ := s.RecordCollection.Get(models.NewFieldName("WriteDate", "write_date")).(dates.DateTime)
	return res
}

// SetWriteDate is a setter for the value of the "WriteDate" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetWriteDate panics if the RecordSet is empty.
func (s UserSet) SetWriteDate(value dates.DateTime) {
	s.RecordCollection.Set(models.NewFieldName("WriteDate", "write_date"), value)
}

// WriteUID is a getter for the value of the "WriteUID" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) WriteUID() int64 {
	res, _ := s.RecordCollection.Get(models.NewFieldName("WriteUID", "write_uid")).(int64)
	return res
}

// SetWriteUID is a setter for the value of the "WriteUID" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetWriteUID panics if the RecordSet is empty.
func (s UserSet) SetWriteUID(value int64) {
	s.RecordCollection.Set(models.NewFieldName("WriteUID", "write_uid"), value)
}

// Zip is a getter for the value of the "Zip" field of the first
// record in this RecordSet. It returns the Go zero value if the RecordSet is empty.
func (s UserSet) Zip() string {
	res, _ := s.RecordCollection.Get(models.NewFieldName("Zip", "zip")).(string)
	return res
}

// SetZip is a setter for the value of the "Zip" field of this
// RecordSet. All Records of this RecordSet will be updated. Each call to this
// method makes an update query in the database.
//
// SetZip panics if the RecordSet is empty.
func (s UserSet) SetZip(value string) {
	s.RecordCollection.Set(models.NewFieldName("Zip", "zip"), value)
}

// Super returns a RecordSet with a modified callstack so that call to the current
// method will execute the next method layer.
//
// This method is meant to be used inside a method layer function to call its parent,
// such as:
//
//    func (rs h.MyRecordSet) MyMethod() string {
//        res := rs.Super().MyMethod()
//        res += " ok!"
//        return res
//    }
//
// Calls to a different method than the current method will call its next layer only
// if the current method has been called from a layer of the other method. Otherwise,
// it will be the same as calling the other method directly.
func (s UserSet) Super() m.UserSet {
	return s.RecordCollection.Super().Wrap("User").(m.UserSet)
}

// ModelData returns a new UserData object populated with the values
// of the given FieldMap.
func (s UserSet) ModelData(fMap models.FieldMap) m.UserData {
	res := &UserData{
		models.NewModelData(models.Registry.MustGet("User")),
	}
	for k, v := range fMap {
		res.Set(models.Registry.MustGet("User").FieldName(k), v)
	}
	return res
}

// ActionArchive sets Active=false on a recordset, by calling ToggleActive to take the
// corresponding actions according to the model
func (s UserSet) ActionArchive() {
	s.Collection().Call("ActionArchive")
}

// ActionGet returns the action for the preferences popup
func (s UserSet) ActionGet() *actions.Action {
	res := s.Collection().Call("ActionGet")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// ActionShowGroups returns an action to list the groups this user belongs to
func (s UserSet) ActionShowGroups() *actions.Action {
	res := s.Collection().Call("ActionShowGroups")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// ActionUnarchive sets Active=true on a recordset, by calling ToggleActive to take the
// corresponding actions according to the model
func (s UserSet) ActionUnarchive() {
	s.Collection().Call("ActionUnarchive")
}

// AddDomainLimitOffset adds the given domain, limit, offset
// and order to the current RecordSet query.
func (s UserSet) AddDomainLimitOffset(domain domains.Domain, limit int, offset int, order string) m.UserSet {
	res := s.Collection().Call("AddDomainLimitOffset", domain, limit, offset, order)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// AddMandatoryGroups adds the group Everyone to everybody and the admin group to the admin
func (s UserSet) AddMandatoryGroups() {
	s.Collection().Call("AddMandatoryGroups")
}

// AddModifiers adds the modifiers attribute nodes to given xml doc.
func (s UserSet) AddModifiers(doc *etree.Document, fieldInfos map[string]*models.FieldInfo) {
	s.Collection().Call("AddModifiers", doc, fieldInfos)
}

// AddNameToRelations returns the given RecordData after getting the name of all 2one relation ids
func (s UserSet) AddNamesToRelations(data models.RecordData, fInfos map[string]*models.FieldInfo) models.RecordData {
	res := s.Collection().Call("AddNamesToRelations", data, fInfos)
	resTyped, _ := res.(models.RecordData)
	return resTyped
}

// Aggregates returns the result of this RecordSet query, which must by a grouped query.
func (s UserSet) Aggregates(fieldNames ...models.FieldName) []m.UserGroupAggregateRow {
	res := s.Collection().Call("Aggregates", fieldNames)
	resTyped, _ := res.([]m.UserGroupAggregateRow)
	return resTyped
}

// Authenticate the user defined by login and secret
func (s UserSet) Authenticate(login string, secret string) int64 {
	res := s.Collection().Call("Authenticate", login, secret)
	resTyped, _ := res.(int64)
	return resTyped
}

// Browse returns a new RecordSet with only the records with the given ids.
// Note that this function is just a shorcut for Search on a list of ids.
func (s UserSet) Browse(ids []int64) m.UserSet {
	res := s.Collection().Call("Browse", ids)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// BrowseOne returns a new RecordSet with only the record with the given id.
// Note that this function is just a shorcut for Search on a given id.
func (s UserSet) BrowseOne(id int64) m.UserSet {
	res := s.Collection().Call("BrowseOne", id)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// ChangePassword changes current user password. Old password must be provided explicitly
// to prevent hijacking an existing user session, or for cases where the cleartext
// password is not used to authenticate requests. It returns true or panics.
func (s UserSet) ChangePassword(oldPassword string, newPassword string) bool {
	res := s.Collection().Call("ChangePassword", oldPassword, newPassword)
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckAccessRights verifies that the operation given by "operation" is allowed for
// the current user according to the access rights.
//
// operation must be one of "read", "create", "unlink", "write".
func (s UserSet) CheckAccessRights(args webtypes.CheckAccessRightsArgs) bool {
	res := s.Collection().Call("CheckAccessRights", args)
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckActionID checks that the user's home action is valid
func (s UserSet) CheckActionID() {
	s.Collection().Call("CheckActionID")
}

// CheckCompany checks that the user's company is one of its authorized companies
func (s UserSet) CheckCompany() {
	s.Collection().Call("CheckCompany")
}

// CheckCredentials panics if the given password is not the password of the current user
func (s UserSet) CheckCredentials(pwd string) {
	s.Collection().Call("CheckCredentials", pwd)
}

// CheckExecutionPermission panics if the current user is not allowed to execute the given method.
//
// If dontPanic is false, this function will panic, otherwise it returns true
// if the user has the execution permission and false otherwise.
func (s UserSet) CheckExecutionPermission(method *models.Method, dontPanic ...bool) bool {
	res := s.Collection().Call("CheckExecutionPermission", method, dontPanic)
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckGroupSync returns true if the groups in the internal registry match exactly
// database groups of the given users. This method must be called on a singleton
func (s UserSet) CheckGroupsSync() bool {
	res := s.Collection().Call("CheckGroupsSync")
	resTyped, _ := res.(bool)
	return resTyped
}

// CheckOneUserType checks no users are both portal and users (same with public).
// This could typically happen because of implied groups.
func (s UserSet) CheckOneUserType() {
	s.Collection().Call("CheckOneUserType")
}

// CheckRecursion verifies that there is no loop in a hierarchical structure of records,
// by following the parent relationship using the 'Parent' field until a loop is detected or
// until a top-level record is found.
//
// It returns true if no loop was found, false otherwise`,
func (s UserSet) CheckRecursion() bool {
	res := s.Collection().Call("CheckRecursion")
	resTyped, _ := res.(bool)
	return resTyped
}

// ComputeAccessCount computes counts for groups, rules and ACL for this user.
func (s UserSet) ComputeAccessesCount() m.UserData {
	res := s.Collection().Call("ComputeAccessesCount")
	resTyped, _ := res.(m.UserData)
	return resTyped
}

// ComputeCompaniesCount retrieves the number of companies in the system
func (s UserSet) ComputeCompaniesCount() m.UserData {
	res := s.Collection().Call("ComputeCompaniesCount")
	resTyped, _ := res.(m.UserData)
	return resTyped
}

// ComputeDisplayName updates the DisplayName field with the result of NameGet
func (s UserSet) ComputeDisplayName() *models.ModelData {
	res := s.Collection().Call("ComputeDisplayName")
	resTyped, _ := res.(*models.ModelData)
	return resTyped
}

// ComputeLastUpdate returns the last datetime at which the record has been updated.
func (s UserSet) ComputeLastUpdate() *models.ModelData {
	res := s.Collection().Call("ComputeLastUpdate")
	resTyped, _ := res.(*models.ModelData)
	return resTyped
}

// ComputePassword is a technical function for the new password mechanism. It always returns an empty string
func (s UserSet) ComputePassword() m.UserData {
	res := s.Collection().Call("ComputePassword")
	resTyped, _ := res.(m.UserData)
	return resTyped
}

// ComputeSessionToken computes a session token for this user and given session ID.
func (s UserSet) ComputeSessionToken(sid string) string {
	res := s.Collection().Call("ComputeSessionToken", sid)
	resTyped, _ := res.(string)
	return resTyped
}

// ComputeShare checks if this is a shared user
func (s UserSet) ComputeShare() m.UserData {
	res := s.Collection().Call("ComputeShare")
	resTyped, _ := res.(m.UserData)
	return resTyped
}

// ComputeTZOffset returns the number of hours between the user TZ and GMT
func (s UserSet) ComputeTZOffset() m.UserData {
	res := s.Collection().Call("ComputeTZOffset")
	resTyped, _ := res.(m.UserData)
	return resTyped
}

// ContextGet returns a context with the user's lang, tz and uid
// This method must be called on a singleton.`,
func (s UserSet) ContextGet() *types.Context {
	res := s.Collection().Call("ContextGet")
	resTyped, _ := res.(*types.Context)
	return resTyped
}

// Copy duplicates the given User record, overridding values with overrides.
func (s UserSet) Copy(overrides m.UserData) m.UserSet {
	res := s.Collection().Call("Copy", overrides)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// CopyData copies given record's data with all its fields values, overriding values with overrides.
func (s UserSet) CopyData(overrides m.UserData) m.UserData {
	res := s.Collection().Call("CopyData", overrides)
	resTyped, _ := res.(models.RecordData)
	return resTyped.Underlying().Wrap().(m.UserData)
}

// Create inserts a User record in the database from the given data.
// Returns the created UserSet.
func (s UserSet) Create(data m.UserData) m.UserSet {
	res := s.Collection().Call("Create", data)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// CurrentUser returns a UserSet with the currently logged in user.
func (s UserSet) CurrentUser() m.UserSet {
	res := s.Collection().Call("CurrentUser")
	resTyped, _ := res.(m.UserSet)
	return resTyped
}

// DefaultGet returns a UserData with the default values for the model.
func (s UserSet) DefaultGet() m.UserData {
	res := s.Collection().Call("DefaultGet")
	resTyped, _ := res.(models.RecordData)
	return resTyped.Underlying().Wrap().(m.UserData)
}

// Enqueue queues the execution of the given method with the given arguments on this recordset.
// description will be the name given to the job.
func (s UserSet) Enqueue(description string, method models.Methoder, arguments ...interface{}) m.QueueJobSet {
	res := s.Collection().Call("Enqueue", description, method, arguments)
	resTyped, _ := res.(m.QueueJobSet)
	return resTyped
}

// Equals returns true if this RecordSet is the same as other
// i.e. they are of the same model and have the same ids
func (s UserSet) Equals(other m.UserSet) bool {
	res := s.Collection().Call("Equals", other)
	resTyped, _ := res.(bool)
	return resTyped
}

// ExecuteO2MActions executes the actions on one2many fields given by
// the list of triplets received from the client
func (s UserSet) ExecuteO2MActions(fieldName models.FieldName, info *models.FieldInfo, value interface{}) interface{} {
	res := s.Collection().Call("ExecuteO2MActions", fieldName, info, value)
	resTyped, _ := res.(interface{})
	return resTyped
}

// Fetch query the database with the current filter and returns a RecordSet
// with the queries ids.
//
// Fetch is lazy and only return ids. Use Load() instead if you want to fetch all fields.
func (s UserSet) Fetch() m.UserSet {
	res := s.Collection().Call("Fetch")
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// FieldGet returns the definition of the given field.
// The string, help, and selection (if present) attributes are translated.
func (s UserSet) FieldGet(field models.FieldName) *models.FieldInfo {
	res := s.Collection().Call("FieldGet", field)
	resTyped, _ := res.(*models.FieldInfo)
	return resTyped
}

// FieldsGet returns the definition of each field.
// The embedded fields are included.
// The string, help, and selection (if present) attributes are translated.
//
// The result map is indexed by the fields JSON names.
func (s UserSet) FieldsGet(args models.FieldsGetArgs) map[string]*models.FieldInfo {
	res := s.Collection().Call("FieldsGet", args)
	resTyped, _ := res.(map[string]*models.FieldInfo)
	return resTyped
}

// FieldsViewGet is the base implementation of the 'FieldsViewGet' method which
// gets the detailed composition of the requested view like fields, mixin,
// view architecture.
func (s UserSet) FieldsViewGet(args webtypes.FieldsViewGetParams) *webtypes.FieldsViewData {
	res := s.Collection().Call("FieldsViewGet", args)
	resTyped, _ := res.(*webtypes.FieldsViewData)
	return resTyped
}

// FormatRelationFields returns the given data with all relation fields converted to int64 or []int64
func (s UserSet) FormatRelationFields(data models.RecordData, fInfos map[string]*models.FieldInfo) models.RecordData {
	res := s.Collection().Call("FormatRelationFields", data, fInfos)
	resTyped, _ := res.(models.RecordData)
	return resTyped
}

// GetCompany returns the current user's company.
func (s UserSet) GetCompany() m.CompanySet {
	res := s.Collection().Call("GetCompany")
	resTyped, _ := res.(m.CompanySet)
	return resTyped
}

// GetCompanyCurrency returns the currency of the current user's company.
func (s UserSet) GetCompanyCurrency() m.CurrencySet {
	res := s.Collection().Call("GetCompanyCurrency")
	resTyped, _ := res.(m.CurrencySet)
	return resTyped
}

// GetFormviewAction returns an action to open the document.
// This method is meant to be overridden in addons that want
// to give specific view ids for example.`,
func (s UserSet) GetFormviewAction() *actions.Action {
	res := s.Collection().Call("GetFormviewAction")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// GetFormviewID returns an view id to open the document with.
// This method is meant to be overridden in addons that want
// to give specific view ids for example.
func (s UserSet) GetFormviewId() string {
	res := s.Collection().Call("GetFormviewId")
	resTyped, _ := res.(string)
	return resTyped
}

// GetLoginDomain returns the condition to find a user given its login.
// Base implementation is simply q.User().Login().Equals(login).
func (s UserSet) GetLoginDomain(login string) q.UserCondition {
	res := s.Collection().Call("GetLoginDomain", login)
	resTyped, _ := res.(q.UserCondition)
	return resTyped
}

// GetRecord returns the Recordset with the given externalID. It panics if the externalID does not exist.
func (s UserSet) GetRecord(externalID string) m.UserSet {
	res := s.Collection().Call("GetRecord", externalID)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

func (s UserSet) GetSessionTokenFields() models.FieldNames {
	res := s.Collection().Call("GetSessionTokenFields")
	resTyped, _ := res.(models.FieldNames)
	return resTyped
}

// GetToolbar returns a toolbar populated with the actions linked to this model
func (s UserSet) GetToolbar() webtypes.Toolbar {
	res := s.Collection().Call("GetToolbar")
	resTyped, _ := res.(webtypes.Toolbar)
	return resTyped
}

// GroupBy returns a new RecordSet grouped with the given GROUP BY expressions.
func (s UserSet) GroupBy(exprs ...models.FieldName) m.UserSet {
	res := s.Collection().Call("GroupBy", exprs)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// HasGroup returns true if this user belongs to the group with the given ID.
// If this method is called on an empty RecordSet, then it checks if the current
// user belongs to the given group.
func (s UserSet) HasGroup(groupID string) bool {
	res := s.Collection().Call("HasGroup", groupID)
	resTyped, _ := res.(bool)
	return resTyped
}

// HasMultipleGroups returns true if at least one of these users belong to more
// than one of the given groups
func (s UserSet) HasMultipleGroups(groups m.GroupSet) bool {
	res := s.Collection().Call("HasMultipleGroups", groups)
	resTyped, _ := res.(bool)
	return resTyped
}

// HashPassword returns the encrypted password hash for
// the given password.
//
// Override this method and VerifyPassword to use specific hash function.
func (s UserSet) HashPassword(pwd string) string {
	res := s.Collection().Call("HashPassword", pwd)
	resTyped, _ := res.(string)
	return resTyped
}

// Init iterates over the database to encrypt plaintext passwords
func (s UserSet) Init() {
	s.Collection().Call("Init")
}

// Intersect returns a new RecordCollection with only the records that are both
// in this RecordCollection and in the other RecordSet.
func (s UserSet) Intersect(other m.UserSet) m.UserSet {
	res := s.Collection().Call("Intersect", other)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// InverseNewPassword is used in the new password mechanism.
func (s UserSet) InverseNewPassword(value string) {
	s.Collection().Call("InverseNewPassword", value)
}

// InversePassword is called when setting a new password
func (s UserSet) InversePassword(value string) {
	s.Collection().Call("InversePassword", value)
}

// IsAdmin returns true if this user is the administrator or member of the 'Access Rights' group
func (s UserSet) IsAdmin() bool {
	res := s.Collection().Call("IsAdmin")
	resTyped, _ := res.(bool)
	return resTyped
}

// IsPublic returns true if this user is a public user (from website)
func (s UserSet) IsPublic() bool {
	res := s.Collection().Call("IsPublic")
	resTyped, _ := res.(bool)
	return resTyped
}

// IsSuperUser returns true if this user is the administrator
func (s UserSet) IsSuperUser() bool {
	res := s.Collection().Call("IsSuperUser")
	resTyped, _ := res.(bool)
	return resTyped
}

// IsSystem returns true if this user is in the system group
func (s UserSet) IsSystem() bool {
	res := s.Collection().Call("IsSystem")
	resTyped, _ := res.(bool)
	return resTyped
}

// Limit returns a new RecordSet with only the first 'limit' records.
func (s UserSet) Limit(limit int) m.UserSet {
	res := s.Collection().Call("Limit", limit)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// Load looks up cache for fields of the RecordCollection and
// query database for missing values.
// fields are the fields to retrieve in the expression format,
// i.e. "User.Profile.Age" or "user_id.profile_id.age".
// If no fields are given, all DB columns of the RecordCollection's
// model are retrieved.
func (s UserSet) Load(fields ...models.FieldName) m.UserSet {
	res := s.Collection().Call("Load", fields)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// LoadViews returns the data for all the views and filters required in the parameters.
func (s UserSet) LoadViews(args webtypes.LoadViewsArgs) *webtypes.LoadViewsData {
	res := s.Collection().Call("LoadViews", args)
	resTyped, _ := res.(*webtypes.LoadViewsData)
	return resTyped
}

// ManageGroupsOnFields adds the invisible attribute to fields nodes if the current
// user does not belong to one of the groups of the 'groups' attribute
func (s UserSet) ManageGroupsOnFields(doc *etree.Document, fieldInfos map[string]*models.FieldInfo) {
	s.Collection().Call("ManageGroupsOnFields", doc, fieldInfos)
}

// NameGet retrieves the human readable name of this record.`,
func (s UserSet) NameGet() string {
	res := s.Collection().Call("NameGet")
	resTyped, _ := res.(string)
	return resTyped
}

// NameSearch searches for records that have a display name matching the given
// "name" pattern when compared with the given "operator", while also
// matching the optional search domain ("args").
//
// This is used for example to provide suggestions based on a partial
// value for a relational field. Sometimes be seen as the inverse
// function of NameGet but it is not guaranteed to be.
func (s UserSet) NameSearch(params webtypes.NameSearchParams) []webtypes.RecordIDWithName {
	res := s.Collection().Call("NameSearch", params)
	resTyped, _ := res.([]webtypes.RecordIDWithName)
	return resTyped
}

// New creates a User record in memory from the given data.
// Such UserSet has a negative ID and cannot be reloaded from the database
func (s UserSet) New(data m.UserData) m.UserSet {
	res := s.Collection().Call("New", data)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// NormalizeM2MData converts the list of triplets received from the client into the final list of ids
// to keep in the Many2Many relationship of this model through the given field.
func (s UserSet) NormalizeM2MData(fieldName models.FieldName, info *models.FieldInfo, value interface{}) interface{} {
	res := s.Collection().Call("NormalizeM2MData", fieldName, info, value)
	resTyped, _ := res.(interface{})
	return resTyped
}

// Offset returns a new RecordSet with only the records starting at offset
func (s UserSet) Offset(offset int) m.UserSet {
	res := s.Collection().Call("Offset", offset)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// Onchange returns the values that must be modified according to each field's Onchange
// method in the pseudo-record given as params.Values`,
func (s UserSet) Onchange(params models.OnchangeParams) models.OnchangeResult {
	res := s.Collection().Call("Onchange", params)
	resTyped, _ := res.(models.OnchangeResult)
	return resTyped
}

// OnchangeLogin matches the email if the login is an email
func (s UserSet) OnchangeLogin() m.UserData {
	res := s.Collection().Call("OnchangeLogin")
	resTyped, _ := res.(m.UserData)
	return resTyped
}

// OrderBy returns a new RecordSet ordered by the given ORDER BY expressions.
// Each expression contains a field name and optionally one of "asc" or "desc", such as:
//
// rs.OrderBy("Company", "Name desc")
func (s UserSet) OrderBy(exprs ...string) m.UserSet {
	res := s.Collection().Call("OrderBy", exprs)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// PostProcessCreateValues updates FK of related records created at the same time.
//
// This method is meant to be called with the second returned value of ProcessCreateValues
// after record creation.
func (s UserSet) PostProcessCreateValues(data models.RecordData) {
	s.Collection().Call("PostProcessCreateValues", data)
}

// PostProcessFilters transforms a map[models.FieldName]models.Conditioner
// in a map[string][]interface{} which acts as a map of domains.
func (s UserSet) PostProcessFilters(in map[models.FieldName]models.Conditioner) map[string][]interface{} {
	res := s.Collection().Call("PostProcessFilters", in)
	resTyped, _ := res.(map[string][]interface{})
	return resTyped
}

// PreferenceChangePassword is called when clicking 'Change Password' in the preferences popup
func (s UserSet) PreferenceChangePassword() *actions.Action {
	res := s.Collection().Call("PreferenceChangePassword")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// PreferenceSave is called when validating the preferences popup
func (s UserSet) PreferenceSave() *actions.Action {
	res := s.Collection().Call("PreferenceSave")
	resTyped, _ := res.(*actions.Action)
	return resTyped
}

// ProcessCreateValues updates the given data values for Create method to be
// compatible with the ORM, in particular for relation fields.
//
// It returns a first FieldMap to be used as argument to the Create method, and
// a second map to be used with a subsequent call to PostProcessCreateValues (for
// updating FKs pointing to the newly created record).
func (s UserSet) ProcessCreateValues(data models.RecordData) (models.RecordData, models.RecordData) {
	res := s.Collection().CallMulti("ProcessCreateValues", data)
	resTyped0, _ := res[0].(models.RecordData)
	resTyped1, _ := res[1].(models.RecordData)
	return resTyped0, resTyped1
}

// ProcessElementAttrs returns a modifiers map according to the domain
// in attrs of the given element
func (s UserSet) ProcessElementAttrs(element *etree.Element, fieldInfos map[string]*models.FieldInfo) map[string]interface{} {
	res := s.Collection().Call("ProcessElementAttrs", element, fieldInfos)
	resTyped, _ := res.(map[string]interface{})
	return resTyped
}

// ProcessFieldElementModifiers modifies the given modifiers map by taking into account:
// - 'invisible', 'readonly' and 'required' attributes in field tags
// - 'ReadOnly' and 'Required' parameters of the model's field'
// It returns the modified map.
func (s UserSet) ProcessFieldElementModifiers(element *etree.Element, fieldInfos map[string]*models.FieldInfo, modifiers map[string]interface{}) map[string]interface{} {
	res := s.Collection().Call("ProcessFieldElementModifiers", element, fieldInfos, modifiers)
	resTyped, _ := res.(map[string]interface{})
	return resTyped
}

// ProcessView makes all the necessary modifications to the view
// arch and returns the new xml string.`,
func (s UserSet) ProcessView(arch *etree.Document, fieldInfos map[string]*models.FieldInfo) string {
	res := s.Collection().Call("ProcessView", arch, fieldInfos)
	resTyped, _ := res.(string)
	return resTyped
}

// ProcessWriteValues updates the given data values for Write method to be
// compatible with the ORM, in particular for relation fields
func (s UserSet) ProcessWriteValues(data models.RecordData) models.RecordData {
	res := s.Collection().Call("ProcessWriteValues", data)
	resTyped, _ := res.(models.RecordData)
	return resTyped
}

// Read reads the database and returns a slice of FieldMap of the given model.
func (s UserSet) Read(fields models.FieldNames) []models.RecordData {
	res := s.Collection().Call("Read", fields)
	resTyped, _ := res.([]models.RecordData)
	return resTyped
}

// ReadGroup gets a list of record aggregates according to the given parameters.
func (s UserSet) ReadGroup(params webtypes.ReadGroupParams) []models.FieldMap {
	res := s.Collection().Call("ReadGroup", params)
	resTyped, _ := res.([]models.FieldMap)
	return resTyped
}

// SQLFromCondition returns the WHERE clause sql and arguments corresponding to
// the given condition.`,
func (s UserSet) SQLFromCondition(c *models.Condition) (string, models.SQLParams) {
	res := s.Collection().CallMulti("SQLFromCondition", c)
	resTyped0, _ := res[0].(string)
	resTyped1, _ := res[1].(models.SQLParams)
	return resTyped0, resTyped1
}

// Search returns a new UserSet filtering on the current one with the additional given Condition
func (s UserSet) Search(condition q.UserCondition) m.UserSet {
	res := s.Collection().Call("Search", condition)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// SearchAll returns a RecordSet with all items of the table, regardless of the
// current RecordSet query. It is mainly meant to be used on an empty RecordSet.
func (s UserSet) SearchAll() m.UserSet {
	res := s.Collection().Call("SearchAll")
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// SearchByName searches for User records that have a display name matching the given
// "name" pattern when compared with the given "op" operator, while also
// matching the optional search condition ("additionalCond").
//
// This is used for example to provide suggestions based on a partial
// value for a relational field. Sometimes be seen as the inverse
// function of NameGet but it is not guaranteed to be.
func (s UserSet) SearchByName(name string, op operator.Operator, additionalCond q.UserCondition, limit int) m.UserSet {
	res := s.Collection().Call("SearchByName", name, op, additionalCond, limit)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// SearchCount fetch from the database the number of records that match the RecordSet conditions.
func (s UserSet) SearchCount() int {
	res := s.Collection().Call("SearchCount")
	resTyped, _ := res.(int)
	return resTyped
}

// SearchDomain execute a search on the given domain.
func (s UserSet) SearchDomain(domain domains.Domain) m.CommonMixinSet {
	res := s.Collection().Call("SearchDomain", domain)
	resTyped, _ := res.(m.CommonMixinSet)
	return resTyped
}

// SearchRead retrieves database records according to the filters defined in params.
func (s UserSet) SearchRead(params webtypes.SearchParams) []models.RecordData {
	res := s.Collection().Call("SearchRead", params)
	resTyped, _ := res.([]models.RecordData)
	return resTyped
}

// SelfReadableFields returns the list of its own fields that a user can read.
func (s UserSet) SelfReadableFields() map[string]bool {
	res := s.Collection().Call("SelfReadableFields")
	resTyped, _ := res.(map[string]bool)
	return resTyped
}

// SelfWritableFields returns the list of its own fields that a user can write.
func (s UserSet) SelfWritableFields() map[string]bool {
	res := s.Collection().Call("SelfWritableFields")
	resTyped, _ := res.(map[string]bool)
	return resTyped
}

// SortedByField returns a new record set with the same records as rc but sorted by the given field.
// If reverse is true, the sort is done in reversed order
func (s UserSet) SortedByField(namer models.FieldName, reverse bool) m.UserSet {
	res := s.Collection().Call("SortedByField", namer, reverse)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// SortedDefault returns a new record set with the same records as rc but sorted according
// to the default order of this model
func (s UserSet) SortedDefault() m.UserSet {
	res := s.Collection().Call("SortedDefault")
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// Subtract returns a RecordSet with the Records that are in this
// RecordCollection but not in the given 'other' one.
// The result is guaranteed to be a set of unique records.
func (s UserSet) Subtract(other m.UserSet) m.UserSet {
	res := s.Collection().Call("Subtract", other)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// Sudo returns a new RecordSet with the given userID
// or the superuser ID if not specified
func (s UserSet) Sudo(userID ...int64) m.UserSet {
	res := s.Collection().Call("Sudo", userID)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// SyncMemberships synchronises the users memberships with the Hexya internal registry
func (s UserSet) SyncMemberships() {
	s.Collection().Call("SyncMemberships")
}

// ToggleActive toggles the Active field of this object if it exists.
func (s UserSet) ToggleActive() {
	s.Collection().Call("ToggleActive")
}

// Union returns a new RecordSet that is the union of this RecordSet and the given
// "other" RecordSet. The result is guaranteed to be a set of unique records.
func (s UserSet) Union(other m.UserSet) m.UserSet {
	res := s.Collection().Call("Union", other)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// Unlink deletes the given records in the database.
func (s UserSet) Unlink() int64 {
	res := s.Collection().Call("Unlink")
	resTyped, _ := res.(int64)
	return resTyped
}

// UpdateLastLogin updates the last login date of the user
func (s UserSet) UpdateLastLogin() {
	s.Collection().Call("UpdateLastLogin")
}

// VerifyPassword returns true if the given pwd matches the given password hash.
//
// Override this method and HashPassword to use custom password hash function.
func (s UserSet) VerifyPassword(pwd string, hash string) bool {
	res := s.Collection().Call("VerifyPassword", pwd, hash)
	resTyped, _ := res.(bool)
	return resTyped
}

// WebReadGroup returns the result of a read_group (and optionally search for and read records inside each
// group), and the total number of groups matching the search domain.
func (s UserSet) WebReadGroup(params webtypes.WebReadGroupParams) webtypes.WebReadGroupResult {
	res := s.Collection().Call("WebReadGroup", params)
	resTyped, _ := res.(webtypes.WebReadGroupResult)
	return resTyped
}

// WebReadGroupPrivate performs a read_group and optionally a web_search_read for each group.
func (s UserSet) WebReadGroupPrivate(params webtypes.WebReadGroupParams) []models.FieldMap {
	res := s.Collection().Call("WebReadGroupPrivate", params)
	resTyped, _ := res.([]models.FieldMap)
	return resTyped
}

// WebSearchRead performs a search_read and a search_count.
func (s UserSet) WebSearchRead(params webtypes.SearchParams) webtypes.SearchReadResult {
	res := s.Collection().Call("WebSearchRead", params)
	resTyped, _ := res.(webtypes.SearchReadResult)
	return resTyped
}

// WithContext returns a copy of the current RecordSet with
// its context extended by the given key and value.
func (s UserSet) WithContext(key string, value interface{}) m.UserSet {
	res := s.Collection().Call("WithContext", key, value)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// WithEnv returns a copy of the current RecordSet with the given Environment.
func (s UserSet) WithEnv(env models.Environment) m.UserSet {
	res := s.Collection().Call("WithEnv", env)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// WithNewContext returns a copy of the current RecordSet with its context
// replaced by the given one.
func (s UserSet) WithNewContext(context *types.Context) m.UserSet {
	res := s.Collection().Call("WithNewContext", context)
	resTyped := res.(models.RecordSet).Collection().Wrap("User").(m.UserSet)
	return resTyped
}

// Write is the base implementation of the 'Write' method which updates
// User records in the database with the given data.
func (s UserSet) Write(data m.UserData) bool {
	res := s.Collection().Call("Write", data)
	resTyped, _ := res.(bool)
	return resTyped
}

// Aggregates returns the result of this RecordSet query, which must by a grouped query.
func m_User_Aggregates(rs UserSet, fieldNames ...models.FieldName) []m.UserGroupAggregateRow {
	lines := rs.RecordCollection.Aggregates(fieldNames...)
	res := make([]m.UserGroupAggregateRow, len(lines))
	for i, l := range lines {
		res[i] = UserGroupAggregateRow{
			values: l.Values.Wrap().(m.UserData),
			count:  l.Count,
			condition: q.UserCondition{
				Condition: l.Condition,
			},
		}
	}
	return res
}

func init() {
	models.CreateModel("User", 0)
	models.Registry.MustGet("User").AddFields(map[string]models.FieldDefinition{
		"ActiveLangCount":       models.DummyField{},
		"Banks":                 models.DummyField{},
		"Barcode":               models.DummyField{},
		"Categories":            models.DummyField{},
		"Children":              models.DummyField{},
		"City":                  models.DummyField{},
		"Color":                 models.DummyField{},
		"Comment":               models.DummyField{},
		"CommercialCompanyName": models.DummyField{},
		"CommercialPartner":     models.DummyField{},
		"CompanyName":           models.DummyField{},
		"CompanyType":           models.DummyField{},
		"ContactAddress":        models.DummyField{},
		"Country":               models.DummyField{},
		"CreateDate":            models.DummyField{},
		"CreateUID":             models.DummyField{},
		"CreditLimit":           models.DummyField{},
		"Date":                  models.DummyField{},
		"DisplayName":           models.DummyField{},
		"Email":                 models.DummyField{},
		"EmailFormatted":        models.DummyField{},
		"Employee":              models.DummyField{},
		"Function":              models.DummyField{},
		"HexyaExternalID":       models.DummyField{},
		"HexyaVersion":          models.DummyField{},
		"Image":                 models.DummyField{},
		"ImageMedium":           models.DummyField{},
		"ImageSmall":            models.DummyField{},
		"Industry":              models.DummyField{},
		"IsCompany":             models.DummyField{},
		"Lang":                  models.DummyField{},
		"LastUpdate":            models.DummyField{},
		"Latitude":              models.DummyField{},
		"Longitude":             models.DummyField{},
		"Mobile":                models.DummyField{},
		"Name":                  models.DummyField{},
		"Parent":                models.DummyField{},
		"ParentName":            models.DummyField{},
		"PartnerShare":          models.DummyField{},
		"Phone":                 models.DummyField{},
		"Ref":                   models.DummyField{},
		"SameVATPartner":        models.DummyField{},
		"State":                 models.DummyField{},
		"Street":                models.DummyField{},
		"Street2":               models.DummyField{},
		"TZ":                    models.DummyField{},
		"Title":                 models.DummyField{},
		"Type":                  models.DummyField{},
		"User":                  models.DummyField{},
		"Users":                 models.DummyField{},
		"VAT":                   models.DummyField{},
		"Website":               models.DummyField{},
		"WriteDate":             models.DummyField{},
		"WriteUID":              models.DummyField{},
		"Zip":                   models.DummyField{},
	})
	models.Registry.MustGet("User").AddEmptyMethod("ActionArchive")
	models.Registry.MustGet("User").AddEmptyMethod("ActionGet")
	models.Registry.MustGet("User").AddEmptyMethod("ActionShowGroups")
	models.Registry.MustGet("User").AddEmptyMethod("ActionUnarchive")
	models.Registry.MustGet("User").AddEmptyMethod("AddDomainLimitOffset")
	models.Registry.MustGet("User").AddEmptyMethod("AddMandatoryGroups")
	models.Registry.MustGet("User").AddEmptyMethod("AddModifiers")
	models.Registry.MustGet("User").AddEmptyMethod("AddNamesToRelations")
	models.Registry.MustGet("User").AddEmptyMethod("Authenticate")
	models.Registry.MustGet("User").AddEmptyMethod("Browse")
	models.Registry.MustGet("User").AddEmptyMethod("BrowseOne")
	models.Registry.MustGet("User").AddEmptyMethod("ChangePassword")
	models.Registry.MustGet("User").AddEmptyMethod("CheckAccessRights")
	models.Registry.MustGet("User").AddEmptyMethod("CheckActionID")
	models.Registry.MustGet("User").AddEmptyMethod("CheckCompany")
	models.Registry.MustGet("User").AddEmptyMethod("CheckCredentials")
	models.Registry.MustGet("User").AddEmptyMethod("CheckExecutionPermission")
	models.Registry.MustGet("User").AddEmptyMethod("CheckGroupsSync")
	models.Registry.MustGet("User").AddEmptyMethod("CheckOneUserType")
	models.Registry.MustGet("User").AddEmptyMethod("CheckRecursion")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeAccessesCount")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeCompaniesCount")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeDisplayName")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeLastUpdate")
	models.Registry.MustGet("User").AddEmptyMethod("ComputePassword")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeSessionToken")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeShare")
	models.Registry.MustGet("User").AddEmptyMethod("ComputeTZOffset")
	models.Registry.MustGet("User").AddEmptyMethod("ContextGet")
	models.Registry.MustGet("User").AddEmptyMethod("Copy")
	models.Registry.MustGet("User").AddEmptyMethod("CopyData")
	models.Registry.MustGet("User").AddEmptyMethod("Create")
	models.Registry.MustGet("User").AddEmptyMethod("CurrentUser")
	models.Registry.MustGet("User").AddEmptyMethod("DefaultGet")
	models.Registry.MustGet("User").AddEmptyMethod("Enqueue")
	models.Registry.MustGet("User").AddEmptyMethod("Equals")
	models.Registry.MustGet("User").AddEmptyMethod("ExecuteO2MActions")
	models.Registry.MustGet("User").AddEmptyMethod("Fetch")
	models.Registry.MustGet("User").AddEmptyMethod("FieldGet")
	models.Registry.MustGet("User").AddEmptyMethod("FieldsGet")
	models.Registry.MustGet("User").AddEmptyMethod("FieldsViewGet")
	models.Registry.MustGet("User").AddEmptyMethod("FormatRelationFields")
	models.Registry.MustGet("User").AddEmptyMethod("GetCompany")
	models.Registry.MustGet("User").AddEmptyMethod("GetCompanyCurrency")
	models.Registry.MustGet("User").AddEmptyMethod("GetFormviewAction")
	models.Registry.MustGet("User").AddEmptyMethod("GetFormviewId")
	models.Registry.MustGet("User").AddEmptyMethod("GetLoginDomain")
	models.Registry.MustGet("User").AddEmptyMethod("GetRecord")
	models.Registry.MustGet("User").AddEmptyMethod("GetSessionTokenFields")
	models.Registry.MustGet("User").AddEmptyMethod("GetToolbar")
	models.Registry.MustGet("User").AddEmptyMethod("GroupBy")
	models.Registry.MustGet("User").AddEmptyMethod("HasGroup")
	models.Registry.MustGet("User").AddEmptyMethod("HasMultipleGroups")
	models.Registry.MustGet("User").AddEmptyMethod("HashPassword")
	models.Registry.MustGet("User").AddEmptyMethod("Init")
	models.Registry.MustGet("User").AddEmptyMethod("Intersect")
	models.Registry.MustGet("User").AddEmptyMethod("InverseNewPassword")
	models.Registry.MustGet("User").AddEmptyMethod("InversePassword")
	models.Registry.MustGet("User").AddEmptyMethod("IsAdmin")
	models.Registry.MustGet("User").AddEmptyMethod("IsPublic")
	models.Registry.MustGet("User").AddEmptyMethod("IsSuperUser")
	models.Registry.MustGet("User").AddEmptyMethod("IsSystem")
	models.Registry.MustGet("User").AddEmptyMethod("Limit")
	models.Registry.MustGet("User").AddEmptyMethod("Load")
	models.Registry.MustGet("User").AddEmptyMethod("LoadViews")
	models.Registry.MustGet("User").AddEmptyMethod("ManageGroupsOnFields")
	models.Registry.MustGet("User").AddEmptyMethod("NameGet")
	models.Registry.MustGet("User").AddEmptyMethod("NameSearch")
	models.Registry.MustGet("User").AddEmptyMethod("New")
	models.Registry.MustGet("User").AddEmptyMethod("NormalizeM2MData")
	models.Registry.MustGet("User").AddEmptyMethod("Offset")
	models.Registry.MustGet("User").AddEmptyMethod("Onchange")
	models.Registry.MustGet("User").AddEmptyMethod("OnchangeLogin")
	models.Registry.MustGet("User").AddEmptyMethod("OrderBy")
	models.Registry.MustGet("User").AddEmptyMethod("PostProcessCreateValues")
	models.Registry.MustGet("User").AddEmptyMethod("PostProcessFilters")
	models.Registry.MustGet("User").AddEmptyMethod("PreferenceChangePassword")
	models.Registry.MustGet("User").AddEmptyMethod("PreferenceSave")
	models.Registry.MustGet("User").AddEmptyMethod("ProcessCreateValues")
	models.Registry.MustGet("User").AddEmptyMethod("ProcessElementAttrs")
	models.Registry.MustGet("User").AddEmptyMethod("ProcessFieldElementModifiers")
	models.Registry.MustGet("User").AddEmptyMethod("ProcessView")
	models.Registry.MustGet("User").AddEmptyMethod("ProcessWriteValues")
	models.Registry.MustGet("User").AddEmptyMethod("Read")
	models.Registry.MustGet("User").AddEmptyMethod("ReadGroup")
	models.Registry.MustGet("User").AddEmptyMethod("SQLFromCondition")
	models.Registry.MustGet("User").AddEmptyMethod("Search")
	models.Registry.MustGet("User").AddEmptyMethod("SearchAll")
	models.Registry.MustGet("User").AddEmptyMethod("SearchByName")
	models.Registry.MustGet("User").AddEmptyMethod("SearchCount")
	models.Registry.MustGet("User").AddEmptyMethod("SearchDomain")
	models.Registry.MustGet("User").AddEmptyMethod("SearchRead")
	models.Registry.MustGet("User").AddEmptyMethod("SelfReadableFields")
	models.Registry.MustGet("User").AddEmptyMethod("SelfWritableFields")
	models.Registry.MustGet("User").AddEmptyMethod("SortedByField")
	models.Registry.MustGet("User").AddEmptyMethod("SortedDefault")
	models.Registry.MustGet("User").AddEmptyMethod("Subtract")
	models.Registry.MustGet("User").AddEmptyMethod("Sudo")
	models.Registry.MustGet("User").AddEmptyMethod("SyncMemberships")
	models.Registry.MustGet("User").AddEmptyMethod("ToggleActive")
	models.Registry.MustGet("User").AddEmptyMethod("Union")
	models.Registry.MustGet("User").AddEmptyMethod("Unlink")
	models.Registry.MustGet("User").AddEmptyMethod("UpdateLastLogin")
	models.Registry.MustGet("User").AddEmptyMethod("VerifyPassword")
	models.Registry.MustGet("User").AddEmptyMethod("WebReadGroup")
	models.Registry.MustGet("User").AddEmptyMethod("WebReadGroupPrivate")
	models.Registry.MustGet("User").AddEmptyMethod("WebSearchRead")
	models.Registry.MustGet("User").AddEmptyMethod("WithContext")
	models.Registry.MustGet("User").AddEmptyMethod("WithEnv")
	models.Registry.MustGet("User").AddEmptyMethod("WithNewContext")
	models.Registry.MustGet("User").AddEmptyMethod("Write")
	models.Registry.MustGet("User").NewMethod("Aggregates", m_User_Aggregates)
	models.RegisterRecordSetWrapper("User", UserSet{})
	models.RegisterModelDataWrapper("User", UserData{})
}
